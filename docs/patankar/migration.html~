<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>migration API documentation</title>
<meta name="description" content="SFPPy Module: Migration Solver
Implements a **1D finite-volume mass transfer solver (`senspatankar`)** for multilayer structures.
Uses a modified …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>migration</code></h1>
</header>
<section id="section-intro">
<p>===============================================================================
SFPPy Module: Migration Solver
===============================================================================
Implements a <strong>1D finite-volume mass transfer solver (<code><a title="migration.senspatankar" href="#migration.senspatankar">senspatankar()</a></code>)</strong> for multilayer structures.
Uses a modified Patankar scheme with exact solutions to handle partitioning at interfaces.</p>
<p><strong>Main Components:</strong>
- <strong><code><a title="migration.senspatankar" href="#migration.senspatankar">senspatankar()</a></code></strong> (Main solver)
- Computes time evolution of a migrating substance in a multilayer structure
- Supports <strong>Robin, impervious, and periodic</strong> boundary conditions
- Stores simulation results in <code><a title="migration.SensPatankarResult" href="#migration.SensPatankarResult">SensPatankarResult</a></code>
- <strong><code><a title="migration.SensPatankarResult" href="#migration.SensPatankarResult">SensPatankarResult</a></code></strong> (Stores simulation outputs)
- Concentration profiles in packaging (<code>Cx</code>) and food (<code>CF</code>)
- Time-dependent fluxes
- Includes interpolation and visualization methods</p>
<p><strong>Integration with SFPPy Modules:</strong>
- Requires <code>layer.py</code> to define multilayer structures.
- Uses <code>food.py</code> to set food contact conditions.
- Relies on <code>property.py</code> for migration parameters (D, K).
- Calls <code>geometry.py</code> when volume/surface area calculations are needed.</p>
<p>Example:</p>
<pre><code class="language-python">from patankar.migration import senspatankar
solution = senspatankar(multilayer, medium)
solution.plotCF()
</code></pre>
<p>===============================================================================
Details
===============================================================================</p>
<p>This module provides a solver (<code><a title="migration.senspatankar" href="#migration.senspatankar">senspatankar()</a></code>) to simulate in 1D the mass transfer of a substance
initially distributed into a multilayer packaging structure (<code><a title="migration.layer" href="#migration.layer">layer</a></code>) into a contacting medium (<code><a title="migration.foodlayer" href="#migration.foodlayer">foodlayer</a></code>).
It uses a finite-volume method adapted from the Patankar scheme to handle partition coefficients between all layers,
as well as between the food and the contact layer (food is on the left). The right boundary condition is assumed
impervious (no mass transfer at the right edge).</p>
<p>The numerical method has been published here:
Nguyen, P.-M., Goujon, A., Sauvegrain, P. and Vitrac, O. (2013),
A computer-aided methodology to design safe food packaging and related systems.
AIChE J., 59: 1183-1212. <a href="https://doi.org/10.1002/aic.14056">https://doi.org/10.1002/aic.14056</a></p>
<p>The module offers :
- methods to simulate mass transfer under various boudary conditions (Robin, impervious, periodic),
- simulation chaining
- result management (merging, edition&hellip;)
- plotting and printing to disk capabilities</p>
<h2 id="classes">Classes</h2>
<ul>
<li>SensPatankarResult</li>
</ul>
<h2 id="functions">Functions</h2>
<ul>
<li>senspatankar(multilayer, medium, t=None, autotime=True, timescale="sqrt", ntimes=1e4, RelTol=1e-4, AbsTol=1e-4)</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python">
    from patankar.food import ethanol
    from patankar.layer import layer

    # Create medium and layers
    medium = ethanol()
    A = layer(layername=&quot;layer A&quot;)
    B = layer(layername=&quot;layer B&quot;)
    multilayer = A + B

    # Run solver
    sol = senspatankar(multilayer, medium)

    # Plot results
    sol.plotCF()
    sol.plotC()
</code></pre>
<p>@version: 1.0
@project: SFPPy - SafeFoodPackaging Portal in Python initiative
@author: INRAE\olivier.vitrac@agroparistech.fr
@licence: MIT
@Date: 2022-01-17
@rev: 2025-02-24</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
===============================================================================
SFPPy Module: Migration Solver
===============================================================================
Implements a **1D finite-volume mass transfer solver (`senspatankar`)** for multilayer structures.
Uses a modified Patankar scheme with exact solutions to handle partitioning at interfaces.

**Main Components:**
- **`senspatankar`** (Main solver)
    - Computes time evolution of a migrating substance in a multilayer structure
    - Supports **Robin, impervious, and periodic** boundary conditions
    - Stores simulation results in `SensPatankarResult`
- **`SensPatankarResult`** (Stores simulation outputs)
    - Concentration profiles in packaging (`Cx`) and food (`CF`)
    - Time-dependent fluxes
    - Includes interpolation and visualization methods

**Integration with SFPPy Modules:**
- Requires `layer.py` to define multilayer structures.
- Uses `food.py` to set food contact conditions.
- Relies on `property.py` for migration parameters (D, K).
- Calls `geometry.py` when volume/surface area calculations are needed.

Example:
```python
from patankar.migration import senspatankar
solution = senspatankar(multilayer, medium)
solution.plotCF()
```


===============================================================================
Details
===============================================================================

This module provides a solver (``senspatankar``) to simulate in 1D the mass transfer of a substance
initially distributed into a multilayer packaging structure (``layer``) into a contacting medium (``foodlayer``).
It uses a finite-volume method adapted from the Patankar scheme to handle partition coefficients between all layers,
as well as between the food and the contact layer (food is on the left). The right boundary condition is assumed
impervious (no mass transfer at the right edge).

The numerical method has been published here:
    Nguyen, P.-M., Goujon, A., Sauvegrain, P. and Vitrac, O. (2013),
    A computer-aided methodology to design safe food packaging and related systems.
    AIChE J., 59: 1183-1212. https://doi.org/10.1002/aic.14056

The module offers :
    - methods to simulate mass transfer under various boudary conditions (Robin, impervious, periodic),
    - simulation chaining
    - result management (merging, edition...)
    - plotting and printing to disk capabilities


Classes
-------
- SensPatankarResult

Functions
---------
- senspatankar(multilayer, medium, t=None, autotime=True, timescale=&#34;sqrt&#34;, ntimes=1e4, RelTol=1e-4, AbsTol=1e-4)

Example
-------
```python

    from patankar.food import ethanol
    from patankar.layer import layer

    # Create medium and layers
    medium = ethanol()
    A = layer(layername=&#34;layer A&#34;)
    B = layer(layername=&#34;layer B&#34;)
    multilayer = A + B

    # Run solver
    sol = senspatankar(multilayer, medium)

    # Plot results
    sol.plotCF()
    sol.plotC()
```

@version: 1.0
@project: SFPPy - SafeFoodPackaging Portal in Python initiative
@author: INRAE\\olivier.vitrac@agroparistech.fr
@licence: MIT
@Date: 2022-01-17
@rev: 2025-02-24

&#34;&#34;&#34;
# Dependencies
import os
import random
import re
from datetime import datetime
from copy import deepcopy as duplicate
import numpy as np
from scipy.integrate import solve_ivp
from scipy.sparse import diags, coo_matrix
from scipy.interpolate import interp1d
from scipy.integrate import simpson, cumulative_trapezoid
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as mcolors
from matplotlib.figure import Figure
import pandas as pd

# Local dependencies
from patankar.layer import layer, check_units
from patankar.food import foodphysics,foodlayer

__all__ = [&#39;CFSimulationContainer&#39;, &#39;Cprofile&#39;, &#39;PrintableFigure&#39;, &#39;SensPatankarResult&#39;, &#39;autoname&#39;, &#39;check_units&#39;, &#39;compute_fc_profile_PBC&#39;, &#39;compute_fv_profile&#39;, &#39;custom_plt_figure&#39;, &#39;custom_plt_subplots&#39;, &#39;foodlayer&#39;, &#39;foodphysics&#39;, &#39;is_valid_figure&#39;, &#39;layer&#39;, &#39;print_figure&#39;, &#39;print_pdf&#39;, &#39;print_png&#39;, &#39;restartfile&#39;, &#39;restartfile_senspantakar&#39;, &#39;rgb&#39;, &#39;senspatankar&#39;, &#39;tooclear&#39;]

__project__ = &#34;SFPPy&#34;
__author__ = &#34;Olivier Vitrac&#34;
__copyright__ = &#34;Copyright 2022&#34;
__credits__ = [&#34;Olivier Vitrac&#34;]
__license__ = &#34;MIT&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;1.2&#34;

# Plot configuration (preferred units)
plotconfig = {
    &#34;tscale&#34;: 24 * 3600, # days used as time scale
    &#34;tunit&#34;: &#34;days&#34;,
    &#34;lscale&#34;: 1e-6, # µm
    &#34;lunit&#34;: &#34;µm&#34;,
    &#34;Cscale&#34;: 1,
    &#34;Cunit&#34;: &#34;a.u.&#34;
    }
_fig_metadata_atrr_ = &#34;__filename__&#34;
# %% Private functions and classes

def autoname(nchars=6, charset=&#34;a-zA-Z0-9&#34;):
    &#34;&#34;&#34;
    Generates a random simulation name.

    Parameters:
    - nchars (int): Number of characters in the name (default: 6).
    - charset (str): Character set pattern (e.g., &#34;a-zA-Z0-9&#34;).

    Returns:
    - str: A randomly generated name.
    &#34;&#34;&#34;

    # Expand regex-like charset pattern
    char_pool = []
    # Find all ranges (e.g., &#34;a-z&#34;, &#34;A-Z&#34;, &#34;0-9&#34;)
    pattern = re.findall(r&#39;([a-zA-Z0-9])\-([a-zA-Z0-9])&#39;, charset)
    for start, end in pattern:
        char_pool.extend(chr(c) for c in range(ord(start), ord(end) + 1))
    # Include any explicit characters (e.g., &#34;ABC&#34; in &#34;ABC0-9&#34;)
    explicit_chars = re.sub(r&#39;([a-zA-Z0-9])\-([a-zA-Z0-9])&#39;, &#39;&#39;, charset)  # Remove ranges
    char_pool.extend(explicit_chars)
    # Remove duplicates and sort (just for readability)
    char_pool = sorted(set(char_pool))
    # Generate random name
    return &#39;&#39;.join(random.choices(char_pool, k=nchars))

def is_valid_figure(fig):
    &#34;&#34;&#34;
    Checks if `fig` is a valid and open Matplotlib figure.

    Parameters:
    - fig: object to check

    Returns:
    - bool: True if `fig` is a valid, open Matplotlib figure.
    &#34;&#34;&#34;
    return isinstance(fig, Figure) and plt.fignum_exists(fig.number)

def _generate_figname(fig, extension):
    &#34;&#34;&#34;
    Generate a clean filename based on metadata or current date/time.

    Parameters:
    - fig: Matplotlib figure object.
    - extension: File extension (&#39;.pdf&#39; or &#39;.png&#39;).

    Returns:
    - str: Cleaned filename with correct extension.
    &#34;&#34;&#34;
    # Try to retrieve the hidden filename metadata
    if hasattr(fig, _fig_metadata_atrr_):
        filename = getattr(fig, _fig_metadata_atrr_)
    else:
        # Default: Use date-time format if metadata is missing
        filename = &#34;fig&#34; + datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;)
    # Clean filename (replace spaces, trim, remove special characters)
    filename = filename.strip().replace(&#34; &#34;, &#34;_&#34;)
    # Ensure correct file extension
    if not filename.lower().endswith(extension):
        filename += extension
    return filename

def tooclear(color, threshold=0.6, correction=0.15):
    &#34;&#34;&#34;
    Darkens a too-bright RGB(A) color tuple.

    Parameters:
    -----------
    color : tuple (3 or 4 elements)
        RGB or RGBA color in [0,1] range.
    threshold : float, optional (default=0.6)
        Grayscale threshold above which colors are considered too bright.
    correction : float, optional (default=0.15)
        Amount by which to darken too bright colors.

    Returns:
    --------
    tuple
        Adjusted RGB(A) color tuple with too bright colors darkened.

    Example:
    --------
    corrected_color = tooclear((0.9, 0.9, 0.7, 1.0))
    &#34;&#34;&#34;
    if not isinstance(color, tuple) or len(color) not in [3, 4]:
        raise ValueError(&#34;Input must be an RGB or RGBA tuple.&#34;)
    rgb = color[:3]  # Extract RGB values
    # Compute grayscale brightness (mean of RGB channels)
    brightness = sum(rgb) / 3
    # Darken if brightness exceeds the threshold
    if brightness &gt; threshold:
        rgb = tuple(max(0, c - correction) for c in rgb)
    return rgb + (color[3],) if len(color) == 4 else rgb  # Preserve alpha if present


def print_pdf(fig, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
    &#34;&#34;&#34;
    Save a given figure as a PDF.

    Parameters:
    - fig: Matplotlib figure object to be saved.
    - filename: str, PDF filename (auto-generated if empty).
    - destinationfolder: str, folder to save the file.
    - overwrite: bool, overwrite existing file.
    - dpi: int, resolution (default=300).
    &#34;&#34;&#34;
    if not is_valid_figure(fig):
        print(&#34;no valid figure&#34;)
        return
    # Generate filename if not provided
    if not filename:
        filename = _generate_figname(fig, &#34;.pdf&#34;)
    # Ensure full path
    filename = os.path.join(destinationfolder, filename)
    # Prevent overwriting unless specified
    if not overwrite and os.path.exists(filename):
        print(f&#34;File {filename} already exists. Use overwrite=True to replace it.&#34;)
        return
    # Save figure as PDF
    fig.savefig(filename, format=&#34;pdf&#34;, dpi=dpi, bbox_inches=&#34;tight&#34;)
    print(f&#34;Saved PDF: {filename}&#34;)


def print_png(fig, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
    &#34;&#34;&#34;
    Save a given figure as a PNG.

    Parameters:
    - fig: Matplotlib figure object to be saved.
    - filename: str, PNG filename (auto-generated if empty).
    - destinationfolder: str, folder to save the file.
    - overwrite: bool, overwrite existing file.
    - dpi: int, resolution (default=300).
    &#34;&#34;&#34;
    if not is_valid_figure(fig):
        print(&#34;no valid figure&#34;)
        return
    # Generate filename if not provided
    if not filename:
        filename = _generate_figname(fig, &#34;.png&#34;)
    # Ensure full path
    filename = os.path.join(destinationfolder, filename)
    # Prevent overwriting unless specified
    if not overwrite and os.path.exists(filename):
        print(f&#34;File {filename} already exists. Use overwrite=True to replace it.&#34;)
        return
    # Save figure as PNG
    fig.savefig(filename, format=&#34;png&#34;, dpi=dpi, bbox_inches=&#34;tight&#34;)
    print(f&#34;Saved PNG: {filename}&#34;)


def print_figure(fig, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
    &#34;&#34;&#34;
    Save the figure in both PDF and PNG formats.

    Parameters:
    - fig: Matplotlib figure object to be saved.
    - filename: str, base filename (auto-generated if empty).
    - destinationfolder: str, folder to save the files.
    - overwrite: bool, overwrite existing files.
    - dpi: int, resolution (default=300).
    &#34;&#34;&#34;
    if is_valid_figure(fig):
        print_pdf(fig, filename, destinationfolder, overwrite, dpi)
        print_png(fig, filename, destinationfolder, overwrite, dpi)
    else:
        print(&#34;no valid figure&#34;)


# Categorized colors with headers and spacing
COLOR_CATEGORIES = [
    (&#34;White &amp; Gray&#34;, [&#34;White&#34;, &#34;Snow&#34;, &#34;Honeydew&#34;, &#34;MintCream&#34;, &#34;Azure&#34;, &#34;AliceBlue&#34;, &#34;GhostWhite&#34;, &#34;WhiteSmoke&#34;,
                      &#34;Seashell&#34;, &#34;Beige&#34;, &#34;OldLace&#34;, &#34;FloralWhite&#34;, &#34;Ivory&#34;, &#34;AntiqueWhite&#34;, &#34;Linen&#34;,
                      &#34;LavenderBlush&#34;, &#34;MistyRose&#34;, &#34;Gray&#34;, &#34;Gainsboro&#34;, &#34;LightGray&#34;, &#34;Silver&#34;, &#34;DarkGray&#34;,
                      &#34;DimGray&#34;, &#34;LightSlateGray&#34;, &#34;SlateGray&#34;, &#34;DarkSlateGray&#34;, &#34;Black&#34;], 2),

    (&#34;Red, Pink &amp; Orange&#34;, [&#34;Red&#34;, &#34;LightSalmon&#34;, &#34;Salmon&#34;, &#34;DarkSalmon&#34;, &#34;LightCoral&#34;, &#34;IndianRed&#34;, &#34;Crimson&#34;,
                            &#34;FireBrick&#34;, &#34;DarkRed&#34;, &#34;&#34;, &#34;Pink&#34;, &#34;LightPink&#34;, &#34;HotPink&#34;, &#34;DeepPink&#34;, &#34;PaleVioletRed&#34;,
                            &#34;MediumVioletRed&#34;, &#34;&#34;, &#34;Orange&#34;, &#34;DarkOrange&#34;, &#34;Coral&#34;, &#34;Tomato&#34;, &#34;OrangeRed&#34;], 1),

    (&#34;Yellow &amp; Brown&#34;, [&#34;Yellow&#34;, &#34;LightYellow&#34;, &#34;LemonChiffon&#34;, &#34;LightGoldenrodYellow&#34;, &#34;PapayaWhip&#34;, &#34;Moccasin&#34;,
                        &#34;PeachPuff&#34;, &#34;PaleGoldenrod&#34;, &#34;Khaki&#34;, &#34;DarkKhaki&#34;, &#34;Gold&#34;, &#34;&#34;, &#34;Brown&#34;, &#34;Cornsilk&#34;,
                        &#34;BlanchedAlmond&#34;, &#34;Bisque&#34;, &#34;NavajoWhite&#34;, &#34;Wheat&#34;, &#34;BurlyWood&#34;, &#34;Tan&#34;, &#34;RosyBrown&#34;,
                        &#34;SandyBrown&#34;, &#34;Goldenrod&#34;, &#34;DarkGoldenrod&#34;, &#34;Peru&#34;, &#34;Chocolate&#34;, &#34;SaddleBrown&#34;,
                        &#34;Sienna&#34;, &#34;Maroon&#34;], 2),

    (&#34;Green&#34;, [&#34;Green&#34;, &#34;PaleGreen&#34;, &#34;LightGreen&#34;, &#34;YellowGreen&#34;, &#34;GreenYellow&#34;, &#34;Chartreuse&#34;, &#34;LawnGreen&#34;, &#34;Lime&#34;,
               &#34;LimeGreen&#34;, &#34;MediumSpringGreen&#34;, &#34;SpringGreen&#34;, &#34;MediumAquamarine&#34;, &#34;Aquamarine&#34;, &#34;LightSeaGreen&#34;,
               &#34;MediumSeaGreen&#34;, &#34;SeaGreen&#34;, &#34;DarkSeaGreen&#34;, &#34;ForestGreen&#34;, &#34;DarkGreen&#34;, &#34;OliveDrab&#34;, &#34;Olive&#34;,
               &#34;DarkOliveGreen&#34;, &#34;Teal&#34;], 0),

    (&#34;Blue&#34;, [&#34;Blue&#34;, &#34;LightBlue&#34;, &#34;PowderBlue&#34;, &#34;PaleTurquoise&#34;, &#34;Turquoise&#34;, &#34;MediumTurquoise&#34;, &#34;DarkTurquoise&#34;,
              &#34;LightCyan&#34;, &#34;Cyan&#34;, &#34;Aqua&#34;, &#34;DarkCyan&#34;, &#34;CadetBlue&#34;, &#34;LightSteelBlue&#34;, &#34;SteelBlue&#34;, &#34;LightSkyBlue&#34;,
              &#34;SkyBlue&#34;, &#34;DeepSkyBlue&#34;, &#34;DodgerBlue&#34;, &#34;CornflowerBlue&#34;, &#34;RoyalBlue&#34;, &#34;MediumBlue&#34;, &#34;DarkBlue&#34;,
              &#34;Navy&#34;, &#34;MidnightBlue&#34;], 0),

    (&#34;Purple&#34;, [&#34;Purple&#34;, &#34;Lavender&#34;, &#34;Thistle&#34;, &#34;Plum&#34;, &#34;Violet&#34;, &#34;Orchid&#34;, &#34;Fuchsia&#34;, &#34;Magenta&#34;, &#34;MediumOrchid&#34;,
                &#34;MediumPurple&#34;, &#34;Amethyst&#34;, &#34;BlueViolet&#34;, &#34;DarkViolet&#34;, &#34;DarkOrchid&#34;, &#34;DarkMagenta&#34;, &#34;SlateBlue&#34;,
                &#34;DarkSlateBlue&#34;, &#34;MediumSlateBlue&#34;, &#34;Indigo&#34;], 0)
]
# Extract colors from Matplotlib
CSS_COLORS = {k.lower(): v for k, v in mcolors.CSS4_COLORS.items()}

def rgb():
    &#34;&#34;&#34;Displays a categorized color chart with properly aligned headers.&#34;&#34;&#34;
    ncols = len(COLOR_CATEGORIES)
    max_rows = max(len(colors) + spacing for _, colors, spacing in COLOR_CATEGORIES)
    fig, ax = plt.subplots(figsize=(ncols * 2.5, max_rows * 0.6))
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_frame_on(False)
    x_spacing = 1.8  # Horizontal spacing between columns
    y_spacing = 1.0  # Vertical spacing between color patches
    text_size = 13   # Increased text size by 50%
    for col_idx, (category, colors, extra_space) in enumerate(COLOR_CATEGORIES):
        y_pos = max_rows  # Start at the top
        ax.text(col_idx * x_spacing + (x_spacing - 0.2) / 2, y_pos + 1.2, category,
                fontsize=text_size + 2, fontweight=&#39;bold&#39;, ha=&#39;center&#39;)
        y_pos -= y_spacing  # Move down after title
        for color in colors:
            if color == &#34;&#34;:  # Empty string is a spacer
                y_pos -= y_spacing * 0.5
                continue
            hexval = CSS_COLORS.get(color.lower(), &#34;white&#34;)
            y_pos -= y_spacing  # Move down before drawing
            ax.add_patch(plt.Rectangle((col_idx * x_spacing, y_pos), x_spacing - 0.2, y_spacing - 0.2, facecolor=hexval))
            r, g, b = mcolors.to_rgb(hexval)
            brightness = (r + g + b) / 3
            text_color = &#39;white&#39; if brightness &lt; 0.5 else &#39;black&#39;
            ax.text(col_idx * x_spacing + (x_spacing - 0.2) / 2, y_pos + y_spacing / 2, color, ha=&#39;center&#39;,
                    va=&#39;center&#39;, fontsize=text_size, color=text_color)
        y_pos -= extra_space * y_spacing
    ax.set_xlim(-0.5, ncols * x_spacing)
    ax.set_ylim(-0.5, max_rows * y_spacing + 2)
    plt.tight_layout()
    plt.show()


# Define PrintableFigure class
class PrintableFigure(Figure):
    &#34;&#34;&#34;Custom Figure class with print methods.&#34;&#34;&#34;

    def print(self, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
        print_figure(self, filename, destinationfolder, overwrite, dpi)

    def print_png(self, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
        print_png(self, filename, destinationfolder, overwrite, dpi)

    def print_pdf(self, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
        print_pdf(self, filename, destinationfolder, overwrite, dpi)

# ✅ Override `plt.figure()` and `plt.subplots()` to always use PrintableFigure
original_plt_figure = plt.figure
original_plt_subplots = plt.subplots

def custom_plt_figure(*args, **kwargs):
    &#34;&#34;&#34;Ensure all figures are PrintableFigure.&#34;&#34;&#34;
    kwargs.setdefault(&#34;FigureClass&#34;, PrintableFigure)
    return original_plt_figure(*args, **kwargs)

def custom_plt_subplots(*args, **kwargs):
    &#34;&#34;&#34;Ensure plt.subplots() returns a PrintableFigure.&#34;&#34;&#34;
    kwargs.setdefault(&#34;FigureClass&#34;, PrintableFigure)
    fig, ax = original_plt_subplots(*args, **kwargs)
    return fig, ax

# Apply overrides
plt.figure = custom_plt_figure
plt.subplots = custom_plt_subplots
plt.rcParams[&#39;figure.figsize&#39;] = (8, 6)  # Optional default size


# %% Generic Classes to manipulate results
class Cprofile:
    &#34;&#34;&#34;
    Class to store and interpolate a concentration profile (C(x)).
    &#34;&#34;&#34;

    def __init__(self, x=None, Cx=None):
        &#34;&#34;&#34;Initialize the concentration profile Cx(x).&#34;&#34;&#34;
        if x is None or Cx is None:
            raise ValueError(&#34;Syntax: myprofile = Cprofile(x, Cx). Both x and Cx are mandatory.&#34;)
        self.x = np.array(x, dtype=float).reshape(-1)  # Ensure 1D NumPy array
        self.Cx = np.array(Cx, dtype=float).reshape(-1)  # Ensure 1D NumPy array
        # Check if x is strictly increasing
        if np.any(np.diff(self.x) &lt;= 0):
            raise ValueError(&#34;x values must be strictly increasing.&#34;)
        # Create the interpolation function
        self._interp_func = interp1d(
            self.x, self.Cx, kind=&#34;linear&#34;, fill_value=0, bounds_error=False
        )

    def interp(self, x_new):
        &#34;&#34;&#34;
        Interpolate concentration values at new x positions.

        Parameters:
            x_new (array-like): New positions where concentrations are needed.

        Returns:
            np.ndarray: Interpolated concentration values.
        &#34;&#34;&#34;
        x_new = np.array(x_new, dtype=float)  # Ensure NumPy array
        return self._interp_func(x_new)

    def integrate(self):
        &#34;&#34;&#34;
        Compute the integral of Cx over x using Simpson&#39;s rule.

        Returns:
            float: The integral ∫ Cx dx.
        &#34;&#34;&#34;
        return simpson(self.Cx, self.x)

    def mean_concentration(self):
        &#34;&#34;&#34;
        Compute the mean concentration using the integral.

        Returns:
            float: The mean value of Cx.
        &#34;&#34;&#34;
        return self.integrate() / (self.x[-1] - self.x[0])

    def find_indices_xrange(self, x_range):
        &#34;&#34;&#34;
        Find indices where x is within a specified range.

        Parameters:
            x_range (tuple): The (min, max) range of x.

        Returns:
            np.ndarray: Indices where x falls within the range.
        &#34;&#34;&#34;
        xmin, xmax = x_range
        return np.where((self.x &gt;= xmin) &amp; (self.x &lt;= xmax))[0]

    def find_indices_Cxrange(self, Cx_range=(0, np.inf)):
        &#34;&#34;&#34;
        Find indices where Cx is within a specified range.

        Parameters:
            Cx_range (tuple): The (min, max) range of Cx.

        Returns:
            np.ndarray: Indices where Cx falls within the range.
        &#34;&#34;&#34;
        Cmin, Cmax = Cx_range
        return np.where((self.Cx &gt;= Cmin) &amp; (self.Cx &lt;= Cmax))[0]

    def assign_values(self, indices, values):
        &#34;&#34;&#34;
        Assign new values to Cx at specified indices.

        Parameters:
            indices (array-like): Indices where values should be assigned.
            values (float or array-like): New values to assign.

        Raises:
            ValueError: If the number of values does not match the number of indices.
        &#34;&#34;&#34;
        indices = np.array(indices, dtype=int)
        if np.isscalar(values):
            self.Cx[indices] = values  # Assign single value to all indices
        else:
            values = np.array(values, dtype=float)
            if values.shape[0] != indices.shape[0]:
                raise ValueError(&#34;Number of values must match the number of indices.&#34;)
            self.Cx[indices] = values

    def __repr__(self):
        &#34;&#34;&#34;Representation of the profile.&#34;&#34;&#34;
        stats_x = {
            &#34;min&#34;: np.min(self.x),
            &#34;max&#34;: np.max(self.x),
            &#34;mean&#34;: np.mean(self.x),
            &#34;median&#34;: np.median(self.x),
            &#34;std&#34;: np.std(self.x),
        }
        stats_Cx = {
            &#34;min&#34;: np.min(self.Cx),
            &#34;max&#34;: np.max(self.Cx),
            &#34;mean&#34;: np.mean(self.Cx),
            &#34;median&#34;: np.median(self.Cx),
            &#34;std&#34;: np.std(self.Cx),
        }

        print(
            f&#34;Cprofile: {len(self.x)} points\n&#34;,
            f&#34;x range: [{stats_x[&#39;min&#39;]:.4g}, {stats_x[&#39;max&#39;]:.4g}]\n&#34;,
            f&#34;Cx range: [{stats_Cx[&#39;min&#39;]:.4g}, {stats_Cx[&#39;max&#39;]:.4g}]\n&#34;,
            f&#34;x stats: mean={stats_x[&#39;mean&#39;]:.4g}, median={stats_x[&#39;median&#39;]:.4g}, std={stats_x[&#39;std&#39;]:.4g}\n&#34;,
            f&#34;Cx stats: mean={stats_Cx[&#39;mean&#39;]:.4g}, median={stats_Cx[&#39;median&#39;]:.4g}, std={stats_Cx[&#39;std&#39;]:.4g}&#34;
        )
        return str(self)

    def __str__(self):
        &#34;&#34;&#34;Returns a formatted string representation of the profile.&#34;&#34;&#34;
        return f&#34;&lt;{self.__class__.__name__}: including {len(self.x)} points&gt;&#34;



class SensPatankarResult:
    &#34;&#34;&#34;
    Container for the results of the 1D mass transfer simulation performed by ``senspatankar``.

    Attributes
    ----------
    ttarget : ndarray with shape (1,)
        target simulation time
        It is a duration not an absolute time.
    CFtarget : ndarray with shape (1,)
        CF value at ttarget
    Cxtarget : ndarray with shape (npoints,)
         Cx concentration profile at t=ttarget
    t : ndarray with shape (ntimes,)
        1D array of time points (in seconds) covering from 0 to 2*ttarget
        It is a duration not an absolute time.
    C : ndarray with shape (ntimes,)
        1D array of mean concentration in the packaging (averaged over all packaging nodes)
        at each time step. Shape: (ntimes,).
    CF : ndarray with shape (ntimes,)
        1D array of concentration in the food (left boundary) at each time step. Shape: (ntimes,).
    fc : ndarray with shape (ntimes,)
        1D array of the cumulative flux into the food. Shape: (ntimes,).
    f : ndarray with shape (ntimes,)
        1D array of the instantaneous flux into the food. Shape: (ntimes,).
    x : ndarray with shape (npoints,)
        1D array of the position coordinates of all packaging nodes (including sub-nodes).
        npoints = 3 * number of original FV elements (interfaces e and w are included).
    Cx : ndarray with shape (ntimes,npoints)
        2D array of the concentration profile across the packaging thickness for each time step.
        Shape: (ntimes, 3 * number_of_nodes). Each row corresponds to one time step.
    tC : ndarray with shape (ntimes,)
        1D array of the dimensionless time points
    C0eq : ndarray with shape (1,)
        Reference (equilibrium) concentration scaling factor.
    timebase : float
        Characteristic time scale (l_ref^2 / D_ref) used to normalize the solution.
    interp_CF : scipy.interpolate._interpolate.interp1d
        1D interpolant of CF vs time
    interp_Cx : scipy.interpolate._interpolate.interp1d
        1F interpolant of Cx vs time
    restart : restartfile_senspatankar object
        Restart object (see restartfile_senspatankar doc)


    &#34;&#34;&#34;

    def __init__(self, name, description, ttarget, t, C, CF, fc, f, x, Cx, tC, C0eq, timebase,restart,xi,Cxi,_plotconfig=None):
        &#34;&#34;&#34;constructor using positional arguments&#34;&#34;&#34;
        # xi and Cxi are close to x and Cx but they can be interpolated
        # their values are not saved but used to built Cprofile
        self.name = name
        self.description = description
        self.ttarget = ttarget
        self.t = t
        self.C = C
        self.CF = CF
        self.fc = fc
        self.f = f
        self.x = x
        self.Cx = Cx
        self.tC = tC
        self.C0eq = C0eq
        self.timebase = timebase
        # Interpolated CF at ttarget
        self.interp_CF = interp1d(t, CF, kind=&#34;linear&#34;, fill_value=&#34;extrapolate&#34;)
        self.CFtarget = self.interp_CF(ttarget)
        # Interpolated concentration profile at ttarget
        self.interp_Cx = interp1d(t, Cx.T, kind=&#34;linear&#34;, axis=1, fill_value=&#34;extrapolate&#34;)
        self.Cxtarget = self.interp_Cx(ttarget)
        # Restart information including restults at ttarget
        # xi and Cxi are available only from a fresh simulation
        # these data are missing from operation +, in this case we use restart as supplied
        if xi is not None and Cxi is not None:
            Cxi_interp = interp1d(t, Cxi.T, kind=&#34;linear&#34;, axis=1, fill_value=&#34;extrapolate&#34;)
            Cxi_at_t = Cxi_interp(ttarget) # this profile has inceasing xi using xreltol
            restart.freezeCF(ttarget,self.CFtarget)
            restart.freezeCx(xi,Cxi_at_t)
        self.restart = restart
        if _plotconfig is None:
            self._plotconfig = plotconfig # fresh simulation
        else:
            self._plotconfig = _plotconfig # if from an existing SensPatankarResult
        # for simulation chaining
        self.savestate(self.restart.inputs[&#34;multilayer&#34;],self.restart.inputs[&#34;medium&#34;])

    def savestate(self,multilayer,medium):
        &#34;&#34;&#34;Saves senspantankar inputs for simulation chaining&#34;&#34;&#34;
        self._lastmedium = medium
        self._lastmultilayer = multilayer
        self._isstatesaved = True

    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update modifiable parameters of the SensPatankarResult object.
        Parameters:
            - name (str): New name for the object.
            - description (str): New description.
            - tscale (float or tuple): Time scale (can be tuple like (1, &#34;day&#34;)).
            - tunit (str): Time unit.
            - lscale (float or tuple): Length scale (can be tuple like (1e-6, &#34;µm&#34;)).
            - lunit (str): Length unit.
            - Cscale (float or tuple): Concentration scale (can be tuple like (1, &#34;a.u.&#34;)).
            - Cunit (str): Concentration unit.
        &#34;&#34;&#34;
        def checkunits(value):
            &#34;&#34;&#34;Helper function to handle unit conversion for scale/unit tuples.&#34;&#34;&#34;
            if isinstance(value, tuple) and len(value) == 2:
                scale, unit = check_units(value)
                scale, unit = np.array(scale, dtype=float), str(unit)  # Ensure correct types
                return scale.item(), unit  # Convert numpy array to float
            elif isinstance(value, (int, float, np.ndarray)):
                value = np.array(value, dtype=float)  # Ensure float
                return value.item(), None  # Return as float with no unit change
            else:
                raise ValueError(f&#34;Invalid value for scale/unit: {value}&#34;)

        # Update `name` and `description` if provided
        if &#34;name&#34; in kwargs:
            self.name = str(kwargs[&#34;name&#34;])
        if &#34;description&#34; in kwargs:
            self.description = str(kwargs[&#34;description&#34;])
        # Update `_plotconfig` parameters
        for key in [&#34;tscale&#34;, &#34;tunit&#34;, &#34;lscale&#34;, &#34;lunit&#34;, &#34;Cscale&#34;, &#34;Cunit&#34;]:
            if key in kwargs:
                value = kwargs[key]

                if key in [&#34;tscale&#34;, &#34;lscale&#34;, &#34;Cscale&#34;]:
                    value, unit = checkunits(value)  # Process unit conversion
                    self._plotconfig[key] = value
                    if unit is not None:
                        self._plotconfig[key.replace(&#34;scale&#34;, &#34;unit&#34;)] = unit  # Ensure unit consistency
                else:
                    self._plotconfig[key] = str(value)  # Convert unit strings directly
        return self  # Return self for method chaining if needed



    def resume(self,t=None,**kwargs):
        &#34;&#34;&#34;
        Resume simulation for a new duration (with all parameters are unchanged)

        For convenience user overrides are provided as:
            parameter = value
            with parameter = &#34;name&#34;,&#34;description&#34;...&#34;RelTol&#34;,&#34;AbsTol&#34; (see senspantankar)
        Use specifically:
            CF0 to assign a different concentration for the food
            Cx0 (Cprofile object) to assign a different concentration profile (not recommended)
            medium to set a different medium (food) in contact
        &#34;&#34;&#34;

        # retrieve previous results
        previousCF = self.restart.CF # CF at at target
        previousCx = self.restart.Cprofile # corresponding profile
        previousmedium = self.restart.inputs[&#34;medium&#34;].copy()
        previousmedium.CF0 = previousCF # we apply the concentration
        # CF override with CF=new value
        isCF0forced = &#34;CF0&#34; in kwargs
        newmedium = kwargs.get(&#34;medium&#34;,previousmedium)
        if isCF0forced:
            newCF0 = kwargs.get(&#34;CF0&#34;,previousCF)
            newmedium.CF0 = newCF0
        if t is None:
            ttarget = newmedium.get_param(&#34;contacttime&#34;,(10,&#34;days&#34;),acceptNone=False)
            t = 2*ttarget
        # Concentration profile override with Cx0=new profile
        newCx0 = kwargs.get(&#34;Cx0&#34;,previousCx)
        if not isinstance(newCx0,Cprofile):
            raise TypeError(f&#34;Cx0 should be a Cprofile object not a {type(newCx0).__name__}&#34;)

        # extend the existing solution
        inputs = self.restart.inputs # all previous inputs
        newsol = senspatankar(multilayer=inputs[&#34;multilayer&#34;],
                              medium=newmedium,
                              name=kwargs.get(&#34;name&#34;,inputs[&#34;name&#34;]),
                              description=kwargs.get(&#34;description&#34;,inputs[&#34;description&#34;]),
                              t=t,
                              autotime=kwargs.get(&#34;autotime&#34;,inputs[&#34;autotime&#34;]),
                              timescale=kwargs.get(&#34;timescale&#34;,inputs[&#34;timescale&#34;]),
                              Cxprevious=newCx0,
                              ntimes=kwargs.get(&#34;ntimes&#34;,inputs[&#34;ntimes&#34;]),
                              RelTol=kwargs.get(&#34;RelTol&#34;,inputs[&#34;RelTol&#34;]),
                              AbsTol=kwargs.get(&#34;AbsTol&#34;,inputs[&#34;AbsTol&#34;]))
        return newsol

    def chaining(self,multilayer,medium,**kwargs):
        sim = self.resume(multilayer=multilayer,medium=medium,**kwargs)
        medium.lastsimulation = sim # store the last simulation result in medium
        medium.lastinput = multilayer # store the last input (in medium)
        sim.savestate(multilayer,medium) # store store the inputs in sim for chaining
        return sim

    # overloading operation
    def __rshift__(self, medium):
        &#34;&#34;&#34;Overloads &gt;&gt; to propagate migration to food.&#34;&#34;&#34;
        if not isinstance(medium,foodphysics):
            raise TypeError(f&#34;medium must be a foodphysics object not a {type(medium).__name__}&#34;)
        if not self._isstatesaved:
            raise RuntimeError(&#34;The previous inputs were not saved within the instance.&#34;)
        # we update the contact temperature (see example3)
        return self.chaining(medium&gt;&gt;self._lastmultilayer,medium,CF0=self.restart.CF)

    def __add__(self, other):
        &#34;&#34;&#34;Concatenate two solutions&#34;&#34;&#34;
        if not isinstance(other, SensPatankarResult):
            raise TypeError(&#34;Can only add two SensPatankarResult objects&#34;)

        # Ensure compatibility of x-axis
        if not np.isclose(self.x[0], other.x[0]) or not np.isclose(self.x[-1], other.x[-1]):
            raise ValueError(&#34;Mismatch in x-axis boundaries between solutions&#34;)

        # Interpolate other.Cx onto self.x
        interp_Cx_other = interp1d(other.x, other.Cx.T, kind=&#34;linear&#34;, fill_value=0, axis=0)
        Cx_other_interp = interp_Cx_other(self.x).T  # Ensuring shape (ntimes, npoints)

        # Restrict times for valid merging
        valid_indices_self = self.t &lt;= self.ttarget
        valid_indices_other = (other.t &gt; 0) #&amp; (other.t &lt;= other.ttarget)
        t_self = self.t[valid_indices_self]
        t_other = other.t[valid_indices_other] + self.ttarget  # Shift time

        # Merge time arrays without duplicates
        t_merged = np.unique(np.concatenate((t_self, t_other)))
        tC_merged = np.unique(np.concatenate((self.tC[valid_indices_self], other.tC[valid_indices_other])))

        # Merge concentration-related attributes
        C_merged = np.concatenate((self.C[valid_indices_self], other.C[valid_indices_other]))
        CF_merged = np.concatenate((self.CF[valid_indices_self], other.CF[valid_indices_other]))
        fc_merged = np.concatenate((self.fc[valid_indices_self], other.fc[valid_indices_other]))
        f_merged = np.concatenate((self.f[valid_indices_self], other.f[valid_indices_other]))

        # Merge concentration profiles
        Cx_merged = np.vstack((self.Cx[valid_indices_self], Cx_other_interp[valid_indices_other]))

        # Merged description
        if self.description and other.description:
            merged_description = f&#34;Merged: {self.description} &amp; {other.description}&#34;
        elif self.description:
            merged_description = self.description
        elif other.description:
            merged_description = other.description
        else:
            merged_description = &#34;&#34;

        # Create new instance with merged data
        merged_result = SensPatankarResult(
            name=f&#34;{self.name} + {other.name}&#34; if self.name!=other.name else self.name,
            description=merged_description,
            ttarget=self.ttarget + other.ttarget,
            t=t_merged,
            C=C_merged,
            CF=CF_merged,
            fc=fc_merged,
            f=f_merged,
            x=self.x,  # Keep self.x as reference
            Cx=Cx_merged,
            tC=tC_merged,
            C0eq=self.C0eq,  # Keep self.C0eq
            timebase=other.timebase,  # Take timebase from other
            restart=other.restart,  # Take restart from other (the last valid one)
            xi=None,  # xi and Cxi values are available
            Cxi=None  # only from a fresh simulation
        )

        return merged_result

    def interpolate_CF(self, t, kind=&#34;linear&#34;, fill_value=&#34;extrapolate&#34;):
        &#34;&#34;&#34;
        Interpolates the concentration in the food (CF) at given time(s).

        Parameters
        ----------
        t : float, list, tuple, or ndarray
            Time(s) at which to interpolate CF values.
            - If a tuple, it should be (value or list, unit) and will be converted to SI.
            - If a scalar or list, it is assumed to be in SI units already.
        kind : str, optional
            Interpolation method. Default is &#34;linear&#34;.
            Possible values:
            - &#34;linear&#34;: Piecewise linear interpolation (default).
            - &#34;nearest&#34;: Nearest-neighbor interpolation.
            - &#34;zero&#34;: Zero-order spline interpolation.
            - &#34;slinear&#34;, &#34;quadratic&#34;, &#34;cubic&#34;: Spline interpolations of various orders.
        fill_value : str or float, optional
            Specifies how to handle values outside the given range.
            - &#34;extrapolate&#34; (default): Extrapolates values beyond available data.
            - Any float: Uses a constant value for out-of-bounds interpolation.

        Returns
        -------
        ndarray
            Interpolated CF values at the requested time(s).
        &#34;&#34;&#34;
        # Convert time input to SI units if provided as a tuple
        if isinstance(t, tuple):
            t, _ = check_units(t)  # Convert to numeric array

        # Ensure t is a NumPy array for vectorized operations
        t = np.atleast_1d(t)

        # Create the interpolant on demand with user-defined settings
        interp_function = interp1d(self.t, self.CF, kind=kind, fill_value=fill_value, bounds_error=False)

        # Return interpolated values
        return interp_function(t)


    def __repr__(self):
        ntimes = len(self.t)
        nx = self.Cx.shape[1] if self.Cx.ndim &gt; 1 else len(self.x)
        tmin, tmax = self.t.min(), self.t.max()
        xmin, xmax = self.x.min(), self.x.max()

        print(f&#34;SensPatankarResult: {self.name}\n&#34;
              f&#34;\t {self.description if self.description != &#39;&#39; else &#39;&lt;no description&gt;&#39;}\n&#34;
              f&#34;\t - with {ntimes} time steps\n&#34;,
              f&#34;\t - with {nx} spatial points\n&#34;
              f&#34;\t - Time range: [{tmin:.2e}, {tmax:.2e}] s\n&#34;
              f&#34;\t - Position range: [{xmin:.2e}, {xmax:.2e}] m&#34;)

        return str(self)


    def __str__(self):
        return (f&#39;&lt;{self.__class__.__name__}:{self.name}: &#39;
            f&#39;CF({(self.ttarget / plotconfig[&#34;tscale&#34;]).item():.4g} [{plotconfig[&#34;tunit&#34;]}]) = &#39;
            f&#39;{(self.CFtarget / plotconfig[&#34;Cscale&#34;]).item():.4g} [{plotconfig[&#34;Cunit&#34;]}]&gt;&#39;)



    def plotCF(self, t=None, trange=None):
        &#34;&#34;&#34;
        Plot the concentration in the food (CF) as a function of time and highlight the target time(s).

        Parameters
        ----------
        t : float, list, or None, optional
            Specific time(s) for which the concentration should be highlighted.
            If None, defaults to `ttarget`.
        trange : None, float, or list [t_min, t_max], optional
            If None, the full profile is shown.
            If a float, it is treated as an upper bound (lower bound assumed 0).
            If a list `[t_min, t_max]`, the profile is interpolated between these values.
        &#34;&#34;&#34;

        # extract plotconfig
        plotconfig = self._plotconfig

        # Ensure t is a list (even if a single value is given)
        if t is None:
            t_values = [self.ttarget]
        elif isinstance(t, (int, float)):
            t_values = [t]
        elif isinstance(t,np.ndarray):
            t_values = t.flatten()
        elif isinstance(t,tuple):
            t_values = check_units(t)[0]
        else:
            t_values = np.array(t)  # Convert to array

        # Interpolate CF values at given times
        CF_t_values = self.interp_CF(t_values)

        # Handle trange interpolation
        if trange is None:
            t_plot = self.t
            CF_plot = self.CF
        else:
            # Convert trange to a valid range
            if isinstance(trange, (int, float)):
                trange = [0, trange]  # Assume lower bound is 0
            elif len(trange) != 2:
                raise ValueError(&#34;trange must be None, a single float (upper bound), or a list of two values [t_min, t_max]&#34;)

            # Validate range
            t_min, t_max = trange
            if t_min &lt; self.t.min() or t_max &gt; self.t.max():
                print(&#34;Warning: trange values are outside the available time range and may cause extrapolation.&#34;)

            # Generate interpolated time values
            t_plot = np.linspace(t_min, t_max, 500)
            CF_plot = self.interp_CF(t_plot)  # Interpolated CF values

        # Set up colormap for multiple t values
        cmap = plt.get_cmap(&#39;viridis&#39;, len(t_values))
        norm = mcolors.Normalize(vmin=min(t_values), vmax=max(t_values))

        # Create the figure
        fig, ax = plt.subplots(figsize=(8, 6))

        # Plot CF curve (either original or interpolated)
        ax.plot(t_plot / plotconfig[&#34;tscale&#34;], CF_plot / plotconfig[&#34;Cscale&#34;],
                label=&#39;Concentration in Food&#39;, color=&#39;b&#39;)

        # Highlight each target time
        for i, tC in enumerate(t_values):
            color = tooclear(cmap(norm(tC))) if len(t_values) &gt; 1 else &#39;r&#39;  # Use color map only if multiple t values

            # Vertical and horizontal lines
            ax.axvline(tC / plotconfig[&#34;tscale&#34;], color=color, linestyle=&#39;--&#39;, linewidth=1)
            ax.axhline(CF_t_values[i] / plotconfig[&#34;Cscale&#34;], color=color, linestyle=&#39;--&#39;, linewidth=1)

            # Intersection point
            ax.scatter(tC / plotconfig[&#34;tscale&#34;], CF_t_values[i] / plotconfig[&#34;Cscale&#34;],
                       color=color, zorder=3)

            # Annotate time
            ax.text(tC / plotconfig[&#34;tscale&#34;], min(CF_plot) / plotconfig[&#34;Cscale&#34;],
                    f&#39;{(tC / plotconfig[&#34;tscale&#34;]).item():.2f} {plotconfig[&#34;tunit&#34;]}&#39;,
                    verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;right&#39;, rotation=90, fontsize=10, color=color)

            # Annotate concentration
            ax.text(min(t_plot) / plotconfig[&#34;tscale&#34;], CF_t_values[i] / plotconfig[&#34;Cscale&#34;],
                    f&#39;{(CF_t_values[i] / plotconfig[&#34;Cscale&#34;]).item():.2f} {plotconfig[&#34;Cunit&#34;]}&#39;,
                    verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;left&#39;, fontsize=10, color=color)

        # Labels and title
        ax.set_xlabel(f&#39;Time [{plotconfig[&#34;tunit&#34;]}]&#39;)
        ax.set_ylabel(f&#39;Concentration in Food [{plotconfig[&#34;Cunit&#34;]}]&#39;)
        title_main = &#34;Concentration in Food vs. Time&#34;
        title_sub = rf&#34;$\bf{{{self.name}}}$&#34; + (f&#34;: {self.description}&#34; if self.description else &#34;&#34;)
        ax.set_title(f&#34;{title_main}\n{title_sub}&#34;, fontsize=10)
        ax.text(0.5, 1.05, title_sub, fontsize=8, ha=&#34;center&#34;, va=&#34;bottom&#34;, transform=ax.transAxes)
        ax.set_title(title_main)
        ax.legend()
        ax.grid(True)
        plt.show()
        # store metadata
        setattr(fig,_fig_metadata_atrr_,f&#34;pltCF_{self.name}&#34;)
        return fig



    def plotCx(self, t=None, nmax=15):
        &#34;&#34;&#34;
        Plot the concentration profiles (Cx) in the packaging vs. position (x) for different times,
        using a color gradient similar to Parula, based on time values (not index order).
        Additionally, highlight the concentration profile at `ttarget` with a thick black line.

        Parameters
        ----------
        t : list, array-like, or None, optional
            List of specific times to plot. Only valid values (inside self.t) are used.
            If None, time values are selected using sqrt-spaced distribution.
        nmax : int, optional
            Maximum number of profiles to plot. The default is 15.
        &#34;&#34;&#34;

        # extract plotconfig
        plotconfig = self._plotconfig


        # Ensure time values are within the available time range
        if t is None:
            # Default: Select `nmax` time values using sqrt-spacing
            nt = len(self.t)
            if nt &lt;= nmax:
                t_values = self.t
            else:
                sqrt_t = np.sqrt(self.t)
                sqrt_t_values = np.linspace(sqrt_t[0], sqrt_t[-1], nmax)
                t_values = sqrt_t_values**2
        else:
            # Use user-specified time values
            if isinstance(t,tuple):
                t_values = check_units(t)[0]
            else:
                t_values = np.array(t)
            # Keep only valid times inside `self.t`
            t_values = t_values[(t_values &gt;= self.t.min()) &amp; (t_values &lt;= self.t.max())]
            if len(t_values) == 0:
                print(&#34;Warning: No valid time values found in the specified range.&#34;)
                return
            # If more than `nmax`, keep the first `nmax` values
            t_values = t_values[:nmax]

        # Normalize time for colormap (Ensure at least one valid value)
        norm = mcolors.Normalize(vmin=t_values.min(), vmax=t_values.max()) if len(t_values) &gt; 1 else mcolors.Normalize(vmin=self.t.min(), vmax=self.t.max())
        cmap = plt.get_cmap(&#39;viridis&#39;, nmax)  # &#39;viridis&#39; is similar to Parula

        fig, ax = plt.subplots(figsize=(8, 6))  # Explicitly create a figure and axis

        # Plot all valid concentration profiles with time-based colormap
        for tC in t_values:
            C = self.interp_Cx(tC)
            color = tooclear(cmap(norm(tC)))  # Get color from colormap
            ax.plot(self.x / plotconfig[&#34;lscale&#34;], C / plotconfig[&#34;Cscale&#34;],
                    color=color, alpha=0.9, label=f&#39;t={tC / plotconfig[&#34;tscale&#34;]:.3g} {plotconfig[&#34;tunit&#34;]}&#39;)

        # Highlight concentration profile at `ttarget`
        ax.plot(self.x / plotconfig[&#34;lscale&#34;], self.Cxtarget / plotconfig[&#34;Cscale&#34;], &#39;k-&#39;, linewidth=3,
                label=f&#39;t={self.ttarget[0] / plotconfig[&#34;tscale&#34;]:.2g} {plotconfig[&#34;tunit&#34;]} (target)&#39;)

        # Create ScalarMappable and add colorbar
        sm = cm.ScalarMappable(cmap=cmap, norm=norm)
        sm.set_array([])  # Needed for colorbar
        cbar = fig.colorbar(sm, ax=ax)  # Explicitly associate colorbar with axis
        cbar.set_label(f&#39;Time [{plotconfig[&#34;tunit&#34;]}]&#39;)

        ax.set_xlabel(f&#39;Position [{plotconfig[&#34;lunit&#34;]}]&#39;)
        ax.set_ylabel(f&#39;Concentration in Packaging [{plotconfig[&#34;Cunit&#34;]}]&#39;)
        title_main = &#34;Concentration Profiles in Packaging vs. Position&#34;
        title_sub = rf&#34;$\bf{{{self.name}}}$&#34; + (f&#34;: {self.description}&#34; if self.description else &#34;&#34;)
        ax.set_title(f&#34;{title_main}\n{title_sub}&#34;, fontsize=10)
        ax.text(0.5, 1.05, title_sub, fontsize=8, ha=&#34;center&#34;, va=&#34;bottom&#34;, transform=ax.transAxes)
        ax.set_title(title_main)
        ax.grid(True)
        ax.legend()
        plt.show()
        # store metadata
        setattr(fig,_fig_metadata_atrr_,f&#34;pltCx_{self.name}&#34;)
        return fig


# Container for multiple simulations
class CFSimulationContainer:
    &#34;&#34;&#34;
    Container to store and compare multiple CF results from different simulations.

    Attributes
    ----------
    curves : dict
        Stores CF results with unique keys. Each entry contains:
        - &#39;label&#39;: Label used for legend.
        - &#39;tmin&#39;, &#39;tmax&#39;: Time range of the simulation.
        - &#39;interpolant&#39;: Interpolated CF function.
        - &#39;color&#39;: Assigned color for plotting.
        - &#39;linestyle&#39;: Line style (default is &#39;-&#39;).
        - &#39;linewidth&#39;: Line width (default is 2).
    &#34;&#34;&#34;

    def __init__(self,name=&#34;&#34;,description=&#34;&#34;):
        &#34;&#34;&#34;Initialize an empty container for CF results.&#34;&#34;&#34;
        self.curves = {}
        self._name = name
        self._description = description
        self._plotconfig = plotconfig

    @property
    def name(self):
        return self._name or autoname(6)

    @property
    def description(self):
        return self._description or f&#34;comparison of {len(self.curves)} curves&#34;


    def add(self, simulation_result, label=None, color=None, linestyle=&#34;-&#34;, linewidth=2):
        &#34;&#34;&#34;
        Add a new CF result to the container.

        Parameters
        ----------
        simulation_result : SensPatankarResult
            The simulation result to store.
        label : str, optional
            Label for the curve (used in legend). Defaults to &#39;plot1&#39;, &#39;plot2&#39;, etc.
        color : str or tuple, optional
            Color for the curve. Defaults to automatic colormap.
        linestyle : str, optional
            Line style for the plot (e.g., &#39;-&#39;, &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;). Default is &#39;-&#39;.
        linewidth : float, optional
            Line width for the plot. Default is 2.
        &#34;&#34;&#34;

        # Check input
        if not isinstance(simulation_result,SensPatankarResult):
            raise TypeError(f&#34;simulation_result should be a SensPatankarResult object not a {type(simulation_result).__name__}&#34;)

        # Auto-generate a label if not provided
        label = label or self.name
        label = label or f&#34;plot{len(self.curves) + 1}&#34;

        # Generate a unique key (first 40 letters of label)
        key = label[:40] # 40 max

        # Create the interpolant function
        interpolant = interp1d(simulation_result.t, simulation_result.CF,
                               kind=&#34;linear&#34;, fill_value=&#34;extrapolate&#34;, bounds_error=False)

        # Assign color from a colormap if not provided
        if color is None:
            cmap = cm.get_cmap(&#34;tab10&#34;, len(self.curves) + 1)
            color = cmap(len(self.curves) % 10)  # Cycle through colors

        # Store the result in the dictionary (replacing existing key if necessary)
        self.curves[key] = {
            &#34;label&#34;: label,
             &#34;name&#34;: simulation_result.name,
      &#34;description&#34;: simulation_result.description,
             &#34;tmin&#34;: simulation_result.t.min(),
             &#34;tmax&#34;: simulation_result.t.max(),
      &#34;interpolant&#34;: interpolant,
            &#34;color&#34;: color,
        &#34;linestyle&#34;: linestyle,
        &#34;linewidth&#34;: linewidth
        }

    def delete(self, label):
        &#34;&#34;&#34;
        Remove a stored curve by its label.

        Parameters
        ----------
        label : str
            Label of the curve to delete.
        &#34;&#34;&#34;
        key = label[:10]
        if key in self.curves:
            del self.curves[key]
            print(f&#34;Deleted curve &#39;{label}&#39;&#34;)
        else:
            print(f&#34;No curve found with label &#39;{label}&#39;&#34;)

    def __repr__(self):
        &#34;&#34;&#34;Return a summary of stored CF curves.&#34;&#34;&#34;
        if not self.curves:
            return &#34;&lt;CFSimulationContainer: No stored curves&gt;&#34;

        repr_str = &#34;&lt;CFSimulationContainer: Stored CF Curves&gt;\n&#34;
        repr_str += &#34;--------------------------------------------------\n&#34;
        for key, data in self.curves.items():
            repr_str += (f&#34;[{data[&#39;label&#39;]}] &#34;
                         f&#34;Name: {data[&#39;name&#39;]} | &#34;
                         f&#34;Descr: {data[&#39;description&#39;]} | &#34;
                         f&#34;Time: [{data[&#39;tmin&#39;]:.2e}, {data[&#39;tmax&#39;]:.2e}] s | &#34;
                         f&#34;Color: {data[&#39;color&#39;]} | &#34;
                         f&#34;Style: {data[&#39;linestyle&#39;]} | &#34;
                         f&#34;Width: {data[&#39;linewidth&#39;]}\n&#34;)
        return repr_str


    def plotCF(self, t_range=None):
        &#34;&#34;&#34;
        Plot all stored CF curves in a single figure.

        Parameters
        ----------
        t_range : tuple (t_min, t_max), optional
            Time range for plotting. If None, uses each curve&#39;s own range.
        plotconfig : dict, optional
            Dictionary with plotting configuration, containing:
            - &#34;tunit&#34;: Time unit label (e.g., &#39;s&#39;).
            - &#34;Cunit&#34;: Concentration unit label (e.g., &#39;mg/L&#39;).
            - &#34;tscale&#34;: Time scaling factor.
            - &#34;Cscale&#34;: Concentration scaling factor.
        &#34;&#34;&#34;

        # extract plotconfig
        plotconfig = self._plotconfig

        if not self.curves:
            print(&#34;No curves to plot.&#34;)
            return

        fig, ax = plt.subplots(figsize=(8, 6))

        for data in self.curves.values():
            # Determine the time range
            t_min, t_max = data[&#34;tmin&#34;], data[&#34;tmax&#34;]
            if t_range:
                t_min, t_max = max(t_min, t_range[0]), min(t_max, t_range[1])

            # Generate interpolated values
            t_plot = np.linspace(t_min, t_max, 500)
            CF_plot = data[&#34;interpolant&#34;](t_plot)

            # Apply unit scaling if plotconfig is provided
            if plotconfig:
                t_plot /= plotconfig.get(&#34;tscale&#34;, 1)
                CF_plot /= plotconfig.get(&#34;Cscale&#34;, 1)

            # Plot the curve
            ax.plot(t_plot, CF_plot, label=data[&#34;label&#34;],
                    color=data[&#34;color&#34;], linestyle=data[&#34;linestyle&#34;], linewidth=data[&#34;linewidth&#34;])

        # Configure the plot
        ax.set_xlabel(f&#39;Time [{plotconfig[&#34;tunit&#34;]}]&#39; if plotconfig else &#34;Time&#34;)
        ax.set_ylabel(f&#39;Concentration in Food [{plotconfig[&#34;Cunit&#34;]}]&#39; if plotconfig else &#34;CF&#34;)
        title_main = &#34;Concentration in Food vs. Time&#34;
        title_sub = rf&#34;$\bf{{{self.name}}}$&#34; + (f&#34;: {self.description}&#34; if self.description else &#34;&#34;)
        ax.set_title(f&#34;{title_main}\n{title_sub}&#34;, fontsize=10)
        ax.text(0.5, 1.05, title_sub, fontsize=8, ha=&#34;center&#34;, va=&#34;bottom&#34;, transform=ax.transAxes)
        ax.set_title(title_main)
        ax.legend()
        ax.grid(True)
        plt.show()
        # store metadata
        setattr(fig,_fig_metadata_atrr_,f&#34;cmp_pltCF_{self.name}&#34;)
        return fig


    def to_dataframe(self, t_range=None, num_points=1000, time_list=None):
        &#34;&#34;&#34;
        Export interpolated CF data as a pandas DataFrame.
        Parameters:
        - t_range: tuple (t_min, t_max), optional
            The time range for interpolation (default: min &amp; max of all stored results).
        - num_points: int, optional
            Number of points in the interpolated time grid (default: 100).
        - time_list: list or array, optional
            Explicit list of time points for interpolation (overrides t_range &amp; num_points).
        Returns:
        - pd.DataFrame
            A DataFrame with time as index and CF values as columns (one per simulation).
        &#34;&#34;&#34;
        if not self.curves:
            print(&#34;No data to export.&#34;)
            return pd.DataFrame()

        # Determine the time grid
        if time_list is not None:
            t_grid = np.array(time_list)
        else:
            all_t_min = min(data[&#34;tmin&#34;] for data in self.curves.values())
            all_t_max = max(data[&#34;tmax&#34;] for data in self.curves.values())
            # Default time range
            t_min, t_max = t_range if t_range else (all_t_min, all_t_max)
            # Create evenly spaced time grid
            t_grid = np.linspace(t_min, t_max, num_points)
        # Create DataFrame with time as index
        df = pd.DataFrame({&#34;Time (s)&#34;: t_grid})

        # Interpolate each stored CF curve at the common time grid
        for key, data in self.curves.items():
            df[data[&#34;label&#34;]] = data[&#34;interpolant&#34;](t_grid)
        return df


    def save_as_excel(self, filename=&#34;CF_data.xlsx&#34;, destinationfolder=os.getcwd(), overwrite=False,
                      t_range=None, num_points=1000, time_list=None):
        &#34;&#34;&#34;
        Save stored CF data to an Excel file.
        Parameters:
        - filename: str, Excel filename.
        - destinationfolder: str, where to save the file.
        - overwrite: bool, overwrite existing file.
        - t_range: tuple (t_min, t_max), optional
            The time range for interpolation (default: min &amp; max of all stored results).
        - num_points: int, optional
            Number of points in the interpolated time grid (default: 100).
        - time_list: list or array, optional
            Explicit list of time points for interpolation (overrides t_range &amp; num_points).
        &#34;&#34;&#34;
        if not self.curves:
            print(&#34;No data to export.&#34;)
            return
        df = self.to_dataframe(t_range=t_range, num_points=num_points, time_list=time_list)
        filepath = os.path.join(destinationfolder, filename)
        if not overwrite and os.path.exists(filepath):
            print(f&#34;File {filepath} already exists. Use overwrite=True to replace it.&#34;)
            return

        df.to_excel(filepath, index=False)
        print(f&#34;Saved Excel file: {filepath}&#34;)


    def save_as_csv(self, filename=&#34;CF_data.csv&#34;, destinationfolder=os.getcwd(), overwrite=False,
                    t_range=None, num_points=200, time_list=None):
        &#34;&#34;&#34;
        Save stored CF data to an Excel file.
        Parameters:
        - filename: str, Excel filename.
        - destinationfolder: str, where to save the file.
        - overwrite: bool, overwrite existing file.
        - t_range: tuple (t_min, t_max), optional
            The time range for interpolation (default: min &amp; max of all stored results).
        - num_points: int, optional
            Number of points in the interpolated time grid (default: 100).
        - time_list: list or array, optional
            Explicit list of time points for interpolation (overrides t_range &amp; num_points).
        &#34;&#34;&#34;
        if not self.curves:
            print(&#34;No data to export.&#34;)
            return
        df = self.to_dataframe(t_range=t_range, num_points=num_points, time_list=time_list)
        filepath = os.path.join(destinationfolder, filename)
        if not overwrite and os.path.exists(filepath):
            print(f&#34;File {filepath} already exists. Use overwrite=True to replace it.&#34;)
            return
        df.to_csv(filepath, index=False)
        print(f&#34;Saved CSV file: {filepath}&#34;)


    def rgb(self):
        &#34;&#34;&#34;Displays a categorized color chart with properly aligned headers.&#34;&#34;&#34;
        rgb()


# restartfile
class restartfile:
    &#34;&#34;&#34;
    Containter for the restartfile
    &#34;&#34;&#34;
    @classmethod
    def copy(cls, what):
        &#34;&#34;&#34;Safely copy a parameter that can be a float, str, dict, or a NumPy array&#34;&#34;&#34;
        if isinstance(what, (int, float, str, tuple,bool)):  # Immutable types (direct copy)
            return what
        elif isinstance(what, np.ndarray):  # NumPy array (ensure a separate copy)
            return np.copy(what)
        elif isinstance(what, dict):  # Dictionary (deep copy)
            return duplicate(what)
        elif what is None:
            return None
        else:  # Fallback for other complex types
            return duplicate(what)

# specific restartfile for senspatankar
class restartfile_senspantakar(restartfile):
    &#34;&#34;&#34;
    Containter for the restartfile
    &#34;&#34;&#34;
    def __init__(self,multilayer,medium,name,description,
                 t,autotime,timescale,Cxprevious,
                 ntimes,RelTol,AbsTol):
        &#34;&#34;&#34;constructor to be called at the intialization&#34;&#34;&#34;
        inputs = {
            &#34;multilayer&#34;:multilayer.copy(),
            &#34;medium&#34;:medium.copy(),
            &#34;name&#34;:restartfile.copy(name),
            &#34;description&#34;:restartfile.copy(description),
            &#34;t&#34;:restartfile.copy(t), # t is a duration not absolute time (it should not be reused)
            &#34;autotime&#34;:restartfile.copy(autotime),
            &#34;timescale&#34;:restartfile.copy(timescale),
            &#34;Cxprevious&#34;:Cxprevious,
            &#34;ntimes&#34;:restartfile.copy(ntimes),
            &#34;RelTol&#34;:restartfile.copy(RelTol),
            &#34;AbsTol&#34;:restartfile.copy(AbsTol)
            }
        # inputs
        self.inputs = inputs
        # outputs
        self.t = None # no result yet
        self.CF = None # no result yet
        self.Cprofile = None # no result yet

    def freezeCF(self,t,CF):
        &#34;&#34;&#34;Freeze the CF solution CF(t)&#34;&#34;&#34;
        self.t = t
        self.CF = CF

    def freezeCx(self,x,Cx):
        &#34;&#34;&#34;Freeze the Cx solution Cx(x)&#34;&#34;&#34;
        self.Cprofile = Cprofile(x,Cx)

    def __repr__(self):
        &#34;&#34;&#34;representation of the restart object&#34;&#34;&#34;
        if self.t is None:
            print(&#34;Restart file with no result&#34;)
        else:
            print(f&#34;Restart file at t={self.t} with CF={self.CF}&#34;)
            print(&#34;Details of the profile:&#34;)
            repr(self.Cprofile)
        return str(self)

    def __str__(self):
        &#34;&#34;&#34;Formatted representation of the restart object&#34;&#34;&#34;
        res = &#34;no result&#34; if self.t is None else f&#34;solution at t={self.t}&#34;
        return f&#34;&lt;{self.__class__.__name__}: {res}&#34;


# %% Core function
def senspatankar(multilayer=None, medium=None,
                 name=f&#34;senspatantkar:{autoname(6)}&#34;, description=&#34;&#34;,
                 t=None, autotime=True, timescale=&#34;sqrt&#34;, Cxprevious=None,
                 ntimes=1e3, RelTol=1e-6, AbsTol=1e-6):
    &#34;&#34;&#34;
    Simulates in 1D the mass transfer of a substance initially distributed in a multilayer
    packaging structure into a food medium (or liquid medium). This solver uses a finite-volume
    method adapted from Patankar to handle partition coefficients between all layers, and
    between the food and the contact layer.

    Two typical configurations are implemented:

    Configuration (PBC=False)
        - Robin (third-kind boundary condition) on the left (in contact with food)
        - Impervious boundary condition on the right (in contact with surrounding)

    Configuration (PBC=true)
        - periodic boundary condition between left and right to simulate infinite stacking or setoff

    The configuration nofood is a variant of PBC=False with h=Bi=0 (impervious boundary condition on the left).

    The behavior of the solver is decided by medium attributes (see food.py module).
    The property medium.PBC will determine whether periodic boundary conditions are used or not.


    Parameters
    ----------
    multilayer : layer
        A ``layer`` (or combined layers) object describing the packaging.
    medium : foodlayer or foodphysics
        A ``foodlayer`` object describing the food (or liquid) medium in contact.
    name : str, optional
        Simulation name, default = f&#34;senspatantkar:{autoname(6)}&#34; where autoname(6)
        is a random sequence of characters a-z A-Z 0-9
    description : str, optional
        Simulation description
    t : float or array_like, optional
        If a float is provided, it is taken as the total contact duration in seconds.
        If an array is provided, it is assumed to be time points where the solution
        will be evaluated. If None, it defaults to the contact time from the medium.
    autotime : bool, optional
        If True (default), an automatic time discretization is generated internally
        (linear or sqrt-based) between 0 and tmax (the maximum time). If False, the
        times in ``t`` are used directly.
    timescale : {&#34;sqrt&#34;, &#34;linear&#34;}, optional
        Type of automatic time discretization if ``autotime=True``.
        &#34;sqrt&#34; (default) refines the early times more (useful for capturing rapid changes).
        &#34;linear&#34; uses a regular spacing.
    Cxprevious : Cprofile, optional (default=None)
        Concentration profile (from a previous simulation).
    ntimes : int, optional
        Number of time points in the automatically generated time vector if ``autotime=True``.
        The default is 1e3.
    RelTol : float, optional
        Relative tolerance for the ODE solver (``solve_ivp``). Default is 1e-4.
    AbsTol : float, optional
        Absolute tolerance for the ODE solver (``solve_ivp``). Default is 1e-4.

    Raises
    ------
    TypeError
        If ``multilayer`` is not a ``layer`` instance or ``medium`` is not a ``foodlayer`` instance,
        or if ``timescale`` is not a string.
    ValueError
        If an invalid ``timescale`` is given (not one of {&#34;sqrt&#34;, &#34;linear&#34;}).

    Returns
    -------
    SensPatankarResult
        An object containing the time vector, concentration histories, fluxes, and
        spatial concentration profiles suitable for plotting and analysis.

    Notes
    -----
    - The geometry is assumed 1D: Food is on the left boundary, with a mass transfer coefficient
      `h = medium.h`, partition ratio `k0 = medium.k0`, and the packaging layers are to the right
      up to an impervious boundary.
    - Results are normalized internally using a reference layer (``iref``) specified in ``multilayer``.
      The reference layer is used to define dimensionless time (Fourier number Fo).
    - The dimensionless solution is solved by the Patankar approach with partition coefficients.

    Example
    -------
    .. code-block:: python

        from patankar.food import ethanol
        from patankar.layer import layer
        medium = ethanol()
        A = layer(layername=&#34;layer A&#34;)
        B = layer(layername=&#34;layer B&#34;)
        multilayer = A + B

        sol = senspatankar(multilayer, medium, autotime=True, timescale=&#34;sqrt&#34;)
        sol.plotCF()
        sol.plotC()
    &#34;&#34;&#34;

    # Check arguments
    if not isinstance(multilayer, layer):
        raise TypeError(f&#34;the input multilayer must be of class layer, not {type(multilayer).__name__}&#34;)
    if not isinstance(medium, (foodlayer,foodphysics)):
        raise TypeError(f&#34;the input medium must be of class foodlayer, not {type(medium).__name__}&#34;)
    if not isinstance(timescale, str):
        raise TypeError(f&#34;timescale must be a string, not {type(timescale).__name__}&#34;)

    # Refresh the physics of medium for parameters tunned by the end-user
    medium.refresh()

    # extract the PBC flag (True for setoff)
    PBC = medium.PBC

    # Restart file initialization (all parameters are saved)
    restart = restartfile_senspantakar(multilayer, medium, name,
            description, t, autotime, timescale, Cxprevious, ntimes, RelTol, AbsTol)

    # Contact medium properties
    CF0 = medium.get_param(&#34;CF0&#34;,0) # instead of medium.CF0 to get a fallback mechanism with nofood and setoff
    k0 = medium.get_param(&#34;k0&#34;,1)
    h = medium.get_param(&#34;h&#34;,0,acceptNone=False) # None will arise for PBC
    ttarget = medium.get_param(&#34;contacttime&#34;) # &lt;-- ttarget is the time requested
    tmax = 2 * ttarget  # ensures at least up to 2*contacttime

    # Material properties
    k = multilayer.k / k0   # all k are normalized
    k0 = k0 / k0            # all k are normalized
    D = multilayer.D
    l = multilayer.l
    C0 = multilayer.C0

    # Validate/prepare time array
    if isinstance(t,tuple):
        t = check_units(t)[0]
    t = np.array(tmax if t is None else t, dtype=float) # &lt;-- simulation time (longer than ttarget)
    if np.isscalar(t) or t.size == 1:
        t = np.array([0, t.item()],dtype=float)
    if t[0] != 0:
        t = np.insert(t, 0, 0)  # Ensure time starts at zero
    # Ensure t[-1] is greater than ttarget
    if t[-1] &lt; ttarget.item():  # Convert ttarget to scalar before comparison
        t = np.append(t, [ttarget, 1.05*ttarget, 1.1*ttarget, 1.2*ttarget])  # Extend time array to cover requested time

    # Reference layer for dimensionless transformations
    iref = multilayer.referencelayer
    l_ref = l[iref]
    D_ref = D[iref]

    # Normalize lengths and diffusivities
    l_normalized = l / l_ref
    D_normalized = D / D_ref

    # Dimensionless time (Fourier number)
    timebase = l_ref**2 / D_ref
    Fo = t / timebase

    # Automatic time discretization if requested
    if autotime:
        if timescale.lower() == &#34;linear&#34;:
            Fo_int = np.linspace(np.min(Fo), np.max(Fo), int(ntimes))
        elif timescale.lower() == &#34;sqrt&#34;:
            Fo_int = np.linspace(np.sqrt(np.min(Fo)), np.sqrt(np.max(Fo)), int(ntimes))**2
        else:
            raise ValueError(&#39;timescale can be &#34;sqrt&#34; or &#34;linear&#34;&#39;)
        t = Fo_int * timebase
    else:
        Fo_int = Fo

    # L: dimensionless ratio of packaging to food volumes (scaled by reference layer thickness)
    A = medium.get_param(&#34;surfacearea&#34;,0)
    l_sum = multilayer.thickness
    VP = A * l_sum
    VF = medium.get_param(&#34;volume&#34;,1)
    LPF = VP / VF
    L = LPF * l_ref / l_sum

    # Bi: dimensionless mass transfer coefficient
    Bi = h * l_ref / D_ref

    # Compute equilibrium concentration factor
    sum_lL_C0 = np.sum(l_normalized * L * C0)
    sum_terms = np.sum((1 / k) * l_normalized * L)
    C0eq = (CF0 + sum_lL_C0) / (1 + sum_terms)
    if C0eq == 0:
        C0eq = 1.0

    # Normalize initial concentrations
    C0_normalized = C0 / C0eq
    CF0_normalized = CF0 / C0eq

    # Generate mesh (add offset x0 and concatenate them)
    meshes = multilayer.mesh()
    x0 = 0
    for i,mesh in enumerate((meshes)):
        mesh.xmesh += x0
        x0 += mesh.l
    xmesh = np.concatenate([m.xmesh for m in meshes])
    total_nodes = len(xmesh)

    # Positions of the interfaces (East and West)
    dw = np.concatenate([m.dw for m in meshes])
    de = np.concatenate([m.de for m in meshes])

    # Attach properties to nodes (flat interpolant)
    D_mesh = np.concatenate([D_normalized[m.index] for m in meshes])
    k_mesh = np.concatenate([k[m.index] for m in meshes])
    C0_mesh = np.concatenate([C0_normalized[m.index] for m in meshes])

    # Interpolate the initial solution if Cxprevious is supplied
    if Cxprevious is not None:
        if not isinstance(Cxprevious,Cprofile):
            raise TypeError(f&#34;Cxprevisous should be a Cprofile object not a {type(Cxprevious).__name__}&#34;)
        C0_mesh = Cxprevious.interp(xmesh*l_ref) / C0eq # dimensionless

    # Conductances between the node and the next interface
    # item() is forced to avoid the (1,) Shape Issue (since NumPy 1.25)
    hw = np.zeros(total_nodes)
    he = np.zeros(total_nodes)
    if PBC:
        for i in range(total_nodes):
            prev = total_nodes-1 if i==0 else i-1
            hw[i] = (1 / ((de[prev] / D_mesh[prev] * k_mesh[prev] / k_mesh[i]) + dw[i] / D_mesh[i])).item()
    else:
        hw[0] = (1 / ((1 / k_mesh[0]) / Bi + dw[0] / D_mesh[0])).item()
        for i in range(1, total_nodes):
            hw[i] = (1 / ((de[i - 1] / D_mesh[i - 1] * k_mesh[i - 1] / k_mesh[i]) + dw[i] / D_mesh[i])).item()
    he[:-1] = hw[1:] # nodes are the center of FV elements: he = np.roll(hw, -1)
    he[-1]=hw[0] if PBC else 0.0 # we connect (PBC) or we enforce impervious (note that he was initialized to 0 already)

    if PBC: # periodic boundary condition

        # Assemble sparse matrix using COO format for efficient construction
        rows = np.zeros(3 * total_nodes, dtype=int) # row indices
        cols = np.zeros_like(rows) # col indices
        data = np.zeros_like(rows, dtype=np.float64) # values
        idx = 0
        for i in range(total_nodes):
            current = i
            west = (i-1) % total_nodes
            east = (i+1) % total_nodes
            denominator = dw[current] + de[current]
            k_current = k_mesh[current]
            k_west = k_mesh[west]
            k_east = k_mesh[east]
            # West neighbor
            rows[idx] = current
            cols[idx] = west
            data[idx] = hw[current] * k_west / k_current / denominator
            idx +=1
            # Diagonal
            rows[idx] = current
            cols[idx] = current
            data[idx] = (-hw[current] - he[current] * k_current/k_east) / denominator
            idx +=1
            # East neighbor
            rows[idx] = current
            cols[idx] = east
            data[idx] = he[current] / denominator
            idx +=1
        A = coo_matrix((data[:idx], (rows[:idx], cols[:idx])),
                     shape=(total_nodes, total_nodes)).tocsr()
        C_initial =  C0_mesh

    else: # Robin (left) + impervious (right) --&gt; triband matrix

        # Assemble the tri-band matrix A as sparse for efficiency
        size = total_nodes + 1  # +1 for the food node
        main_diag = np.zeros(size)
        upper_diag = np.zeros(size - 1)
        lower_diag = np.zeros(size - 1)
        # Food node (index 0)
        main_diag[0] = (-L * hw[0] * (1 / k_mesh[0])).item()
        upper_diag[0] = (L * hw[0]).item()
        # Layer nodes
        for i in range(total_nodes):
            denom = dw[i] + de[i]
            if i == 0:
                main_diag[1] = (-hw[0] - he[0] * k_mesh[0] / k_mesh[1]) / denom
                upper_diag[1] = he[0] / denom
                lower_diag[0] = (hw[0] * (1 / k_mesh[0])) / denom
            elif i == total_nodes - 1:
                main_diag[i + 1] = (-hw[i]) / denom
                lower_diag[i] = (hw[i] * k_mesh[i - 1] / k_mesh[i]) / denom
            else:
                main_diag[i + 1] = (-hw[i] - he[i] * k_mesh[i] / k_mesh[i + 1]) / denom
                upper_diag[i + 1] = he[i] / denom
                lower_diag[i] = (hw[i] * k_mesh[i - 1] / k_mesh[i]) / denom
        A = diags([main_diag, upper_diag, lower_diag], [0, 1, -1], shape=(size, size), format=&#39;csr&#39;)
        C_initial = np.concatenate([CF0_normalized, C0_mesh])

    # ODE system: dC/dFo = A * C
    def odesys(_, C):
        return A.dot(C)

    sol = solve_ivp(   # &lt;-- generic solver
        odesys,        # &lt;-- our system (efficient sparse matrices)
        [Fo_int[0], Fo_int[-1]], # &lt;-- integration range on Fourier scale
        C_initial,     # &lt;-- initial solution
        t_eval=Fo_int, # &lt;-- the solution is retrieved at these Fo values
        method=&#39;BDF&#39;,  # &lt;-- backward differences are absolutely stable
        rtol=RelTol,   # &lt;-- relative and absolute tolerances
        atol=AbsTol
    )

    # Check solution
    if not sol.success:
        print(&#34;Solver failed:&#34;, sol.message)

    # Extract solution
    if PBC:
        CF_dimless = np.full((sol.y.shape[1],), CF0 / C0eq)
        C_dimless = sol.y
        f = np.zeros_like(CF_dimless)
    else:
        CF_dimless = sol.y[0, :]
        C_dimless = sol.y[1:, :]
        # Robin flux
        f = hw[0] * (k0 * CF_dimless - C_dimless[0, :]) * C0eq

    # Compute cumulative flux
    fc = cumulative_trapezoid(f, t, initial=0)

    if PBC:
        # Build full (dimensionless) profile for plotting across each sub-node
        xfull, Cfull_dimless = compute_fc_profile_PBC(C_dimless, Fo_int, de, dw, he, hw, k_mesh, D_mesh, xmesh, xreltol=0)
        # Build full (dimensionless) profile for interpolation across each sub-node
        xfulli, Cfull_dimlessi = compute_fc_profile_PBC(C_dimless, Fo_int, de, dw, he, hw, k_mesh, D_mesh, xmesh, xreltol=1e-4)
    else:
        # Build full (dimensionless) profile for plotting across each sub-node
        xfull, Cfull_dimless = compute_fv_profile(xmesh, dw, de,C_dimless, k_mesh, D_mesh, hw, he, CF_dimless, k0, Fo_int, xreltol=0)
        # Build full (dimensionless) profile for interpolation across each sub-node
        xfulli, Cfull_dimlessi = compute_fv_profile(xmesh, dw, de,C_dimless, k_mesh, D_mesh, hw, he, CF_dimless, k0, Fo_int, xreltol=1e-4)


    # revert to dimensional concentrations
    CF = CF_dimless * C0eq
    Cx = Cfull_dimless * C0eq

    return SensPatankarResult(
        name=name,
        description=description,
        ttarget = ttarget,             # target time
        t=t,     # time where concentrations are calculated
        C= np.trapz(Cfull_dimless, xfull, axis=1)*C0eq,
        CF=CF,
        fc=fc,
        f=f,
        x=xfull * l_ref,           # revert to dimensional lengths
        Cx=Cx,
        tC=sol.t,
        C0eq=C0eq,
        timebase=timebase,
        restart=restart, # &lt;--- restart info (inputs only)
        xi=xfulli*l_ref, # for restart only
        Cxi=Cfull_dimlessi*C0eq # for restart only
    )


# Exact FV interpolant (with Robin BC)
def compute_fv_profile(xmesh, dw, de, C_dimless, k_mesh, D_mesh, hw, he, CF_dimless, k0, Fo_int, xreltol=0):
    &#34;&#34;&#34;
    Compute the full finite-volume concentration profile, including node values and interface values.
    (this function is not nested inside senspantar for better readability)

    Parameters:
        xmesh (np.ndarray): Node positions.
        dw (np.ndarray): Distance to west interfaces.
        de (np.ndarray): Distance to east interfaces.
        C_dimless (np.ndarray): Concentration at nodes.
        k_mesh (np.ndarray): Henri-like coefficient at nodes.
        D_mesh (np.ndarray): Diffusion coefficient at nodes.
        hw (np.ndarray): Conductance to west interface.
        he (np.ndarray): Conductance to east interface.
        CF_dimless (np.ndarray): Far-field (Food) concentration values.
        k0 (float): Partition coefficient at the boundary.
        Fo_int (np.ndarray): Time steps.
        xreltol (float, optional): Relative perturbation factor for interpolation accuracy. Defaults to 0.

    Returns:
        xfull (np.ndarray): Full spatial positions including nodes and interfaces.
        Cfull_dimless (np.ndarray): Full concentration profile.
    &#34;&#34;&#34;
    num_nodes, num_timesteps = C_dimless.shape  # Extract shape

    # Compute xtol based on minimum interface distances
    xtol = np.min([np.min(de), np.min(dw)]) * xreltol

    # Adjust west and east interface positions
    xw = xmesh - dw + xtol  # Shift west interface
    xe = xmesh + de - xtol  # Shift east interface

    # Build full spatial profile
    xfull = np.empty(3 * num_nodes)
    xfull[::3] = xw      # Every 3rd position is xw
    xfull[1::3] = xmesh  # Every 3rd position (offset by 1) is xmesh
    xfull[2::3] = xe     # Every 3rd position (offset by 2) is xe

    # Initialize concentration at interfaces
    Ce = np.zeros_like(C_dimless)  # East interfaces
    Cw = np.zeros_like(C_dimless)  # West interfaces

    # Compute Ce (east interface) for all timesteps at once
    Ce[:-1, :] = C_dimless[:-1, :] - (
        (de[:-1, None] * he[:-1, None] *
        ((k_mesh[:-1, None] / k_mesh[1:, None]) * C_dimless[:-1, :] - C_dimless[1:, :]))
        / D_mesh[:-1, None]
    )
    Ce[-1, :] = C_dimless[-1, :]  # Last node follows boundary condition

    # Compute Cw (west interface) for all timesteps at once
    Cw[1:, :] = C_dimless[1:, :] + (
        (dw[1:, None] * hw[1:, None] *
        ((k_mesh[:-1, None] / k_mesh[1:, None]) * C_dimless[:-1, :] - C_dimless[1:, :]))
        / D_mesh[1:, None]
    )

    # Compute Cw[0, :] separately to handle boundary condition
    Cw[0, :] = (C_dimless[0, :] + (
        dw[0] * hw[0] *
        (k0 / k_mesh[0] * CF_dimless - C_dimless[0, :])
        / D_mesh[0]
    )).flatten()  # Ensure correct shape

    # Interleave concentration values instead of using np.hstack and reshape
    Cfull_dimless = np.empty((num_timesteps, 3 * num_nodes))
    Cfull_dimless[:, ::3] = Cw.T      # Every 3rd column is Cw
    Cfull_dimless[:, 1::3] = C_dimless.T  # Every 3rd column (offset by 1) is C
    Cfull_dimless[:, 2::3] = Ce.T      # Every 3rd column (offset by 2) is Ce

    return xfull, Cfull_dimless


def compute_fc_profile_PBC(C, t, de, dw, he, hw, k, D, xmesh, xreltol=0):
    &#34;&#34;&#34;Calculate interface concentrations with periodic boundary conditions&#34;&#34;&#34;

    num_nodes, num_timesteps = C.shape  # Extract dimensions

    # Pre-calculate shifted indices for periodic BC
    east_shift = np.roll(np.arange(num_nodes), -1)  # Shift left (next node)
    west_shift = np.roll(np.arange(num_nodes), 1)   # Shift right (previous node)

    # Get shifted concentrations and diffusion coefficients
    C_east = C[east_shift, :]  # Shape (num_nodes, num_timesteps)
    C_west = C[west_shift, :]  # Shape (num_nodes, num_timesteps)
    k_east = k[east_shift][:, None]  # Make it broadcastable (num_nodes, 1)
    k_west = k[west_shift][:, None]  # Make it broadcastable (num_nodes, 1)

    # Eastern interface concentrations (vectorized)
    Ce = C - (de[:, None] * he[:, None] * ((k[:, None] / k_east) * C - C_east) / D[:, None])

    # Western interface concentrations (vectorized)
    Cw = C + (dw[:, None] * hw[:, None] * ((k_west / k[:, None]) * C_west - C) / D[:, None])

    # Create full concentration matrix with interfaces
    Cfull = np.empty((num_timesteps, 3*num_nodes))

    # Compute positional tolerances
    xtol = np.min([np.min(de), np.min(dw)]) * xreltol
    xw = xmesh - dw + xtol  # Shifted west positions
    xe = xmesh + de - xtol  # Shifted east positions

    # Interleave values: West, Center, East
    Cfull[:, ::3] = Cw.T  # Ensure correct alignment
    Cfull[:, 1::3] = C.T
    Cfull[:, 2::3] = Ce.T

    # Create full position vector
    xfull = np.empty(3*num_nodes)
    xfull[::3] = xw
    xfull[1::3] = xmesh
    xfull[2::3] = xe

    return xfull, Cfull

# %% test and debug
# -------------------------------------------------------------------
# Example usage (for debugging / standalone tests)
# -------------------------------------------------------------------
if __name__ == &#39;__main__&#39;:
    from patankar.food import ethanol, setoff, nofood
    from patankar.layer import PP

    medium = ethanol()
    medium.CF0 = 100 # works
    medium.update(CF0=100) # works also
    A = layer(layername=&#34;layer A&#34;,k=2,C0=0,D=1e-16)
    B = layer(layername=&#34;layer B&#34;)
    multilayer = A + B
    sol1 = senspatankar(multilayer, medium,t=(25,&#34;days&#34;))
    sol1.plotCF(t=np.array([3,10,14])*24*3600)
    sol1.plotCx()
    r=sol1.restart
    repr(r)

    # extend the solution for 40 days
    sol2 = sol1.resume((40,&#34;days&#34;))
    sol2.plotCF()
    sol2.plotCx()

    # extend the solution for 60 days from sol2
    sol3 = sol2.resume((60,&#34;days&#34;))
    sol3.update(name=&#34;sol3&#34;)
    sol3.plotCF()
    sol3.plotCx()

    # merge the previous solutions 1+2
    # extend the solution for 60 days from sol12=sol1+sol2
    sol12 = sol1+sol2
    sol123a = sol12.resume((60,&#34;days&#34;))
    sol123a.update(name=&#34;sol123a&#34;)
    sol123a.plotCF()
    sol123a.plotCx()

    # concat
    sol123a_ = sol12 + sol123a
    sol123a_.update(name=&#34;sol123a_ (full): sol12 + sol123a&#34;)
    sol123a_.plotCF()

    # compare with sol1+sol2+sol3
    sol123_ = sol1+sol2+sol3
    sol123_.update(name=&#34;sol123_ (full): sol1+sol2+sol3&#34;)
    sol123_.plotCF()
    sol123_.plotCx()

    # simulation of setoff
    packstorage = setoff(contacttime=(100,&#34;days&#34;))
    A = PP(l=(500,&#34;um&#34;),C0=0)
    B = PP(l=(300,&#34;um&#34;),C0=5000)
    AB = A+B
    print(medium)
    solAB = senspatankar(AB,packstorage)
    solAB.plotCx()

    # we extend the previous solution by putting medium in contact
    solABext = solAB.resume(medium=medium)
    solABext.plotCF()
    solABext.plotCx()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="migration.autoname"><code class="name flex">
<span>def <span class="ident">autoname</span></span>(<span>nchars=6, charset='a-zA-Z0-9')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a random simulation name.</p>
<p>Parameters:
- nchars (int): Number of characters in the name (default: 6).
- charset (str): Character set pattern (e.g., "a-zA-Z0-9").</p>
<p>Returns:
- str: A randomly generated name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def autoname(nchars=6, charset=&#34;a-zA-Z0-9&#34;):
    &#34;&#34;&#34;
    Generates a random simulation name.

    Parameters:
    - nchars (int): Number of characters in the name (default: 6).
    - charset (str): Character set pattern (e.g., &#34;a-zA-Z0-9&#34;).

    Returns:
    - str: A randomly generated name.
    &#34;&#34;&#34;

    # Expand regex-like charset pattern
    char_pool = []
    # Find all ranges (e.g., &#34;a-z&#34;, &#34;A-Z&#34;, &#34;0-9&#34;)
    pattern = re.findall(r&#39;([a-zA-Z0-9])\-([a-zA-Z0-9])&#39;, charset)
    for start, end in pattern:
        char_pool.extend(chr(c) for c in range(ord(start), ord(end) + 1))
    # Include any explicit characters (e.g., &#34;ABC&#34; in &#34;ABC0-9&#34;)
    explicit_chars = re.sub(r&#39;([a-zA-Z0-9])\-([a-zA-Z0-9])&#39;, &#39;&#39;, charset)  # Remove ranges
    char_pool.extend(explicit_chars)
    # Remove duplicates and sort (just for readability)
    char_pool = sorted(set(char_pool))
    # Generate random name
    return &#39;&#39;.join(random.choices(char_pool, k=nchars))</code></pre>
</details>
</dd>
<dt id="migration.check_units"><code class="name flex">
<span>def <span class="ident">check_units</span></span>(<span>value, ProvidedUnits=None, ExpectedUnits=None, defaulttempUnits='degC')</span>
</code></dt>
<dd>
<div class="desc"><p>check numeric inputs and convert them to SI units</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_units(value,ProvidedUnits=None,ExpectedUnits=None,defaulttempUnits=&#34;degC&#34;):
    &#34;&#34;&#34; check numeric inputs and convert them to SI units &#34;&#34;&#34;
    # by convention, NumPy arrays and None are return unchanged (prevent nesting)
    if isinstance(value,np.ndarray) or value is None:
        return value,UnknownUnits
    if isinstance(value,tuple):
        if len(value) != 2:
            raise ValueError(&#39;value should be a tuple: (value,&#34;unit&#34;&#39;)
        ProvidedUnits = value[1]
        value = value[0]
    if isinstance(value,list): # the function is vectorized
        value = np.array(value)
    if {&#34;degC&#34;, &#34;K&#34;} &amp; {ProvidedUnits, ExpectedUnits}: # the value is a temperature
        ExpectedUnits = defaulttempUnits if ExpectedUnits is None else ExpectedUnits
        ProvidedUnits = ExpectedUnits if ProvidedUnits is None else ProvidedUnits
        if ProvidedUnits==&#34;degC&#34; and ExpectedUnits==&#34;K&#34;:
            value += constants[&#34;T0K&#34;]
        elif ProvidedUnits==&#34;K&#34; and ExpectedUnits==&#34;degC&#34;:
            value -= constants[&#34;T0K&#34;]
        return np.array([value]),ExpectedUnits
    else: # the value is not a temperature
        ExpectedUnits = NoUnits if ExpectedUnits is None else ExpectedUnits
        if (ProvidedUnits==ExpectedUnits) or (ProvidedUnits==NoUnits) or (ExpectedUnits==None):
            conversion =1               # no conversion needed
            units = ExpectedUnits if ExpectedUnits is not None else NoUnits
        else:
            q0,conversion,units = toSI(qSI(1,ProvidedUnits))
        return np.array([value*conversion]),units</code></pre>
</details>
</dd>
<dt id="migration.compute_fc_profile_PBC"><code class="name flex">
<span>def <span class="ident">compute_fc_profile_PBC</span></span>(<span>C, t, de, dw, he, hw, k, D, xmesh, xreltol=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate interface concentrations with periodic boundary conditions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_fc_profile_PBC(C, t, de, dw, he, hw, k, D, xmesh, xreltol=0):
    &#34;&#34;&#34;Calculate interface concentrations with periodic boundary conditions&#34;&#34;&#34;

    num_nodes, num_timesteps = C.shape  # Extract dimensions

    # Pre-calculate shifted indices for periodic BC
    east_shift = np.roll(np.arange(num_nodes), -1)  # Shift left (next node)
    west_shift = np.roll(np.arange(num_nodes), 1)   # Shift right (previous node)

    # Get shifted concentrations and diffusion coefficients
    C_east = C[east_shift, :]  # Shape (num_nodes, num_timesteps)
    C_west = C[west_shift, :]  # Shape (num_nodes, num_timesteps)
    k_east = k[east_shift][:, None]  # Make it broadcastable (num_nodes, 1)
    k_west = k[west_shift][:, None]  # Make it broadcastable (num_nodes, 1)

    # Eastern interface concentrations (vectorized)
    Ce = C - (de[:, None] * he[:, None] * ((k[:, None] / k_east) * C - C_east) / D[:, None])

    # Western interface concentrations (vectorized)
    Cw = C + (dw[:, None] * hw[:, None] * ((k_west / k[:, None]) * C_west - C) / D[:, None])

    # Create full concentration matrix with interfaces
    Cfull = np.empty((num_timesteps, 3*num_nodes))

    # Compute positional tolerances
    xtol = np.min([np.min(de), np.min(dw)]) * xreltol
    xw = xmesh - dw + xtol  # Shifted west positions
    xe = xmesh + de - xtol  # Shifted east positions

    # Interleave values: West, Center, East
    Cfull[:, ::3] = Cw.T  # Ensure correct alignment
    Cfull[:, 1::3] = C.T
    Cfull[:, 2::3] = Ce.T

    # Create full position vector
    xfull = np.empty(3*num_nodes)
    xfull[::3] = xw
    xfull[1::3] = xmesh
    xfull[2::3] = xe

    return xfull, Cfull</code></pre>
</details>
</dd>
<dt id="migration.compute_fv_profile"><code class="name flex">
<span>def <span class="ident">compute_fv_profile</span></span>(<span>xmesh, dw, de, C_dimless, k_mesh, D_mesh, hw, he, CF_dimless, k0, Fo_int, xreltol=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the full finite-volume concentration profile, including node values and interface values.
(this function is not nested inside senspantar for better readability)</p>
<h2 id="parameters">Parameters</h2>
<p>xmesh (np.ndarray): Node positions.
dw (np.ndarray): Distance to west interfaces.
de (np.ndarray): Distance to east interfaces.
C_dimless (np.ndarray): Concentration at nodes.
k_mesh (np.ndarray): Henri-like coefficient at nodes.
D_mesh (np.ndarray): Diffusion coefficient at nodes.
hw (np.ndarray): Conductance to west interface.
he (np.ndarray): Conductance to east interface.
CF_dimless (np.ndarray): Far-field (Food) concentration values.
k0 (float): Partition coefficient at the boundary.
Fo_int (np.ndarray): Time steps.
xreltol (float, optional): Relative perturbation factor for interpolation accuracy. Defaults to 0.</p>
<h2 id="returns">Returns</h2>
<p>xfull (np.ndarray): Full spatial positions including nodes and interfaces.
Cfull_dimless (np.ndarray): Full concentration profile.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_fv_profile(xmesh, dw, de, C_dimless, k_mesh, D_mesh, hw, he, CF_dimless, k0, Fo_int, xreltol=0):
    &#34;&#34;&#34;
    Compute the full finite-volume concentration profile, including node values and interface values.
    (this function is not nested inside senspantar for better readability)

    Parameters:
        xmesh (np.ndarray): Node positions.
        dw (np.ndarray): Distance to west interfaces.
        de (np.ndarray): Distance to east interfaces.
        C_dimless (np.ndarray): Concentration at nodes.
        k_mesh (np.ndarray): Henri-like coefficient at nodes.
        D_mesh (np.ndarray): Diffusion coefficient at nodes.
        hw (np.ndarray): Conductance to west interface.
        he (np.ndarray): Conductance to east interface.
        CF_dimless (np.ndarray): Far-field (Food) concentration values.
        k0 (float): Partition coefficient at the boundary.
        Fo_int (np.ndarray): Time steps.
        xreltol (float, optional): Relative perturbation factor for interpolation accuracy. Defaults to 0.

    Returns:
        xfull (np.ndarray): Full spatial positions including nodes and interfaces.
        Cfull_dimless (np.ndarray): Full concentration profile.
    &#34;&#34;&#34;
    num_nodes, num_timesteps = C_dimless.shape  # Extract shape

    # Compute xtol based on minimum interface distances
    xtol = np.min([np.min(de), np.min(dw)]) * xreltol

    # Adjust west and east interface positions
    xw = xmesh - dw + xtol  # Shift west interface
    xe = xmesh + de - xtol  # Shift east interface

    # Build full spatial profile
    xfull = np.empty(3 * num_nodes)
    xfull[::3] = xw      # Every 3rd position is xw
    xfull[1::3] = xmesh  # Every 3rd position (offset by 1) is xmesh
    xfull[2::3] = xe     # Every 3rd position (offset by 2) is xe

    # Initialize concentration at interfaces
    Ce = np.zeros_like(C_dimless)  # East interfaces
    Cw = np.zeros_like(C_dimless)  # West interfaces

    # Compute Ce (east interface) for all timesteps at once
    Ce[:-1, :] = C_dimless[:-1, :] - (
        (de[:-1, None] * he[:-1, None] *
        ((k_mesh[:-1, None] / k_mesh[1:, None]) * C_dimless[:-1, :] - C_dimless[1:, :]))
        / D_mesh[:-1, None]
    )
    Ce[-1, :] = C_dimless[-1, :]  # Last node follows boundary condition

    # Compute Cw (west interface) for all timesteps at once
    Cw[1:, :] = C_dimless[1:, :] + (
        (dw[1:, None] * hw[1:, None] *
        ((k_mesh[:-1, None] / k_mesh[1:, None]) * C_dimless[:-1, :] - C_dimless[1:, :]))
        / D_mesh[1:, None]
    )

    # Compute Cw[0, :] separately to handle boundary condition
    Cw[0, :] = (C_dimless[0, :] + (
        dw[0] * hw[0] *
        (k0 / k_mesh[0] * CF_dimless - C_dimless[0, :])
        / D_mesh[0]
    )).flatten()  # Ensure correct shape

    # Interleave concentration values instead of using np.hstack and reshape
    Cfull_dimless = np.empty((num_timesteps, 3 * num_nodes))
    Cfull_dimless[:, ::3] = Cw.T      # Every 3rd column is Cw
    Cfull_dimless[:, 1::3] = C_dimless.T  # Every 3rd column (offset by 1) is C
    Cfull_dimless[:, 2::3] = Ce.T      # Every 3rd column (offset by 2) is Ce

    return xfull, Cfull_dimless</code></pre>
</details>
</dd>
<dt id="migration.custom_plt_figure"><code class="name flex">
<span>def <span class="ident">custom_plt_figure</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure all figures are PrintableFigure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_plt_figure(*args, **kwargs):
    &#34;&#34;&#34;Ensure all figures are PrintableFigure.&#34;&#34;&#34;
    kwargs.setdefault(&#34;FigureClass&#34;, PrintableFigure)
    return original_plt_figure(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="migration.custom_plt_subplots"><code class="name flex">
<span>def <span class="ident">custom_plt_subplots</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure plt.subplots() returns a PrintableFigure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_plt_subplots(*args, **kwargs):
    &#34;&#34;&#34;Ensure plt.subplots() returns a PrintableFigure.&#34;&#34;&#34;
    kwargs.setdefault(&#34;FigureClass&#34;, PrintableFigure)
    fig, ax = original_plt_subplots(*args, **kwargs)
    return fig, ax</code></pre>
</details>
</dd>
<dt id="migration.is_valid_figure"><code class="name flex">
<span>def <span class="ident">is_valid_figure</span></span>(<span>fig)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if <code>fig</code> is a valid and open Matplotlib figure.</p>
<p>Parameters:
- fig: object to check</p>
<p>Returns:
- bool: True if <code>fig</code> is a valid, open Matplotlib figure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_figure(fig):
    &#34;&#34;&#34;
    Checks if `fig` is a valid and open Matplotlib figure.

    Parameters:
    - fig: object to check

    Returns:
    - bool: True if `fig` is a valid, open Matplotlib figure.
    &#34;&#34;&#34;
    return isinstance(fig, Figure) and plt.fignum_exists(fig.number)</code></pre>
</details>
</dd>
<dt id="migration.print_figure"><code class="name flex">
<span>def <span class="ident">print_figure</span></span>(<span>fig, filename='', destinationfolder='/home/olivi/natacha/python/utils', overwrite=False, dpi=300)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the figure in both PDF and PNG formats.</p>
<p>Parameters:
- fig: Matplotlib figure object to be saved.
- filename: str, base filename (auto-generated if empty).
- destinationfolder: str, folder to save the files.
- overwrite: bool, overwrite existing files.
- dpi: int, resolution (default=300).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_figure(fig, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
    &#34;&#34;&#34;
    Save the figure in both PDF and PNG formats.

    Parameters:
    - fig: Matplotlib figure object to be saved.
    - filename: str, base filename (auto-generated if empty).
    - destinationfolder: str, folder to save the files.
    - overwrite: bool, overwrite existing files.
    - dpi: int, resolution (default=300).
    &#34;&#34;&#34;
    if is_valid_figure(fig):
        print_pdf(fig, filename, destinationfolder, overwrite, dpi)
        print_png(fig, filename, destinationfolder, overwrite, dpi)
    else:
        print(&#34;no valid figure&#34;)</code></pre>
</details>
</dd>
<dt id="migration.print_pdf"><code class="name flex">
<span>def <span class="ident">print_pdf</span></span>(<span>fig, filename='', destinationfolder='/home/olivi/natacha/python/utils', overwrite=False, dpi=300)</span>
</code></dt>
<dd>
<div class="desc"><p>Save a given figure as a PDF.</p>
<p>Parameters:
- fig: Matplotlib figure object to be saved.
- filename: str, PDF filename (auto-generated if empty).
- destinationfolder: str, folder to save the file.
- overwrite: bool, overwrite existing file.
- dpi: int, resolution (default=300).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_pdf(fig, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
    &#34;&#34;&#34;
    Save a given figure as a PDF.

    Parameters:
    - fig: Matplotlib figure object to be saved.
    - filename: str, PDF filename (auto-generated if empty).
    - destinationfolder: str, folder to save the file.
    - overwrite: bool, overwrite existing file.
    - dpi: int, resolution (default=300).
    &#34;&#34;&#34;
    if not is_valid_figure(fig):
        print(&#34;no valid figure&#34;)
        return
    # Generate filename if not provided
    if not filename:
        filename = _generate_figname(fig, &#34;.pdf&#34;)
    # Ensure full path
    filename = os.path.join(destinationfolder, filename)
    # Prevent overwriting unless specified
    if not overwrite and os.path.exists(filename):
        print(f&#34;File {filename} already exists. Use overwrite=True to replace it.&#34;)
        return
    # Save figure as PDF
    fig.savefig(filename, format=&#34;pdf&#34;, dpi=dpi, bbox_inches=&#34;tight&#34;)
    print(f&#34;Saved PDF: {filename}&#34;)</code></pre>
</details>
</dd>
<dt id="migration.print_png"><code class="name flex">
<span>def <span class="ident">print_png</span></span>(<span>fig, filename='', destinationfolder='/home/olivi/natacha/python/utils', overwrite=False, dpi=300)</span>
</code></dt>
<dd>
<div class="desc"><p>Save a given figure as a PNG.</p>
<p>Parameters:
- fig: Matplotlib figure object to be saved.
- filename: str, PNG filename (auto-generated if empty).
- destinationfolder: str, folder to save the file.
- overwrite: bool, overwrite existing file.
- dpi: int, resolution (default=300).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_png(fig, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
    &#34;&#34;&#34;
    Save a given figure as a PNG.

    Parameters:
    - fig: Matplotlib figure object to be saved.
    - filename: str, PNG filename (auto-generated if empty).
    - destinationfolder: str, folder to save the file.
    - overwrite: bool, overwrite existing file.
    - dpi: int, resolution (default=300).
    &#34;&#34;&#34;
    if not is_valid_figure(fig):
        print(&#34;no valid figure&#34;)
        return
    # Generate filename if not provided
    if not filename:
        filename = _generate_figname(fig, &#34;.png&#34;)
    # Ensure full path
    filename = os.path.join(destinationfolder, filename)
    # Prevent overwriting unless specified
    if not overwrite and os.path.exists(filename):
        print(f&#34;File {filename} already exists. Use overwrite=True to replace it.&#34;)
        return
    # Save figure as PNG
    fig.savefig(filename, format=&#34;png&#34;, dpi=dpi, bbox_inches=&#34;tight&#34;)
    print(f&#34;Saved PNG: {filename}&#34;)</code></pre>
</details>
</dd>
<dt id="migration.rgb"><code class="name flex">
<span>def <span class="ident">rgb</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a categorized color chart with properly aligned headers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rgb():
    &#34;&#34;&#34;Displays a categorized color chart with properly aligned headers.&#34;&#34;&#34;
    ncols = len(COLOR_CATEGORIES)
    max_rows = max(len(colors) + spacing for _, colors, spacing in COLOR_CATEGORIES)
    fig, ax = plt.subplots(figsize=(ncols * 2.5, max_rows * 0.6))
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_frame_on(False)
    x_spacing = 1.8  # Horizontal spacing between columns
    y_spacing = 1.0  # Vertical spacing between color patches
    text_size = 13   # Increased text size by 50%
    for col_idx, (category, colors, extra_space) in enumerate(COLOR_CATEGORIES):
        y_pos = max_rows  # Start at the top
        ax.text(col_idx * x_spacing + (x_spacing - 0.2) / 2, y_pos + 1.2, category,
                fontsize=text_size + 2, fontweight=&#39;bold&#39;, ha=&#39;center&#39;)
        y_pos -= y_spacing  # Move down after title
        for color in colors:
            if color == &#34;&#34;:  # Empty string is a spacer
                y_pos -= y_spacing * 0.5
                continue
            hexval = CSS_COLORS.get(color.lower(), &#34;white&#34;)
            y_pos -= y_spacing  # Move down before drawing
            ax.add_patch(plt.Rectangle((col_idx * x_spacing, y_pos), x_spacing - 0.2, y_spacing - 0.2, facecolor=hexval))
            r, g, b = mcolors.to_rgb(hexval)
            brightness = (r + g + b) / 3
            text_color = &#39;white&#39; if brightness &lt; 0.5 else &#39;black&#39;
            ax.text(col_idx * x_spacing + (x_spacing - 0.2) / 2, y_pos + y_spacing / 2, color, ha=&#39;center&#39;,
                    va=&#39;center&#39;, fontsize=text_size, color=text_color)
        y_pos -= extra_space * y_spacing
    ax.set_xlim(-0.5, ncols * x_spacing)
    ax.set_ylim(-0.5, max_rows * y_spacing + 2)
    plt.tight_layout()
    plt.show()</code></pre>
</details>
</dd>
<dt id="migration.senspatankar"><code class="name flex">
<span>def <span class="ident">senspatankar</span></span>(<span>multilayer=None, medium=None, name='senspatantkar:y1fCdu', description='', t=None, autotime=True, timescale='sqrt', Cxprevious=None, ntimes=1000.0, RelTol=1e-06, AbsTol=1e-06)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulates in 1D the mass transfer of a substance initially distributed in a multilayer
packaging structure into a food medium (or liquid medium). This solver uses a finite-volume
method adapted from Patankar to handle partition coefficients between all layers, and
between the food and the contact layer.</p>
<p>Two typical configurations are implemented:</p>
<p>Configuration (PBC=False)
- Robin (third-kind boundary condition) on the left (in contact with food)
- Impervious boundary condition on the right (in contact with surrounding)</p>
<p>Configuration (PBC=true)
- periodic boundary condition between left and right to simulate infinite stacking or setoff</p>
<p>The configuration nofood is a variant of PBC=False with h=Bi=0 (impervious boundary condition on the left).</p>
<p>The behavior of the solver is decided by medium attributes (see food.py module).
The property medium.PBC will determine whether periodic boundary conditions are used or not.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>multilayer</code></strong> :&ensp;<code><a title="migration.layer" href="#migration.layer">layer</a></code></dt>
<dd>A <code><a title="migration.layer" href="#migration.layer">layer</a></code> (or combined layers) object describing the packaging.</dd>
<dt><strong><code>medium</code></strong> :&ensp;<code><a title="migration.foodlayer" href="#migration.foodlayer">foodlayer</a></code> or <code><a title="migration.foodphysics" href="#migration.foodphysics">foodphysics</a></code></dt>
<dd>A <code><a title="migration.foodlayer" href="#migration.foodlayer">foodlayer</a></code> object describing the food (or liquid) medium in contact.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Simulation name, default = f"senspatantkar:{autoname(6)}" where autoname(6)
is a random sequence of characters a-z A-Z 0-9</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Simulation description</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code> or <code>array_like</code>, optional</dt>
<dd>If a float is provided, it is taken as the total contact duration in seconds.
If an array is provided, it is assumed to be time points where the solution
will be evaluated. If None, it defaults to the contact time from the medium.</dd>
<dt><strong><code>autotime</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True (default), an automatic time discretization is generated internally
(linear or sqrt-based) between 0 and tmax (the maximum time). If False, the
times in <code>t</code> are used directly.</dd>
<dt><strong><code>timescale</code></strong> :&ensp;<code>{"sqrt", "linear"}</code>, optional</dt>
<dd>Type of automatic time discretization if <code>autotime=True</code>.
"sqrt" (default) refines the early times more (useful for capturing rapid changes).
"linear" uses a regular spacing.</dd>
<dt><strong><code>Cxprevious</code></strong> :&ensp;<code><a title="migration.Cprofile" href="#migration.Cprofile">Cprofile</a></code>, optional <code>(default=None)</code></dt>
<dd>Concentration profile (from a previous simulation).</dd>
<dt><strong><code>ntimes</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of time points in the automatically generated time vector if <code>autotime=True</code>.
The default is 1e3.</dd>
<dt><strong><code>RelTol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Relative tolerance for the ODE solver (<code>solve_ivp</code>). Default is 1e-4.</dd>
<dt><strong><code>AbsTol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Absolute tolerance for the ODE solver (<code>solve_ivp</code>). Default is 1e-4.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If <code>multilayer</code> is not a <code><a title="migration.layer" href="#migration.layer">layer</a></code> instance or <code>medium</code> is not a <code><a title="migration.foodlayer" href="#migration.foodlayer">foodlayer</a></code> instance,
or if <code>timescale</code> is not a string.</dd>
<dt><code>ValueError</code></dt>
<dd>If an invalid <code>timescale</code> is given (not one of {"sqrt", "linear"}).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="migration.SensPatankarResult" href="#migration.SensPatankarResult">SensPatankarResult</a></code></dt>
<dd>An object containing the time vector, concentration histories, fluxes, and
spatial concentration profiles suitable for plotting and analysis.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>The geometry is assumed 1D: Food is on the left boundary, with a mass transfer coefficient
<code>h = medium.h</code>, partition ratio <code>k0 = medium.k0</code>, and the packaging layers are to the right
up to an impervious boundary.</li>
<li>Results are normalized internally using a reference layer (<code>iref</code>) specified in <code>multilayer</code>.
The reference layer is used to define dimensionless time (Fourier number Fo).</li>
<li>The dimensionless solution is solved by the Patankar approach with partition coefficients.</li>
</ul>
<h2 id="example">Example</h2>
<p>.. code-block:: python</p>
<pre><code>from patankar.food import ethanol
from patankar.layer import layer
medium = ethanol()
A = layer(layername="layer A")
B = layer(layername="layer B")
multilayer = A + B

sol = senspatankar(multilayer, medium, autotime=True, timescale="sqrt")
sol.plotCF()
sol.plotC()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def senspatankar(multilayer=None, medium=None,
                 name=f&#34;senspatantkar:{autoname(6)}&#34;, description=&#34;&#34;,
                 t=None, autotime=True, timescale=&#34;sqrt&#34;, Cxprevious=None,
                 ntimes=1e3, RelTol=1e-6, AbsTol=1e-6):
    &#34;&#34;&#34;
    Simulates in 1D the mass transfer of a substance initially distributed in a multilayer
    packaging structure into a food medium (or liquid medium). This solver uses a finite-volume
    method adapted from Patankar to handle partition coefficients between all layers, and
    between the food and the contact layer.

    Two typical configurations are implemented:

    Configuration (PBC=False)
        - Robin (third-kind boundary condition) on the left (in contact with food)
        - Impervious boundary condition on the right (in contact with surrounding)

    Configuration (PBC=true)
        - periodic boundary condition between left and right to simulate infinite stacking or setoff

    The configuration nofood is a variant of PBC=False with h=Bi=0 (impervious boundary condition on the left).

    The behavior of the solver is decided by medium attributes (see food.py module).
    The property medium.PBC will determine whether periodic boundary conditions are used or not.


    Parameters
    ----------
    multilayer : layer
        A ``layer`` (or combined layers) object describing the packaging.
    medium : foodlayer or foodphysics
        A ``foodlayer`` object describing the food (or liquid) medium in contact.
    name : str, optional
        Simulation name, default = f&#34;senspatantkar:{autoname(6)}&#34; where autoname(6)
        is a random sequence of characters a-z A-Z 0-9
    description : str, optional
        Simulation description
    t : float or array_like, optional
        If a float is provided, it is taken as the total contact duration in seconds.
        If an array is provided, it is assumed to be time points where the solution
        will be evaluated. If None, it defaults to the contact time from the medium.
    autotime : bool, optional
        If True (default), an automatic time discretization is generated internally
        (linear or sqrt-based) between 0 and tmax (the maximum time). If False, the
        times in ``t`` are used directly.
    timescale : {&#34;sqrt&#34;, &#34;linear&#34;}, optional
        Type of automatic time discretization if ``autotime=True``.
        &#34;sqrt&#34; (default) refines the early times more (useful for capturing rapid changes).
        &#34;linear&#34; uses a regular spacing.
    Cxprevious : Cprofile, optional (default=None)
        Concentration profile (from a previous simulation).
    ntimes : int, optional
        Number of time points in the automatically generated time vector if ``autotime=True``.
        The default is 1e3.
    RelTol : float, optional
        Relative tolerance for the ODE solver (``solve_ivp``). Default is 1e-4.
    AbsTol : float, optional
        Absolute tolerance for the ODE solver (``solve_ivp``). Default is 1e-4.

    Raises
    ------
    TypeError
        If ``multilayer`` is not a ``layer`` instance or ``medium`` is not a ``foodlayer`` instance,
        or if ``timescale`` is not a string.
    ValueError
        If an invalid ``timescale`` is given (not one of {&#34;sqrt&#34;, &#34;linear&#34;}).

    Returns
    -------
    SensPatankarResult
        An object containing the time vector, concentration histories, fluxes, and
        spatial concentration profiles suitable for plotting and analysis.

    Notes
    -----
    - The geometry is assumed 1D: Food is on the left boundary, with a mass transfer coefficient
      `h = medium.h`, partition ratio `k0 = medium.k0`, and the packaging layers are to the right
      up to an impervious boundary.
    - Results are normalized internally using a reference layer (``iref``) specified in ``multilayer``.
      The reference layer is used to define dimensionless time (Fourier number Fo).
    - The dimensionless solution is solved by the Patankar approach with partition coefficients.

    Example
    -------
    .. code-block:: python

        from patankar.food import ethanol
        from patankar.layer import layer
        medium = ethanol()
        A = layer(layername=&#34;layer A&#34;)
        B = layer(layername=&#34;layer B&#34;)
        multilayer = A + B

        sol = senspatankar(multilayer, medium, autotime=True, timescale=&#34;sqrt&#34;)
        sol.plotCF()
        sol.plotC()
    &#34;&#34;&#34;

    # Check arguments
    if not isinstance(multilayer, layer):
        raise TypeError(f&#34;the input multilayer must be of class layer, not {type(multilayer).__name__}&#34;)
    if not isinstance(medium, (foodlayer,foodphysics)):
        raise TypeError(f&#34;the input medium must be of class foodlayer, not {type(medium).__name__}&#34;)
    if not isinstance(timescale, str):
        raise TypeError(f&#34;timescale must be a string, not {type(timescale).__name__}&#34;)

    # Refresh the physics of medium for parameters tunned by the end-user
    medium.refresh()

    # extract the PBC flag (True for setoff)
    PBC = medium.PBC

    # Restart file initialization (all parameters are saved)
    restart = restartfile_senspantakar(multilayer, medium, name,
            description, t, autotime, timescale, Cxprevious, ntimes, RelTol, AbsTol)

    # Contact medium properties
    CF0 = medium.get_param(&#34;CF0&#34;,0) # instead of medium.CF0 to get a fallback mechanism with nofood and setoff
    k0 = medium.get_param(&#34;k0&#34;,1)
    h = medium.get_param(&#34;h&#34;,0,acceptNone=False) # None will arise for PBC
    ttarget = medium.get_param(&#34;contacttime&#34;) # &lt;-- ttarget is the time requested
    tmax = 2 * ttarget  # ensures at least up to 2*contacttime

    # Material properties
    k = multilayer.k / k0   # all k are normalized
    k0 = k0 / k0            # all k are normalized
    D = multilayer.D
    l = multilayer.l
    C0 = multilayer.C0

    # Validate/prepare time array
    if isinstance(t,tuple):
        t = check_units(t)[0]
    t = np.array(tmax if t is None else t, dtype=float) # &lt;-- simulation time (longer than ttarget)
    if np.isscalar(t) or t.size == 1:
        t = np.array([0, t.item()],dtype=float)
    if t[0] != 0:
        t = np.insert(t, 0, 0)  # Ensure time starts at zero
    # Ensure t[-1] is greater than ttarget
    if t[-1] &lt; ttarget.item():  # Convert ttarget to scalar before comparison
        t = np.append(t, [ttarget, 1.05*ttarget, 1.1*ttarget, 1.2*ttarget])  # Extend time array to cover requested time

    # Reference layer for dimensionless transformations
    iref = multilayer.referencelayer
    l_ref = l[iref]
    D_ref = D[iref]

    # Normalize lengths and diffusivities
    l_normalized = l / l_ref
    D_normalized = D / D_ref

    # Dimensionless time (Fourier number)
    timebase = l_ref**2 / D_ref
    Fo = t / timebase

    # Automatic time discretization if requested
    if autotime:
        if timescale.lower() == &#34;linear&#34;:
            Fo_int = np.linspace(np.min(Fo), np.max(Fo), int(ntimes))
        elif timescale.lower() == &#34;sqrt&#34;:
            Fo_int = np.linspace(np.sqrt(np.min(Fo)), np.sqrt(np.max(Fo)), int(ntimes))**2
        else:
            raise ValueError(&#39;timescale can be &#34;sqrt&#34; or &#34;linear&#34;&#39;)
        t = Fo_int * timebase
    else:
        Fo_int = Fo

    # L: dimensionless ratio of packaging to food volumes (scaled by reference layer thickness)
    A = medium.get_param(&#34;surfacearea&#34;,0)
    l_sum = multilayer.thickness
    VP = A * l_sum
    VF = medium.get_param(&#34;volume&#34;,1)
    LPF = VP / VF
    L = LPF * l_ref / l_sum

    # Bi: dimensionless mass transfer coefficient
    Bi = h * l_ref / D_ref

    # Compute equilibrium concentration factor
    sum_lL_C0 = np.sum(l_normalized * L * C0)
    sum_terms = np.sum((1 / k) * l_normalized * L)
    C0eq = (CF0 + sum_lL_C0) / (1 + sum_terms)
    if C0eq == 0:
        C0eq = 1.0

    # Normalize initial concentrations
    C0_normalized = C0 / C0eq
    CF0_normalized = CF0 / C0eq

    # Generate mesh (add offset x0 and concatenate them)
    meshes = multilayer.mesh()
    x0 = 0
    for i,mesh in enumerate((meshes)):
        mesh.xmesh += x0
        x0 += mesh.l
    xmesh = np.concatenate([m.xmesh for m in meshes])
    total_nodes = len(xmesh)

    # Positions of the interfaces (East and West)
    dw = np.concatenate([m.dw for m in meshes])
    de = np.concatenate([m.de for m in meshes])

    # Attach properties to nodes (flat interpolant)
    D_mesh = np.concatenate([D_normalized[m.index] for m in meshes])
    k_mesh = np.concatenate([k[m.index] for m in meshes])
    C0_mesh = np.concatenate([C0_normalized[m.index] for m in meshes])

    # Interpolate the initial solution if Cxprevious is supplied
    if Cxprevious is not None:
        if not isinstance(Cxprevious,Cprofile):
            raise TypeError(f&#34;Cxprevisous should be a Cprofile object not a {type(Cxprevious).__name__}&#34;)
        C0_mesh = Cxprevious.interp(xmesh*l_ref) / C0eq # dimensionless

    # Conductances between the node and the next interface
    # item() is forced to avoid the (1,) Shape Issue (since NumPy 1.25)
    hw = np.zeros(total_nodes)
    he = np.zeros(total_nodes)
    if PBC:
        for i in range(total_nodes):
            prev = total_nodes-1 if i==0 else i-1
            hw[i] = (1 / ((de[prev] / D_mesh[prev] * k_mesh[prev] / k_mesh[i]) + dw[i] / D_mesh[i])).item()
    else:
        hw[0] = (1 / ((1 / k_mesh[0]) / Bi + dw[0] / D_mesh[0])).item()
        for i in range(1, total_nodes):
            hw[i] = (1 / ((de[i - 1] / D_mesh[i - 1] * k_mesh[i - 1] / k_mesh[i]) + dw[i] / D_mesh[i])).item()
    he[:-1] = hw[1:] # nodes are the center of FV elements: he = np.roll(hw, -1)
    he[-1]=hw[0] if PBC else 0.0 # we connect (PBC) or we enforce impervious (note that he was initialized to 0 already)

    if PBC: # periodic boundary condition

        # Assemble sparse matrix using COO format for efficient construction
        rows = np.zeros(3 * total_nodes, dtype=int) # row indices
        cols = np.zeros_like(rows) # col indices
        data = np.zeros_like(rows, dtype=np.float64) # values
        idx = 0
        for i in range(total_nodes):
            current = i
            west = (i-1) % total_nodes
            east = (i+1) % total_nodes
            denominator = dw[current] + de[current]
            k_current = k_mesh[current]
            k_west = k_mesh[west]
            k_east = k_mesh[east]
            # West neighbor
            rows[idx] = current
            cols[idx] = west
            data[idx] = hw[current] * k_west / k_current / denominator
            idx +=1
            # Diagonal
            rows[idx] = current
            cols[idx] = current
            data[idx] = (-hw[current] - he[current] * k_current/k_east) / denominator
            idx +=1
            # East neighbor
            rows[idx] = current
            cols[idx] = east
            data[idx] = he[current] / denominator
            idx +=1
        A = coo_matrix((data[:idx], (rows[:idx], cols[:idx])),
                     shape=(total_nodes, total_nodes)).tocsr()
        C_initial =  C0_mesh

    else: # Robin (left) + impervious (right) --&gt; triband matrix

        # Assemble the tri-band matrix A as sparse for efficiency
        size = total_nodes + 1  # +1 for the food node
        main_diag = np.zeros(size)
        upper_diag = np.zeros(size - 1)
        lower_diag = np.zeros(size - 1)
        # Food node (index 0)
        main_diag[0] = (-L * hw[0] * (1 / k_mesh[0])).item()
        upper_diag[0] = (L * hw[0]).item()
        # Layer nodes
        for i in range(total_nodes):
            denom = dw[i] + de[i]
            if i == 0:
                main_diag[1] = (-hw[0] - he[0] * k_mesh[0] / k_mesh[1]) / denom
                upper_diag[1] = he[0] / denom
                lower_diag[0] = (hw[0] * (1 / k_mesh[0])) / denom
            elif i == total_nodes - 1:
                main_diag[i + 1] = (-hw[i]) / denom
                lower_diag[i] = (hw[i] * k_mesh[i - 1] / k_mesh[i]) / denom
            else:
                main_diag[i + 1] = (-hw[i] - he[i] * k_mesh[i] / k_mesh[i + 1]) / denom
                upper_diag[i + 1] = he[i] / denom
                lower_diag[i] = (hw[i] * k_mesh[i - 1] / k_mesh[i]) / denom
        A = diags([main_diag, upper_diag, lower_diag], [0, 1, -1], shape=(size, size), format=&#39;csr&#39;)
        C_initial = np.concatenate([CF0_normalized, C0_mesh])

    # ODE system: dC/dFo = A * C
    def odesys(_, C):
        return A.dot(C)

    sol = solve_ivp(   # &lt;-- generic solver
        odesys,        # &lt;-- our system (efficient sparse matrices)
        [Fo_int[0], Fo_int[-1]], # &lt;-- integration range on Fourier scale
        C_initial,     # &lt;-- initial solution
        t_eval=Fo_int, # &lt;-- the solution is retrieved at these Fo values
        method=&#39;BDF&#39;,  # &lt;-- backward differences are absolutely stable
        rtol=RelTol,   # &lt;-- relative and absolute tolerances
        atol=AbsTol
    )

    # Check solution
    if not sol.success:
        print(&#34;Solver failed:&#34;, sol.message)

    # Extract solution
    if PBC:
        CF_dimless = np.full((sol.y.shape[1],), CF0 / C0eq)
        C_dimless = sol.y
        f = np.zeros_like(CF_dimless)
    else:
        CF_dimless = sol.y[0, :]
        C_dimless = sol.y[1:, :]
        # Robin flux
        f = hw[0] * (k0 * CF_dimless - C_dimless[0, :]) * C0eq

    # Compute cumulative flux
    fc = cumulative_trapezoid(f, t, initial=0)

    if PBC:
        # Build full (dimensionless) profile for plotting across each sub-node
        xfull, Cfull_dimless = compute_fc_profile_PBC(C_dimless, Fo_int, de, dw, he, hw, k_mesh, D_mesh, xmesh, xreltol=0)
        # Build full (dimensionless) profile for interpolation across each sub-node
        xfulli, Cfull_dimlessi = compute_fc_profile_PBC(C_dimless, Fo_int, de, dw, he, hw, k_mesh, D_mesh, xmesh, xreltol=1e-4)
    else:
        # Build full (dimensionless) profile for plotting across each sub-node
        xfull, Cfull_dimless = compute_fv_profile(xmesh, dw, de,C_dimless, k_mesh, D_mesh, hw, he, CF_dimless, k0, Fo_int, xreltol=0)
        # Build full (dimensionless) profile for interpolation across each sub-node
        xfulli, Cfull_dimlessi = compute_fv_profile(xmesh, dw, de,C_dimless, k_mesh, D_mesh, hw, he, CF_dimless, k0, Fo_int, xreltol=1e-4)


    # revert to dimensional concentrations
    CF = CF_dimless * C0eq
    Cx = Cfull_dimless * C0eq

    return SensPatankarResult(
        name=name,
        description=description,
        ttarget = ttarget,             # target time
        t=t,     # time where concentrations are calculated
        C= np.trapz(Cfull_dimless, xfull, axis=1)*C0eq,
        CF=CF,
        fc=fc,
        f=f,
        x=xfull * l_ref,           # revert to dimensional lengths
        Cx=Cx,
        tC=sol.t,
        C0eq=C0eq,
        timebase=timebase,
        restart=restart, # &lt;--- restart info (inputs only)
        xi=xfulli*l_ref, # for restart only
        Cxi=Cfull_dimlessi*C0eq # for restart only
    )</code></pre>
</details>
</dd>
<dt id="migration.tooclear"><code class="name flex">
<span>def <span class="ident">tooclear</span></span>(<span>color, threshold=0.6, correction=0.15)</span>
</code></dt>
<dd>
<div class="desc"><p>Darkens a too-bright RGB(A) color tuple.</p>
<h2 id="parameters">Parameters:</h2>
<p>color : tuple (3 or 4 elements)
RGB or RGBA color in [0,1] range.
threshold : float, optional (default=0.6)
Grayscale threshold above which colors are considered too bright.
correction : float, optional (default=0.15)
Amount by which to darken too bright colors.</p>
<h2 id="returns">Returns:</h2>
<p>tuple
Adjusted RGB(A) color tuple with too bright colors darkened.</p>
<h2 id="example">Example:</h2>
<p>corrected_color = tooclear((0.9, 0.9, 0.7, 1.0))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tooclear(color, threshold=0.6, correction=0.15):
    &#34;&#34;&#34;
    Darkens a too-bright RGB(A) color tuple.

    Parameters:
    -----------
    color : tuple (3 or 4 elements)
        RGB or RGBA color in [0,1] range.
    threshold : float, optional (default=0.6)
        Grayscale threshold above which colors are considered too bright.
    correction : float, optional (default=0.15)
        Amount by which to darken too bright colors.

    Returns:
    --------
    tuple
        Adjusted RGB(A) color tuple with too bright colors darkened.

    Example:
    --------
    corrected_color = tooclear((0.9, 0.9, 0.7, 1.0))
    &#34;&#34;&#34;
    if not isinstance(color, tuple) or len(color) not in [3, 4]:
        raise ValueError(&#34;Input must be an RGB or RGBA tuple.&#34;)
    rgb = color[:3]  # Extract RGB values
    # Compute grayscale brightness (mean of RGB channels)
    brightness = sum(rgb) / 3
    # Darken if brightness exceeds the threshold
    if brightness &gt; threshold:
        rgb = tuple(max(0, c - correction) for c in rgb)
    return rgb + (color[3],) if len(color) == 4 else rgb  # Preserve alpha if present</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="migration.CFSimulationContainer"><code class="flex name class">
<span>class <span class="ident">CFSimulationContainer</span></span>
<span>(</span><span>name='', description='')</span>
</code></dt>
<dd>
<div class="desc"><p>Container to store and compare multiple CF results from different simulations.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>curves</code></strong> :&ensp;<code>dict</code></dt>
<dd>Stores CF results with unique keys. Each entry contains:
- 'label': Label used for legend.
- 'tmin', 'tmax': Time range of the simulation.
- 'interpolant': Interpolated CF function.
- 'color': Assigned color for plotting.
- 'linestyle': Line style (default is '-').
- 'linewidth': Line width (default is 2).</dd>
</dl>
<p>Initialize an empty container for CF results.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CFSimulationContainer:
    &#34;&#34;&#34;
    Container to store and compare multiple CF results from different simulations.

    Attributes
    ----------
    curves : dict
        Stores CF results with unique keys. Each entry contains:
        - &#39;label&#39;: Label used for legend.
        - &#39;tmin&#39;, &#39;tmax&#39;: Time range of the simulation.
        - &#39;interpolant&#39;: Interpolated CF function.
        - &#39;color&#39;: Assigned color for plotting.
        - &#39;linestyle&#39;: Line style (default is &#39;-&#39;).
        - &#39;linewidth&#39;: Line width (default is 2).
    &#34;&#34;&#34;

    def __init__(self,name=&#34;&#34;,description=&#34;&#34;):
        &#34;&#34;&#34;Initialize an empty container for CF results.&#34;&#34;&#34;
        self.curves = {}
        self._name = name
        self._description = description
        self._plotconfig = plotconfig

    @property
    def name(self):
        return self._name or autoname(6)

    @property
    def description(self):
        return self._description or f&#34;comparison of {len(self.curves)} curves&#34;


    def add(self, simulation_result, label=None, color=None, linestyle=&#34;-&#34;, linewidth=2):
        &#34;&#34;&#34;
        Add a new CF result to the container.

        Parameters
        ----------
        simulation_result : SensPatankarResult
            The simulation result to store.
        label : str, optional
            Label for the curve (used in legend). Defaults to &#39;plot1&#39;, &#39;plot2&#39;, etc.
        color : str or tuple, optional
            Color for the curve. Defaults to automatic colormap.
        linestyle : str, optional
            Line style for the plot (e.g., &#39;-&#39;, &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;). Default is &#39;-&#39;.
        linewidth : float, optional
            Line width for the plot. Default is 2.
        &#34;&#34;&#34;

        # Check input
        if not isinstance(simulation_result,SensPatankarResult):
            raise TypeError(f&#34;simulation_result should be a SensPatankarResult object not a {type(simulation_result).__name__}&#34;)

        # Auto-generate a label if not provided
        label = label or self.name
        label = label or f&#34;plot{len(self.curves) + 1}&#34;

        # Generate a unique key (first 40 letters of label)
        key = label[:40] # 40 max

        # Create the interpolant function
        interpolant = interp1d(simulation_result.t, simulation_result.CF,
                               kind=&#34;linear&#34;, fill_value=&#34;extrapolate&#34;, bounds_error=False)

        # Assign color from a colormap if not provided
        if color is None:
            cmap = cm.get_cmap(&#34;tab10&#34;, len(self.curves) + 1)
            color = cmap(len(self.curves) % 10)  # Cycle through colors

        # Store the result in the dictionary (replacing existing key if necessary)
        self.curves[key] = {
            &#34;label&#34;: label,
             &#34;name&#34;: simulation_result.name,
      &#34;description&#34;: simulation_result.description,
             &#34;tmin&#34;: simulation_result.t.min(),
             &#34;tmax&#34;: simulation_result.t.max(),
      &#34;interpolant&#34;: interpolant,
            &#34;color&#34;: color,
        &#34;linestyle&#34;: linestyle,
        &#34;linewidth&#34;: linewidth
        }

    def delete(self, label):
        &#34;&#34;&#34;
        Remove a stored curve by its label.

        Parameters
        ----------
        label : str
            Label of the curve to delete.
        &#34;&#34;&#34;
        key = label[:10]
        if key in self.curves:
            del self.curves[key]
            print(f&#34;Deleted curve &#39;{label}&#39;&#34;)
        else:
            print(f&#34;No curve found with label &#39;{label}&#39;&#34;)

    def __repr__(self):
        &#34;&#34;&#34;Return a summary of stored CF curves.&#34;&#34;&#34;
        if not self.curves:
            return &#34;&lt;CFSimulationContainer: No stored curves&gt;&#34;

        repr_str = &#34;&lt;CFSimulationContainer: Stored CF Curves&gt;\n&#34;
        repr_str += &#34;--------------------------------------------------\n&#34;
        for key, data in self.curves.items():
            repr_str += (f&#34;[{data[&#39;label&#39;]}] &#34;
                         f&#34;Name: {data[&#39;name&#39;]} | &#34;
                         f&#34;Descr: {data[&#39;description&#39;]} | &#34;
                         f&#34;Time: [{data[&#39;tmin&#39;]:.2e}, {data[&#39;tmax&#39;]:.2e}] s | &#34;
                         f&#34;Color: {data[&#39;color&#39;]} | &#34;
                         f&#34;Style: {data[&#39;linestyle&#39;]} | &#34;
                         f&#34;Width: {data[&#39;linewidth&#39;]}\n&#34;)
        return repr_str


    def plotCF(self, t_range=None):
        &#34;&#34;&#34;
        Plot all stored CF curves in a single figure.

        Parameters
        ----------
        t_range : tuple (t_min, t_max), optional
            Time range for plotting. If None, uses each curve&#39;s own range.
        plotconfig : dict, optional
            Dictionary with plotting configuration, containing:
            - &#34;tunit&#34;: Time unit label (e.g., &#39;s&#39;).
            - &#34;Cunit&#34;: Concentration unit label (e.g., &#39;mg/L&#39;).
            - &#34;tscale&#34;: Time scaling factor.
            - &#34;Cscale&#34;: Concentration scaling factor.
        &#34;&#34;&#34;

        # extract plotconfig
        plotconfig = self._plotconfig

        if not self.curves:
            print(&#34;No curves to plot.&#34;)
            return

        fig, ax = plt.subplots(figsize=(8, 6))

        for data in self.curves.values():
            # Determine the time range
            t_min, t_max = data[&#34;tmin&#34;], data[&#34;tmax&#34;]
            if t_range:
                t_min, t_max = max(t_min, t_range[0]), min(t_max, t_range[1])

            # Generate interpolated values
            t_plot = np.linspace(t_min, t_max, 500)
            CF_plot = data[&#34;interpolant&#34;](t_plot)

            # Apply unit scaling if plotconfig is provided
            if plotconfig:
                t_plot /= plotconfig.get(&#34;tscale&#34;, 1)
                CF_plot /= plotconfig.get(&#34;Cscale&#34;, 1)

            # Plot the curve
            ax.plot(t_plot, CF_plot, label=data[&#34;label&#34;],
                    color=data[&#34;color&#34;], linestyle=data[&#34;linestyle&#34;], linewidth=data[&#34;linewidth&#34;])

        # Configure the plot
        ax.set_xlabel(f&#39;Time [{plotconfig[&#34;tunit&#34;]}]&#39; if plotconfig else &#34;Time&#34;)
        ax.set_ylabel(f&#39;Concentration in Food [{plotconfig[&#34;Cunit&#34;]}]&#39; if plotconfig else &#34;CF&#34;)
        title_main = &#34;Concentration in Food vs. Time&#34;
        title_sub = rf&#34;$\bf{{{self.name}}}$&#34; + (f&#34;: {self.description}&#34; if self.description else &#34;&#34;)
        ax.set_title(f&#34;{title_main}\n{title_sub}&#34;, fontsize=10)
        ax.text(0.5, 1.05, title_sub, fontsize=8, ha=&#34;center&#34;, va=&#34;bottom&#34;, transform=ax.transAxes)
        ax.set_title(title_main)
        ax.legend()
        ax.grid(True)
        plt.show()
        # store metadata
        setattr(fig,_fig_metadata_atrr_,f&#34;cmp_pltCF_{self.name}&#34;)
        return fig


    def to_dataframe(self, t_range=None, num_points=1000, time_list=None):
        &#34;&#34;&#34;
        Export interpolated CF data as a pandas DataFrame.
        Parameters:
        - t_range: tuple (t_min, t_max), optional
            The time range for interpolation (default: min &amp; max of all stored results).
        - num_points: int, optional
            Number of points in the interpolated time grid (default: 100).
        - time_list: list or array, optional
            Explicit list of time points for interpolation (overrides t_range &amp; num_points).
        Returns:
        - pd.DataFrame
            A DataFrame with time as index and CF values as columns (one per simulation).
        &#34;&#34;&#34;
        if not self.curves:
            print(&#34;No data to export.&#34;)
            return pd.DataFrame()

        # Determine the time grid
        if time_list is not None:
            t_grid = np.array(time_list)
        else:
            all_t_min = min(data[&#34;tmin&#34;] for data in self.curves.values())
            all_t_max = max(data[&#34;tmax&#34;] for data in self.curves.values())
            # Default time range
            t_min, t_max = t_range if t_range else (all_t_min, all_t_max)
            # Create evenly spaced time grid
            t_grid = np.linspace(t_min, t_max, num_points)
        # Create DataFrame with time as index
        df = pd.DataFrame({&#34;Time (s)&#34;: t_grid})

        # Interpolate each stored CF curve at the common time grid
        for key, data in self.curves.items():
            df[data[&#34;label&#34;]] = data[&#34;interpolant&#34;](t_grid)
        return df


    def save_as_excel(self, filename=&#34;CF_data.xlsx&#34;, destinationfolder=os.getcwd(), overwrite=False,
                      t_range=None, num_points=1000, time_list=None):
        &#34;&#34;&#34;
        Save stored CF data to an Excel file.
        Parameters:
        - filename: str, Excel filename.
        - destinationfolder: str, where to save the file.
        - overwrite: bool, overwrite existing file.
        - t_range: tuple (t_min, t_max), optional
            The time range for interpolation (default: min &amp; max of all stored results).
        - num_points: int, optional
            Number of points in the interpolated time grid (default: 100).
        - time_list: list or array, optional
            Explicit list of time points for interpolation (overrides t_range &amp; num_points).
        &#34;&#34;&#34;
        if not self.curves:
            print(&#34;No data to export.&#34;)
            return
        df = self.to_dataframe(t_range=t_range, num_points=num_points, time_list=time_list)
        filepath = os.path.join(destinationfolder, filename)
        if not overwrite and os.path.exists(filepath):
            print(f&#34;File {filepath} already exists. Use overwrite=True to replace it.&#34;)
            return

        df.to_excel(filepath, index=False)
        print(f&#34;Saved Excel file: {filepath}&#34;)


    def save_as_csv(self, filename=&#34;CF_data.csv&#34;, destinationfolder=os.getcwd(), overwrite=False,
                    t_range=None, num_points=200, time_list=None):
        &#34;&#34;&#34;
        Save stored CF data to an Excel file.
        Parameters:
        - filename: str, Excel filename.
        - destinationfolder: str, where to save the file.
        - overwrite: bool, overwrite existing file.
        - t_range: tuple (t_min, t_max), optional
            The time range for interpolation (default: min &amp; max of all stored results).
        - num_points: int, optional
            Number of points in the interpolated time grid (default: 100).
        - time_list: list or array, optional
            Explicit list of time points for interpolation (overrides t_range &amp; num_points).
        &#34;&#34;&#34;
        if not self.curves:
            print(&#34;No data to export.&#34;)
            return
        df = self.to_dataframe(t_range=t_range, num_points=num_points, time_list=time_list)
        filepath = os.path.join(destinationfolder, filename)
        if not overwrite and os.path.exists(filepath):
            print(f&#34;File {filepath} already exists. Use overwrite=True to replace it.&#34;)
            return
        df.to_csv(filepath, index=False)
        print(f&#34;Saved CSV file: {filepath}&#34;)


    def rgb(self):
        &#34;&#34;&#34;Displays a categorized color chart with properly aligned headers.&#34;&#34;&#34;
        rgb()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="migration.CFSimulationContainer.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self):
    return self._description or f&#34;comparison of {len(self.curves)} curves&#34;</code></pre>
</details>
</dd>
<dt id="migration.CFSimulationContainer.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    return self._name or autoname(6)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="migration.CFSimulationContainer.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, simulation_result, label=None, color=None, linestyle='-', linewidth=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new CF result to the container.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>simulation_result</code></strong> :&ensp;<code><a title="migration.SensPatankarResult" href="#migration.SensPatankarResult">SensPatankarResult</a></code></dt>
<dd>The simulation result to store.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Label for the curve (used in legend). Defaults to 'plot1', 'plot2', etc.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code> or <code>tuple</code>, optional</dt>
<dd>Color for the curve. Defaults to automatic colormap.</dd>
<dt><strong><code>linestyle</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Line style for the plot (e.g., '-', '&ndash;', '-.', ':'). Default is '-'.</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Line width for the plot. Default is 2.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, simulation_result, label=None, color=None, linestyle=&#34;-&#34;, linewidth=2):
    &#34;&#34;&#34;
    Add a new CF result to the container.

    Parameters
    ----------
    simulation_result : SensPatankarResult
        The simulation result to store.
    label : str, optional
        Label for the curve (used in legend). Defaults to &#39;plot1&#39;, &#39;plot2&#39;, etc.
    color : str or tuple, optional
        Color for the curve. Defaults to automatic colormap.
    linestyle : str, optional
        Line style for the plot (e.g., &#39;-&#39;, &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;). Default is &#39;-&#39;.
    linewidth : float, optional
        Line width for the plot. Default is 2.
    &#34;&#34;&#34;

    # Check input
    if not isinstance(simulation_result,SensPatankarResult):
        raise TypeError(f&#34;simulation_result should be a SensPatankarResult object not a {type(simulation_result).__name__}&#34;)

    # Auto-generate a label if not provided
    label = label or self.name
    label = label or f&#34;plot{len(self.curves) + 1}&#34;

    # Generate a unique key (first 40 letters of label)
    key = label[:40] # 40 max

    # Create the interpolant function
    interpolant = interp1d(simulation_result.t, simulation_result.CF,
                           kind=&#34;linear&#34;, fill_value=&#34;extrapolate&#34;, bounds_error=False)

    # Assign color from a colormap if not provided
    if color is None:
        cmap = cm.get_cmap(&#34;tab10&#34;, len(self.curves) + 1)
        color = cmap(len(self.curves) % 10)  # Cycle through colors

    # Store the result in the dictionary (replacing existing key if necessary)
    self.curves[key] = {
        &#34;label&#34;: label,
         &#34;name&#34;: simulation_result.name,
  &#34;description&#34;: simulation_result.description,
         &#34;tmin&#34;: simulation_result.t.min(),
         &#34;tmax&#34;: simulation_result.t.max(),
  &#34;interpolant&#34;: interpolant,
        &#34;color&#34;: color,
    &#34;linestyle&#34;: linestyle,
    &#34;linewidth&#34;: linewidth
    }</code></pre>
</details>
</dd>
<dt id="migration.CFSimulationContainer.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a stored curve by its label.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>Label of the curve to delete.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, label):
    &#34;&#34;&#34;
    Remove a stored curve by its label.

    Parameters
    ----------
    label : str
        Label of the curve to delete.
    &#34;&#34;&#34;
    key = label[:10]
    if key in self.curves:
        del self.curves[key]
        print(f&#34;Deleted curve &#39;{label}&#39;&#34;)
    else:
        print(f&#34;No curve found with label &#39;{label}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="migration.CFSimulationContainer.plotCF"><code class="name flex">
<span>def <span class="ident">plotCF</span></span>(<span>self, t_range=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot all stored CF curves in a single figure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t_range</code></strong> :&ensp;<code>tuple (t_min, t_max)</code>, optional</dt>
<dd>Time range for plotting. If None, uses each curve's own range.</dd>
<dt><strong><code>plotconfig</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Dictionary with plotting configuration, containing:
- "tunit": Time unit label (e.g., 's').
- "Cunit": Concentration unit label (e.g., 'mg/L').
- "tscale": Time scaling factor.
- "Cscale": Concentration scaling factor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotCF(self, t_range=None):
    &#34;&#34;&#34;
    Plot all stored CF curves in a single figure.

    Parameters
    ----------
    t_range : tuple (t_min, t_max), optional
        Time range for plotting. If None, uses each curve&#39;s own range.
    plotconfig : dict, optional
        Dictionary with plotting configuration, containing:
        - &#34;tunit&#34;: Time unit label (e.g., &#39;s&#39;).
        - &#34;Cunit&#34;: Concentration unit label (e.g., &#39;mg/L&#39;).
        - &#34;tscale&#34;: Time scaling factor.
        - &#34;Cscale&#34;: Concentration scaling factor.
    &#34;&#34;&#34;

    # extract plotconfig
    plotconfig = self._plotconfig

    if not self.curves:
        print(&#34;No curves to plot.&#34;)
        return

    fig, ax = plt.subplots(figsize=(8, 6))

    for data in self.curves.values():
        # Determine the time range
        t_min, t_max = data[&#34;tmin&#34;], data[&#34;tmax&#34;]
        if t_range:
            t_min, t_max = max(t_min, t_range[0]), min(t_max, t_range[1])

        # Generate interpolated values
        t_plot = np.linspace(t_min, t_max, 500)
        CF_plot = data[&#34;interpolant&#34;](t_plot)

        # Apply unit scaling if plotconfig is provided
        if plotconfig:
            t_plot /= plotconfig.get(&#34;tscale&#34;, 1)
            CF_plot /= plotconfig.get(&#34;Cscale&#34;, 1)

        # Plot the curve
        ax.plot(t_plot, CF_plot, label=data[&#34;label&#34;],
                color=data[&#34;color&#34;], linestyle=data[&#34;linestyle&#34;], linewidth=data[&#34;linewidth&#34;])

    # Configure the plot
    ax.set_xlabel(f&#39;Time [{plotconfig[&#34;tunit&#34;]}]&#39; if plotconfig else &#34;Time&#34;)
    ax.set_ylabel(f&#39;Concentration in Food [{plotconfig[&#34;Cunit&#34;]}]&#39; if plotconfig else &#34;CF&#34;)
    title_main = &#34;Concentration in Food vs. Time&#34;
    title_sub = rf&#34;$\bf{{{self.name}}}$&#34; + (f&#34;: {self.description}&#34; if self.description else &#34;&#34;)
    ax.set_title(f&#34;{title_main}\n{title_sub}&#34;, fontsize=10)
    ax.text(0.5, 1.05, title_sub, fontsize=8, ha=&#34;center&#34;, va=&#34;bottom&#34;, transform=ax.transAxes)
    ax.set_title(title_main)
    ax.legend()
    ax.grid(True)
    plt.show()
    # store metadata
    setattr(fig,_fig_metadata_atrr_,f&#34;cmp_pltCF_{self.name}&#34;)
    return fig</code></pre>
</details>
</dd>
<dt id="migration.CFSimulationContainer.rgb"><code class="name flex">
<span>def <span class="ident">rgb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a categorized color chart with properly aligned headers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rgb(self):
    &#34;&#34;&#34;Displays a categorized color chart with properly aligned headers.&#34;&#34;&#34;
    rgb()</code></pre>
</details>
</dd>
<dt id="migration.CFSimulationContainer.save_as_csv"><code class="name flex">
<span>def <span class="ident">save_as_csv</span></span>(<span>self, filename='CF_data.csv', destinationfolder='/home/olivi/natacha/python/utils', overwrite=False, t_range=None, num_points=200, time_list=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save stored CF data to an Excel file.
Parameters:
- filename: str, Excel filename.
- destinationfolder: str, where to save the file.
- overwrite: bool, overwrite existing file.
- t_range: tuple (t_min, t_max), optional
The time range for interpolation (default: min &amp; max of all stored results).
- num_points: int, optional
Number of points in the interpolated time grid (default: 100).
- time_list: list or array, optional
Explicit list of time points for interpolation (overrides t_range &amp; num_points).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_as_csv(self, filename=&#34;CF_data.csv&#34;, destinationfolder=os.getcwd(), overwrite=False,
                t_range=None, num_points=200, time_list=None):
    &#34;&#34;&#34;
    Save stored CF data to an Excel file.
    Parameters:
    - filename: str, Excel filename.
    - destinationfolder: str, where to save the file.
    - overwrite: bool, overwrite existing file.
    - t_range: tuple (t_min, t_max), optional
        The time range for interpolation (default: min &amp; max of all stored results).
    - num_points: int, optional
        Number of points in the interpolated time grid (default: 100).
    - time_list: list or array, optional
        Explicit list of time points for interpolation (overrides t_range &amp; num_points).
    &#34;&#34;&#34;
    if not self.curves:
        print(&#34;No data to export.&#34;)
        return
    df = self.to_dataframe(t_range=t_range, num_points=num_points, time_list=time_list)
    filepath = os.path.join(destinationfolder, filename)
    if not overwrite and os.path.exists(filepath):
        print(f&#34;File {filepath} already exists. Use overwrite=True to replace it.&#34;)
        return
    df.to_csv(filepath, index=False)
    print(f&#34;Saved CSV file: {filepath}&#34;)</code></pre>
</details>
</dd>
<dt id="migration.CFSimulationContainer.save_as_excel"><code class="name flex">
<span>def <span class="ident">save_as_excel</span></span>(<span>self, filename='CF_data.xlsx', destinationfolder='/home/olivi/natacha/python/utils', overwrite=False, t_range=None, num_points=1000, time_list=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save stored CF data to an Excel file.
Parameters:
- filename: str, Excel filename.
- destinationfolder: str, where to save the file.
- overwrite: bool, overwrite existing file.
- t_range: tuple (t_min, t_max), optional
The time range for interpolation (default: min &amp; max of all stored results).
- num_points: int, optional
Number of points in the interpolated time grid (default: 100).
- time_list: list or array, optional
Explicit list of time points for interpolation (overrides t_range &amp; num_points).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_as_excel(self, filename=&#34;CF_data.xlsx&#34;, destinationfolder=os.getcwd(), overwrite=False,
                  t_range=None, num_points=1000, time_list=None):
    &#34;&#34;&#34;
    Save stored CF data to an Excel file.
    Parameters:
    - filename: str, Excel filename.
    - destinationfolder: str, where to save the file.
    - overwrite: bool, overwrite existing file.
    - t_range: tuple (t_min, t_max), optional
        The time range for interpolation (default: min &amp; max of all stored results).
    - num_points: int, optional
        Number of points in the interpolated time grid (default: 100).
    - time_list: list or array, optional
        Explicit list of time points for interpolation (overrides t_range &amp; num_points).
    &#34;&#34;&#34;
    if not self.curves:
        print(&#34;No data to export.&#34;)
        return
    df = self.to_dataframe(t_range=t_range, num_points=num_points, time_list=time_list)
    filepath = os.path.join(destinationfolder, filename)
    if not overwrite and os.path.exists(filepath):
        print(f&#34;File {filepath} already exists. Use overwrite=True to replace it.&#34;)
        return

    df.to_excel(filepath, index=False)
    print(f&#34;Saved Excel file: {filepath}&#34;)</code></pre>
</details>
</dd>
<dt id="migration.CFSimulationContainer.to_dataframe"><code class="name flex">
<span>def <span class="ident">to_dataframe</span></span>(<span>self, t_range=None, num_points=1000, time_list=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Export interpolated CF data as a pandas DataFrame.
Parameters:
- t_range: tuple (t_min, t_max), optional
The time range for interpolation (default: min &amp; max of all stored results).
- num_points: int, optional
Number of points in the interpolated time grid (default: 100).
- time_list: list or array, optional
Explicit list of time points for interpolation (overrides t_range &amp; num_points).
Returns:
- pd.DataFrame
A DataFrame with time as index and CF values as columns (one per simulation).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dataframe(self, t_range=None, num_points=1000, time_list=None):
    &#34;&#34;&#34;
    Export interpolated CF data as a pandas DataFrame.
    Parameters:
    - t_range: tuple (t_min, t_max), optional
        The time range for interpolation (default: min &amp; max of all stored results).
    - num_points: int, optional
        Number of points in the interpolated time grid (default: 100).
    - time_list: list or array, optional
        Explicit list of time points for interpolation (overrides t_range &amp; num_points).
    Returns:
    - pd.DataFrame
        A DataFrame with time as index and CF values as columns (one per simulation).
    &#34;&#34;&#34;
    if not self.curves:
        print(&#34;No data to export.&#34;)
        return pd.DataFrame()

    # Determine the time grid
    if time_list is not None:
        t_grid = np.array(time_list)
    else:
        all_t_min = min(data[&#34;tmin&#34;] for data in self.curves.values())
        all_t_max = max(data[&#34;tmax&#34;] for data in self.curves.values())
        # Default time range
        t_min, t_max = t_range if t_range else (all_t_min, all_t_max)
        # Create evenly spaced time grid
        t_grid = np.linspace(t_min, t_max, num_points)
    # Create DataFrame with time as index
    df = pd.DataFrame({&#34;Time (s)&#34;: t_grid})

    # Interpolate each stored CF curve at the common time grid
    for key, data in self.curves.items():
        df[data[&#34;label&#34;]] = data[&#34;interpolant&#34;](t_grid)
    return df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="migration.Cprofile"><code class="flex name class">
<span>class <span class="ident">Cprofile</span></span>
<span>(</span><span>x=None, Cx=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to store and interpolate a concentration profile (C(x)).</p>
<p>Initialize the concentration profile Cx(x).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cprofile:
    &#34;&#34;&#34;
    Class to store and interpolate a concentration profile (C(x)).
    &#34;&#34;&#34;

    def __init__(self, x=None, Cx=None):
        &#34;&#34;&#34;Initialize the concentration profile Cx(x).&#34;&#34;&#34;
        if x is None or Cx is None:
            raise ValueError(&#34;Syntax: myprofile = Cprofile(x, Cx). Both x and Cx are mandatory.&#34;)
        self.x = np.array(x, dtype=float).reshape(-1)  # Ensure 1D NumPy array
        self.Cx = np.array(Cx, dtype=float).reshape(-1)  # Ensure 1D NumPy array
        # Check if x is strictly increasing
        if np.any(np.diff(self.x) &lt;= 0):
            raise ValueError(&#34;x values must be strictly increasing.&#34;)
        # Create the interpolation function
        self._interp_func = interp1d(
            self.x, self.Cx, kind=&#34;linear&#34;, fill_value=0, bounds_error=False
        )

    def interp(self, x_new):
        &#34;&#34;&#34;
        Interpolate concentration values at new x positions.

        Parameters:
            x_new (array-like): New positions where concentrations are needed.

        Returns:
            np.ndarray: Interpolated concentration values.
        &#34;&#34;&#34;
        x_new = np.array(x_new, dtype=float)  # Ensure NumPy array
        return self._interp_func(x_new)

    def integrate(self):
        &#34;&#34;&#34;
        Compute the integral of Cx over x using Simpson&#39;s rule.

        Returns:
            float: The integral ∫ Cx dx.
        &#34;&#34;&#34;
        return simpson(self.Cx, self.x)

    def mean_concentration(self):
        &#34;&#34;&#34;
        Compute the mean concentration using the integral.

        Returns:
            float: The mean value of Cx.
        &#34;&#34;&#34;
        return self.integrate() / (self.x[-1] - self.x[0])

    def find_indices_xrange(self, x_range):
        &#34;&#34;&#34;
        Find indices where x is within a specified range.

        Parameters:
            x_range (tuple): The (min, max) range of x.

        Returns:
            np.ndarray: Indices where x falls within the range.
        &#34;&#34;&#34;
        xmin, xmax = x_range
        return np.where((self.x &gt;= xmin) &amp; (self.x &lt;= xmax))[0]

    def find_indices_Cxrange(self, Cx_range=(0, np.inf)):
        &#34;&#34;&#34;
        Find indices where Cx is within a specified range.

        Parameters:
            Cx_range (tuple): The (min, max) range of Cx.

        Returns:
            np.ndarray: Indices where Cx falls within the range.
        &#34;&#34;&#34;
        Cmin, Cmax = Cx_range
        return np.where((self.Cx &gt;= Cmin) &amp; (self.Cx &lt;= Cmax))[0]

    def assign_values(self, indices, values):
        &#34;&#34;&#34;
        Assign new values to Cx at specified indices.

        Parameters:
            indices (array-like): Indices where values should be assigned.
            values (float or array-like): New values to assign.

        Raises:
            ValueError: If the number of values does not match the number of indices.
        &#34;&#34;&#34;
        indices = np.array(indices, dtype=int)
        if np.isscalar(values):
            self.Cx[indices] = values  # Assign single value to all indices
        else:
            values = np.array(values, dtype=float)
            if values.shape[0] != indices.shape[0]:
                raise ValueError(&#34;Number of values must match the number of indices.&#34;)
            self.Cx[indices] = values

    def __repr__(self):
        &#34;&#34;&#34;Representation of the profile.&#34;&#34;&#34;
        stats_x = {
            &#34;min&#34;: np.min(self.x),
            &#34;max&#34;: np.max(self.x),
            &#34;mean&#34;: np.mean(self.x),
            &#34;median&#34;: np.median(self.x),
            &#34;std&#34;: np.std(self.x),
        }
        stats_Cx = {
            &#34;min&#34;: np.min(self.Cx),
            &#34;max&#34;: np.max(self.Cx),
            &#34;mean&#34;: np.mean(self.Cx),
            &#34;median&#34;: np.median(self.Cx),
            &#34;std&#34;: np.std(self.Cx),
        }

        print(
            f&#34;Cprofile: {len(self.x)} points\n&#34;,
            f&#34;x range: [{stats_x[&#39;min&#39;]:.4g}, {stats_x[&#39;max&#39;]:.4g}]\n&#34;,
            f&#34;Cx range: [{stats_Cx[&#39;min&#39;]:.4g}, {stats_Cx[&#39;max&#39;]:.4g}]\n&#34;,
            f&#34;x stats: mean={stats_x[&#39;mean&#39;]:.4g}, median={stats_x[&#39;median&#39;]:.4g}, std={stats_x[&#39;std&#39;]:.4g}\n&#34;,
            f&#34;Cx stats: mean={stats_Cx[&#39;mean&#39;]:.4g}, median={stats_Cx[&#39;median&#39;]:.4g}, std={stats_Cx[&#39;std&#39;]:.4g}&#34;
        )
        return str(self)

    def __str__(self):
        &#34;&#34;&#34;Returns a formatted string representation of the profile.&#34;&#34;&#34;
        return f&#34;&lt;{self.__class__.__name__}: including {len(self.x)} points&gt;&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="migration.Cprofile.assign_values"><code class="name flex">
<span>def <span class="ident">assign_values</span></span>(<span>self, indices, values)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign new values to Cx at specified indices.</p>
<h2 id="parameters">Parameters</h2>
<p>indices (array-like): Indices where values should be assigned.
values (float or array-like): New values to assign.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the number of values does not match the number of indices.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_values(self, indices, values):
    &#34;&#34;&#34;
    Assign new values to Cx at specified indices.

    Parameters:
        indices (array-like): Indices where values should be assigned.
        values (float or array-like): New values to assign.

    Raises:
        ValueError: If the number of values does not match the number of indices.
    &#34;&#34;&#34;
    indices = np.array(indices, dtype=int)
    if np.isscalar(values):
        self.Cx[indices] = values  # Assign single value to all indices
    else:
        values = np.array(values, dtype=float)
        if values.shape[0] != indices.shape[0]:
            raise ValueError(&#34;Number of values must match the number of indices.&#34;)
        self.Cx[indices] = values</code></pre>
</details>
</dd>
<dt id="migration.Cprofile.find_indices_Cxrange"><code class="name flex">
<span>def <span class="ident">find_indices_Cxrange</span></span>(<span>self, Cx_range=(0, inf))</span>
</code></dt>
<dd>
<div class="desc"><p>Find indices where Cx is within a specified range.</p>
<h2 id="parameters">Parameters</h2>
<p>Cx_range (tuple): The (min, max) range of Cx.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Indices where Cx falls within the range.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_indices_Cxrange(self, Cx_range=(0, np.inf)):
    &#34;&#34;&#34;
    Find indices where Cx is within a specified range.

    Parameters:
        Cx_range (tuple): The (min, max) range of Cx.

    Returns:
        np.ndarray: Indices where Cx falls within the range.
    &#34;&#34;&#34;
    Cmin, Cmax = Cx_range
    return np.where((self.Cx &gt;= Cmin) &amp; (self.Cx &lt;= Cmax))[0]</code></pre>
</details>
</dd>
<dt id="migration.Cprofile.find_indices_xrange"><code class="name flex">
<span>def <span class="ident">find_indices_xrange</span></span>(<span>self, x_range)</span>
</code></dt>
<dd>
<div class="desc"><p>Find indices where x is within a specified range.</p>
<h2 id="parameters">Parameters</h2>
<p>x_range (tuple): The (min, max) range of x.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Indices where x falls within the range.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_indices_xrange(self, x_range):
    &#34;&#34;&#34;
    Find indices where x is within a specified range.

    Parameters:
        x_range (tuple): The (min, max) range of x.

    Returns:
        np.ndarray: Indices where x falls within the range.
    &#34;&#34;&#34;
    xmin, xmax = x_range
    return np.where((self.x &gt;= xmin) &amp; (self.x &lt;= xmax))[0]</code></pre>
</details>
</dd>
<dt id="migration.Cprofile.integrate"><code class="name flex">
<span>def <span class="ident">integrate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the integral of Cx over x using Simpson's rule.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The integral ∫ Cx dx.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integrate(self):
    &#34;&#34;&#34;
    Compute the integral of Cx over x using Simpson&#39;s rule.

    Returns:
        float: The integral ∫ Cx dx.
    &#34;&#34;&#34;
    return simpson(self.Cx, self.x)</code></pre>
</details>
</dd>
<dt id="migration.Cprofile.interp"><code class="name flex">
<span>def <span class="ident">interp</span></span>(<span>self, x_new)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate concentration values at new x positions.</p>
<h2 id="parameters">Parameters</h2>
<p>x_new (array-like): New positions where concentrations are needed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Interpolated concentration values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interp(self, x_new):
    &#34;&#34;&#34;
    Interpolate concentration values at new x positions.

    Parameters:
        x_new (array-like): New positions where concentrations are needed.

    Returns:
        np.ndarray: Interpolated concentration values.
    &#34;&#34;&#34;
    x_new = np.array(x_new, dtype=float)  # Ensure NumPy array
    return self._interp_func(x_new)</code></pre>
</details>
</dd>
<dt id="migration.Cprofile.mean_concentration"><code class="name flex">
<span>def <span class="ident">mean_concentration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the mean concentration using the integral.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The mean value of Cx.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_concentration(self):
    &#34;&#34;&#34;
    Compute the mean concentration using the integral.

    Returns:
        float: The mean value of Cx.
    &#34;&#34;&#34;
    return self.integrate() / (self.x[-1] - self.x[0])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="migration.PrintableFigure"><code class="flex name class">
<span>class <span class="ident">PrintableFigure</span></span>
<span>(</span><span>figsize=None, dpi=None, *, facecolor=None, edgecolor=None, linewidth=0.0, frameon=None, subplotpars=None, tight_layout=None, constrained_layout=None, layout=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom Figure class with print methods.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figsize</code></strong> :&ensp;<code>2-tuple</code> of <code>floats</code>, default<code>: :rc:</code>figure.figsize``</dt>
<dd>Figure dimension <code>(width, height)</code> in inches.</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>float</code>, default<code>: :rc:</code>figure.dpi``</dt>
<dd>Dots per inch.</dd>
<dt><strong><code>facecolor</code></strong> :&ensp;<code>default: :rc:</code>figure.facecolor``</dt>
<dd>The figure patch facecolor.</dd>
<dt><strong><code>edgecolor</code></strong> :&ensp;<code>default: :rc:</code>figure.edgecolor``</dt>
<dd>The figure patch edge color.</dd>
<dt><strong><code>linewidth</code></strong> :&ensp;<code>float</code></dt>
<dd>The linewidth of the frame (i.e. the edge linewidth of the figure
patch).</dd>
<dt><strong><code>frameon</code></strong> :&ensp;<code>bool</code>, default<code>: :rc:</code>figure.frameon``</dt>
<dd>If <code>False</code>, suppress drawing the figure background patch.</dd>
<dt><strong><code>subplotpars</code></strong> :&ensp;<code>~matplotlib.gridspec.SubplotParams</code></dt>
<dd>Subplot parameters. If not given, the default subplot
parameters :rc:<code>figure.subplot.*</code> are used.</dd>
<dt><strong><code>tight_layout</code></strong> :&ensp;<code>bool</code> or <code>dict</code>, default<code>: :rc:</code>figure.autolayout``</dt>
<dd>
<p>Whether to use the tight layout mechanism. See <code>.set_tight_layout</code>.</p>
<div class="admonition admonition">
<p class="admonition-title">Discouraged</p>
<p>The use of this parameter is discouraged. Please use
<code>layout='tight'</code> instead for the common case of
<code>tight_layout=True</code> and use <code>.set_tight_layout</code> otherwise.</p>
</div>
</dd>
<dt><strong><code>constrained_layout</code></strong> :&ensp;<code>bool</code>, default<code>: :rc:</code>figure.constrained_layout.use``</dt>
<dd>
<p>This is equal to <code>layout='constrained'</code>.</p>
<div class="admonition admonition">
<p class="admonition-title">Discouraged</p>
<p>The use of this parameter is discouraged. Please use
<code>layout='constrained'</code> instead.</p>
</div>
</dd>
<dt><strong><code>layout</code></strong> :&ensp;<code>{'constrained', 'compressed', 'tight', 'none',</code>.LayoutEngine<code>, None}</code>, default<code>: None</code></dt>
<dd>
<p>The layout mechanism for positioning of plot elements to avoid
overlapping Axes decorations (labels, ticks, etc). Note that
layout managers can have significant performance penalties.</p>
<ul>
<li>'constrained': The constrained layout solver adjusts Axes sizes
to avoid overlapping Axes decorations.
Can handle complex plot
layouts and colorbars, and is thus recommended.</li>
</ul>
<p>See :ref:<code>constrainedlayout_guide</code> for examples.</p>
<ul>
<li>
<p>'compressed': uses the same algorithm as 'constrained', but
removes extra space between fixed-aspect-ratio Axes.
Best for
simple grids of Axes.</p>
</li>
<li>
<p>'tight': Use the tight layout mechanism. This is a relatively
simple algorithm that adjusts the subplot parameters so that
decorations do not overlap.</p>
</li>
</ul>
<p>See :ref:<code>tight_layout_guide</code> for examples.</p>
<ul>
<li>
<p>'none': Do not use a layout engine.</p>
</li>
<li>
<p>A <code>.LayoutEngine</code> instance. Builtin layout classes are
<code>.ConstrainedLayoutEngine</code> and <code>.TightLayoutEngine</code>, more easily
accessible by 'constrained' and 'tight'.
Passing an instance
allows third parties to provide their own layout engine.</p>
</li>
</ul>
<p>If not given, fall back to using the parameters <em>tight_layout</em> and
<em>constrained_layout</em>, including their config defaults
:rc:<code>figure.autolayout</code> and :rc:<code>figure.constrained_layout.use</code>.</p>
</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code><code>.Figure&lt;/code&gt; properties</code>, optional</dt>
<dd>Properties:
agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array and two offsets from the bottom left corner of the image
alpha: scalar or None
animated: bool
canvas: FigureCanvas
clip_box: <code>~matplotlib.transforms.BboxBase</code> or None
clip_on: bool
clip_path: Patch or (Path, Transform) or None
constrained_layout: unknown
constrained_layout_pads: unknown
dpi: float
edgecolor: :mpltype:<code>color</code>
facecolor: :mpltype:<code>color</code>
figheight: float
figure: unknown
figwidth: float
frameon: bool
gid: str
in_layout: bool
label: object
layout_engine: {'constrained', 'compressed', 'tight', 'none', <code>.LayoutEngine</code>, None}
linewidth: number
mouseover: bool
path_effects: list of <code>.AbstractPathEffect</code>
picker: None or bool or float or callable
rasterized: bool
size_inches: (float, float) or float
sketch_params: (scale: float, length: float, randomness: float)
snap: bool or None
tight_layout: unknown
transform: <code>~matplotlib.transforms.Transform</code>
url: str
visible: bool
zorder: float</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrintableFigure(Figure):
    &#34;&#34;&#34;Custom Figure class with print methods.&#34;&#34;&#34;

    def print(self, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
        print_figure(self, filename, destinationfolder, overwrite, dpi)

    def print_png(self, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
        print_png(self, filename, destinationfolder, overwrite, dpi)

    def print_pdf(self, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
        print_pdf(self, filename, destinationfolder, overwrite, dpi)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>matplotlib.figure.Figure</li>
<li>matplotlib.figure.FigureBase</li>
<li>matplotlib.artist.Artist</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="migration.PrintableFigure.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, filename='', destinationfolder='/home/olivi/natacha/python/utils', overwrite=False, dpi=300)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
    print_figure(self, filename, destinationfolder, overwrite, dpi)</code></pre>
</details>
</dd>
<dt id="migration.PrintableFigure.print_pdf"><code class="name flex">
<span>def <span class="ident">print_pdf</span></span>(<span>self, filename='', destinationfolder='/home/olivi/natacha/python/utils', overwrite=False, dpi=300)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_pdf(self, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
    print_pdf(self, filename, destinationfolder, overwrite, dpi)</code></pre>
</details>
</dd>
<dt id="migration.PrintableFigure.print_png"><code class="name flex">
<span>def <span class="ident">print_png</span></span>(<span>self, filename='', destinationfolder='/home/olivi/natacha/python/utils', overwrite=False, dpi=300)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_png(self, filename=&#34;&#34;, destinationfolder=os.getcwd(), overwrite=False, dpi=300):
    print_png(self, filename, destinationfolder, overwrite, dpi)</code></pre>
</details>
</dd>
<dt id="migration.PrintableFigure.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, *, agg_filter=&lt;UNSET&gt;, alpha=&lt;UNSET&gt;, animated=&lt;UNSET&gt;, canvas=&lt;UNSET&gt;, clip_box=&lt;UNSET&gt;, clip_on=&lt;UNSET&gt;, clip_path=&lt;UNSET&gt;, constrained_layout=&lt;UNSET&gt;, constrained_layout_pads=&lt;UNSET&gt;, dpi=&lt;UNSET&gt;, edgecolor=&lt;UNSET&gt;, facecolor=&lt;UNSET&gt;, figheight=&lt;UNSET&gt;, figwidth=&lt;UNSET&gt;, frameon=&lt;UNSET&gt;, gid=&lt;UNSET&gt;, in_layout=&lt;UNSET&gt;, label=&lt;UNSET&gt;, layout_engine=&lt;UNSET&gt;, linewidth=&lt;UNSET&gt;, mouseover=&lt;UNSET&gt;, path_effects=&lt;UNSET&gt;, picker=&lt;UNSET&gt;, rasterized=&lt;UNSET&gt;, size_inches=&lt;UNSET&gt;, sketch_params=&lt;UNSET&gt;, snap=&lt;UNSET&gt;, tight_layout=&lt;UNSET&gt;, transform=&lt;UNSET&gt;, url=&lt;UNSET&gt;, visible=&lt;UNSET&gt;, zorder=&lt;UNSET&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Set multiple properties at once.</p>
<p>Supported properties are</p>
<h2 id="properties">Properties</h2>
<p>agg_filter: a filter function, which takes a (m, n, 3) float array and a dpi value, and returns a (m, n, 3) array and two offsets from the bottom left corner of the image
alpha: scalar or None
animated: bool
canvas: FigureCanvas
clip_box: <code>~matplotlib.transforms.BboxBase</code> or None
clip_on: bool
clip_path: Patch or (Path, Transform) or None
constrained_layout: unknown
constrained_layout_pads: unknown
dpi: float
edgecolor: :mpltype:<code>color</code>
facecolor: :mpltype:<code>color</code>
figheight: float
figure: unknown
figwidth: float
frameon: bool
gid: str
in_layout: bool
label: object
layout_engine: {'constrained', 'compressed', 'tight', 'none', <code>.LayoutEngine</code>, None}
linewidth: number
mouseover: bool
path_effects: list of <code>.AbstractPathEffect</code>
picker: None or bool or float or callable
rasterized: bool
size_inches: (float, float) or float
sketch_params: (scale: float, length: float, randomness: float)
snap: bool or None
tight_layout: unknown
transform: <code>~matplotlib.transforms.Transform</code>
url: str
visible: bool
zorder: float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="migration.SensPatankarResult"><code class="flex name class">
<span>class <span class="ident">SensPatankarResult</span></span>
<span>(</span><span>name, description, ttarget, t, C, CF, fc, f, x, Cx, tC, C0eq, timebase, restart, xi, Cxi)</span>
</code></dt>
<dd>
<div class="desc"><p>Container for the results of the 1D mass transfer simulation performed by <code><a title="migration.senspatankar" href="#migration.senspatankar">senspatankar()</a></code>.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>ttarget</code></strong> :&ensp;<code>ndarray with shape (1,)</code></dt>
<dd>target simulation time
It is a duration not an absolute time.</dd>
<dt><strong><code>CFtarget</code></strong> :&ensp;<code>ndarray with shape (1,)</code></dt>
<dd>CF value at ttarget</dd>
<dt><strong><code>Cxtarget</code></strong> :&ensp;<code>ndarray with shape (npoints,)</code></dt>
<dd>Cx concentration profile at t=ttarget</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>ndarray with shape (ntimes,)</code></dt>
<dd>1D array of time points (in seconds) covering from 0 to 2*ttarget
It is a duration not an absolute time.</dd>
<dt><strong><code>C</code></strong> :&ensp;<code>ndarray with shape (ntimes,)</code></dt>
<dd>1D array of mean concentration in the packaging (averaged over all packaging nodes)
at each time step. Shape: (ntimes,).</dd>
<dt><strong><code>CF</code></strong> :&ensp;<code>ndarray with shape (ntimes,)</code></dt>
<dd>1D array of concentration in the food (left boundary) at each time step. Shape: (ntimes,).</dd>
<dt><strong><code>fc</code></strong> :&ensp;<code>ndarray with shape (ntimes,)</code></dt>
<dd>1D array of the cumulative flux into the food. Shape: (ntimes,).</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>ndarray with shape (ntimes,)</code></dt>
<dd>1D array of the instantaneous flux into the food. Shape: (ntimes,).</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>ndarray with shape (npoints,)</code></dt>
<dd>1D array of the position coordinates of all packaging nodes (including sub-nodes).
npoints = 3 * number of original FV elements (interfaces e and w are included).</dd>
<dt><strong><code>Cx</code></strong> :&ensp;<code>ndarray with shape (ntimes,npoints)</code></dt>
<dd>2D array of the concentration profile across the packaging thickness for each time step.
Shape: (ntimes, 3 * number_of_nodes). Each row corresponds to one time step.</dd>
<dt><strong><code>tC</code></strong> :&ensp;<code>ndarray with shape (ntimes,)</code></dt>
<dd>1D array of the dimensionless time points</dd>
<dt><strong><code>C0eq</code></strong> :&ensp;<code>ndarray with shape (1,)</code></dt>
<dd>Reference (equilibrium) concentration scaling factor.</dd>
<dt><strong><code>timebase</code></strong> :&ensp;<code>float</code></dt>
<dd>Characteristic time scale (l_ref^2 / D_ref) used to normalize the solution.</dd>
<dt><strong><code>interp_CF</code></strong> :&ensp;<code>scipy.interpolate._interpolate.interp1d</code></dt>
<dd>1D interpolant of CF vs time</dd>
<dt><strong><code>interp_Cx</code></strong> :&ensp;<code>scipy.interpolate._interpolate.interp1d</code></dt>
<dd>1F interpolant of Cx vs time</dd>
<dt><strong><code>restart</code></strong> :&ensp;<code>restartfile_senspatankar object</code></dt>
<dd>Restart object (see restartfile_senspatankar doc)</dd>
</dl>
<p>constructor using positional arguments</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SensPatankarResult:
    &#34;&#34;&#34;
    Container for the results of the 1D mass transfer simulation performed by ``senspatankar``.

    Attributes
    ----------
    ttarget : ndarray with shape (1,)
        target simulation time
        It is a duration not an absolute time.
    CFtarget : ndarray with shape (1,)
        CF value at ttarget
    Cxtarget : ndarray with shape (npoints,)
         Cx concentration profile at t=ttarget
    t : ndarray with shape (ntimes,)
        1D array of time points (in seconds) covering from 0 to 2*ttarget
        It is a duration not an absolute time.
    C : ndarray with shape (ntimes,)
        1D array of mean concentration in the packaging (averaged over all packaging nodes)
        at each time step. Shape: (ntimes,).
    CF : ndarray with shape (ntimes,)
        1D array of concentration in the food (left boundary) at each time step. Shape: (ntimes,).
    fc : ndarray with shape (ntimes,)
        1D array of the cumulative flux into the food. Shape: (ntimes,).
    f : ndarray with shape (ntimes,)
        1D array of the instantaneous flux into the food. Shape: (ntimes,).
    x : ndarray with shape (npoints,)
        1D array of the position coordinates of all packaging nodes (including sub-nodes).
        npoints = 3 * number of original FV elements (interfaces e and w are included).
    Cx : ndarray with shape (ntimes,npoints)
        2D array of the concentration profile across the packaging thickness for each time step.
        Shape: (ntimes, 3 * number_of_nodes). Each row corresponds to one time step.
    tC : ndarray with shape (ntimes,)
        1D array of the dimensionless time points
    C0eq : ndarray with shape (1,)
        Reference (equilibrium) concentration scaling factor.
    timebase : float
        Characteristic time scale (l_ref^2 / D_ref) used to normalize the solution.
    interp_CF : scipy.interpolate._interpolate.interp1d
        1D interpolant of CF vs time
    interp_Cx : scipy.interpolate._interpolate.interp1d
        1F interpolant of Cx vs time
    restart : restartfile_senspatankar object
        Restart object (see restartfile_senspatankar doc)


    &#34;&#34;&#34;

    def __init__(self, name, description, ttarget, t, C, CF, fc, f, x, Cx, tC, C0eq, timebase,restart,xi,Cxi,_plotconfig=None):
        &#34;&#34;&#34;constructor using positional arguments&#34;&#34;&#34;
        # xi and Cxi are close to x and Cx but they can be interpolated
        # their values are not saved but used to built Cprofile
        self.name = name
        self.description = description
        self.ttarget = ttarget
        self.t = t
        self.C = C
        self.CF = CF
        self.fc = fc
        self.f = f
        self.x = x
        self.Cx = Cx
        self.tC = tC
        self.C0eq = C0eq
        self.timebase = timebase
        # Interpolated CF at ttarget
        self.interp_CF = interp1d(t, CF, kind=&#34;linear&#34;, fill_value=&#34;extrapolate&#34;)
        self.CFtarget = self.interp_CF(ttarget)
        # Interpolated concentration profile at ttarget
        self.interp_Cx = interp1d(t, Cx.T, kind=&#34;linear&#34;, axis=1, fill_value=&#34;extrapolate&#34;)
        self.Cxtarget = self.interp_Cx(ttarget)
        # Restart information including restults at ttarget
        # xi and Cxi are available only from a fresh simulation
        # these data are missing from operation +, in this case we use restart as supplied
        if xi is not None and Cxi is not None:
            Cxi_interp = interp1d(t, Cxi.T, kind=&#34;linear&#34;, axis=1, fill_value=&#34;extrapolate&#34;)
            Cxi_at_t = Cxi_interp(ttarget) # this profile has inceasing xi using xreltol
            restart.freezeCF(ttarget,self.CFtarget)
            restart.freezeCx(xi,Cxi_at_t)
        self.restart = restart
        if _plotconfig is None:
            self._plotconfig = plotconfig # fresh simulation
        else:
            self._plotconfig = _plotconfig # if from an existing SensPatankarResult
        # for simulation chaining
        self.savestate(self.restart.inputs[&#34;multilayer&#34;],self.restart.inputs[&#34;medium&#34;])

    def savestate(self,multilayer,medium):
        &#34;&#34;&#34;Saves senspantankar inputs for simulation chaining&#34;&#34;&#34;
        self._lastmedium = medium
        self._lastmultilayer = multilayer
        self._isstatesaved = True

    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update modifiable parameters of the SensPatankarResult object.
        Parameters:
            - name (str): New name for the object.
            - description (str): New description.
            - tscale (float or tuple): Time scale (can be tuple like (1, &#34;day&#34;)).
            - tunit (str): Time unit.
            - lscale (float or tuple): Length scale (can be tuple like (1e-6, &#34;µm&#34;)).
            - lunit (str): Length unit.
            - Cscale (float or tuple): Concentration scale (can be tuple like (1, &#34;a.u.&#34;)).
            - Cunit (str): Concentration unit.
        &#34;&#34;&#34;
        def checkunits(value):
            &#34;&#34;&#34;Helper function to handle unit conversion for scale/unit tuples.&#34;&#34;&#34;
            if isinstance(value, tuple) and len(value) == 2:
                scale, unit = check_units(value)
                scale, unit = np.array(scale, dtype=float), str(unit)  # Ensure correct types
                return scale.item(), unit  # Convert numpy array to float
            elif isinstance(value, (int, float, np.ndarray)):
                value = np.array(value, dtype=float)  # Ensure float
                return value.item(), None  # Return as float with no unit change
            else:
                raise ValueError(f&#34;Invalid value for scale/unit: {value}&#34;)

        # Update `name` and `description` if provided
        if &#34;name&#34; in kwargs:
            self.name = str(kwargs[&#34;name&#34;])
        if &#34;description&#34; in kwargs:
            self.description = str(kwargs[&#34;description&#34;])
        # Update `_plotconfig` parameters
        for key in [&#34;tscale&#34;, &#34;tunit&#34;, &#34;lscale&#34;, &#34;lunit&#34;, &#34;Cscale&#34;, &#34;Cunit&#34;]:
            if key in kwargs:
                value = kwargs[key]

                if key in [&#34;tscale&#34;, &#34;lscale&#34;, &#34;Cscale&#34;]:
                    value, unit = checkunits(value)  # Process unit conversion
                    self._plotconfig[key] = value
                    if unit is not None:
                        self._plotconfig[key.replace(&#34;scale&#34;, &#34;unit&#34;)] = unit  # Ensure unit consistency
                else:
                    self._plotconfig[key] = str(value)  # Convert unit strings directly
        return self  # Return self for method chaining if needed



    def resume(self,t=None,**kwargs):
        &#34;&#34;&#34;
        Resume simulation for a new duration (with all parameters are unchanged)

        For convenience user overrides are provided as:
            parameter = value
            with parameter = &#34;name&#34;,&#34;description&#34;...&#34;RelTol&#34;,&#34;AbsTol&#34; (see senspantankar)
        Use specifically:
            CF0 to assign a different concentration for the food
            Cx0 (Cprofile object) to assign a different concentration profile (not recommended)
            medium to set a different medium (food) in contact
        &#34;&#34;&#34;

        # retrieve previous results
        previousCF = self.restart.CF # CF at at target
        previousCx = self.restart.Cprofile # corresponding profile
        previousmedium = self.restart.inputs[&#34;medium&#34;].copy()
        previousmedium.CF0 = previousCF # we apply the concentration
        # CF override with CF=new value
        isCF0forced = &#34;CF0&#34; in kwargs
        newmedium = kwargs.get(&#34;medium&#34;,previousmedium)
        if isCF0forced:
            newCF0 = kwargs.get(&#34;CF0&#34;,previousCF)
            newmedium.CF0 = newCF0
        if t is None:
            ttarget = newmedium.get_param(&#34;contacttime&#34;,(10,&#34;days&#34;),acceptNone=False)
            t = 2*ttarget
        # Concentration profile override with Cx0=new profile
        newCx0 = kwargs.get(&#34;Cx0&#34;,previousCx)
        if not isinstance(newCx0,Cprofile):
            raise TypeError(f&#34;Cx0 should be a Cprofile object not a {type(newCx0).__name__}&#34;)

        # extend the existing solution
        inputs = self.restart.inputs # all previous inputs
        newsol = senspatankar(multilayer=inputs[&#34;multilayer&#34;],
                              medium=newmedium,
                              name=kwargs.get(&#34;name&#34;,inputs[&#34;name&#34;]),
                              description=kwargs.get(&#34;description&#34;,inputs[&#34;description&#34;]),
                              t=t,
                              autotime=kwargs.get(&#34;autotime&#34;,inputs[&#34;autotime&#34;]),
                              timescale=kwargs.get(&#34;timescale&#34;,inputs[&#34;timescale&#34;]),
                              Cxprevious=newCx0,
                              ntimes=kwargs.get(&#34;ntimes&#34;,inputs[&#34;ntimes&#34;]),
                              RelTol=kwargs.get(&#34;RelTol&#34;,inputs[&#34;RelTol&#34;]),
                              AbsTol=kwargs.get(&#34;AbsTol&#34;,inputs[&#34;AbsTol&#34;]))
        return newsol

    def chaining(self,multilayer,medium,**kwargs):
        sim = self.resume(multilayer=multilayer,medium=medium,**kwargs)
        medium.lastsimulation = sim # store the last simulation result in medium
        medium.lastinput = multilayer # store the last input (in medium)
        sim.savestate(multilayer,medium) # store store the inputs in sim for chaining
        return sim

    # overloading operation
    def __rshift__(self, medium):
        &#34;&#34;&#34;Overloads &gt;&gt; to propagate migration to food.&#34;&#34;&#34;
        if not isinstance(medium,foodphysics):
            raise TypeError(f&#34;medium must be a foodphysics object not a {type(medium).__name__}&#34;)
        if not self._isstatesaved:
            raise RuntimeError(&#34;The previous inputs were not saved within the instance.&#34;)
        # we update the contact temperature (see example3)
        return self.chaining(medium&gt;&gt;self._lastmultilayer,medium,CF0=self.restart.CF)

    def __add__(self, other):
        &#34;&#34;&#34;Concatenate two solutions&#34;&#34;&#34;
        if not isinstance(other, SensPatankarResult):
            raise TypeError(&#34;Can only add two SensPatankarResult objects&#34;)

        # Ensure compatibility of x-axis
        if not np.isclose(self.x[0], other.x[0]) or not np.isclose(self.x[-1], other.x[-1]):
            raise ValueError(&#34;Mismatch in x-axis boundaries between solutions&#34;)

        # Interpolate other.Cx onto self.x
        interp_Cx_other = interp1d(other.x, other.Cx.T, kind=&#34;linear&#34;, fill_value=0, axis=0)
        Cx_other_interp = interp_Cx_other(self.x).T  # Ensuring shape (ntimes, npoints)

        # Restrict times for valid merging
        valid_indices_self = self.t &lt;= self.ttarget
        valid_indices_other = (other.t &gt; 0) #&amp; (other.t &lt;= other.ttarget)
        t_self = self.t[valid_indices_self]
        t_other = other.t[valid_indices_other] + self.ttarget  # Shift time

        # Merge time arrays without duplicates
        t_merged = np.unique(np.concatenate((t_self, t_other)))
        tC_merged = np.unique(np.concatenate((self.tC[valid_indices_self], other.tC[valid_indices_other])))

        # Merge concentration-related attributes
        C_merged = np.concatenate((self.C[valid_indices_self], other.C[valid_indices_other]))
        CF_merged = np.concatenate((self.CF[valid_indices_self], other.CF[valid_indices_other]))
        fc_merged = np.concatenate((self.fc[valid_indices_self], other.fc[valid_indices_other]))
        f_merged = np.concatenate((self.f[valid_indices_self], other.f[valid_indices_other]))

        # Merge concentration profiles
        Cx_merged = np.vstack((self.Cx[valid_indices_self], Cx_other_interp[valid_indices_other]))

        # Merged description
        if self.description and other.description:
            merged_description = f&#34;Merged: {self.description} &amp; {other.description}&#34;
        elif self.description:
            merged_description = self.description
        elif other.description:
            merged_description = other.description
        else:
            merged_description = &#34;&#34;

        # Create new instance with merged data
        merged_result = SensPatankarResult(
            name=f&#34;{self.name} + {other.name}&#34; if self.name!=other.name else self.name,
            description=merged_description,
            ttarget=self.ttarget + other.ttarget,
            t=t_merged,
            C=C_merged,
            CF=CF_merged,
            fc=fc_merged,
            f=f_merged,
            x=self.x,  # Keep self.x as reference
            Cx=Cx_merged,
            tC=tC_merged,
            C0eq=self.C0eq,  # Keep self.C0eq
            timebase=other.timebase,  # Take timebase from other
            restart=other.restart,  # Take restart from other (the last valid one)
            xi=None,  # xi and Cxi values are available
            Cxi=None  # only from a fresh simulation
        )

        return merged_result

    def interpolate_CF(self, t, kind=&#34;linear&#34;, fill_value=&#34;extrapolate&#34;):
        &#34;&#34;&#34;
        Interpolates the concentration in the food (CF) at given time(s).

        Parameters
        ----------
        t : float, list, tuple, or ndarray
            Time(s) at which to interpolate CF values.
            - If a tuple, it should be (value or list, unit) and will be converted to SI.
            - If a scalar or list, it is assumed to be in SI units already.
        kind : str, optional
            Interpolation method. Default is &#34;linear&#34;.
            Possible values:
            - &#34;linear&#34;: Piecewise linear interpolation (default).
            - &#34;nearest&#34;: Nearest-neighbor interpolation.
            - &#34;zero&#34;: Zero-order spline interpolation.
            - &#34;slinear&#34;, &#34;quadratic&#34;, &#34;cubic&#34;: Spline interpolations of various orders.
        fill_value : str or float, optional
            Specifies how to handle values outside the given range.
            - &#34;extrapolate&#34; (default): Extrapolates values beyond available data.
            - Any float: Uses a constant value for out-of-bounds interpolation.

        Returns
        -------
        ndarray
            Interpolated CF values at the requested time(s).
        &#34;&#34;&#34;
        # Convert time input to SI units if provided as a tuple
        if isinstance(t, tuple):
            t, _ = check_units(t)  # Convert to numeric array

        # Ensure t is a NumPy array for vectorized operations
        t = np.atleast_1d(t)

        # Create the interpolant on demand with user-defined settings
        interp_function = interp1d(self.t, self.CF, kind=kind, fill_value=fill_value, bounds_error=False)

        # Return interpolated values
        return interp_function(t)


    def __repr__(self):
        ntimes = len(self.t)
        nx = self.Cx.shape[1] if self.Cx.ndim &gt; 1 else len(self.x)
        tmin, tmax = self.t.min(), self.t.max()
        xmin, xmax = self.x.min(), self.x.max()

        print(f&#34;SensPatankarResult: {self.name}\n&#34;
              f&#34;\t {self.description if self.description != &#39;&#39; else &#39;&lt;no description&gt;&#39;}\n&#34;
              f&#34;\t - with {ntimes} time steps\n&#34;,
              f&#34;\t - with {nx} spatial points\n&#34;
              f&#34;\t - Time range: [{tmin:.2e}, {tmax:.2e}] s\n&#34;
              f&#34;\t - Position range: [{xmin:.2e}, {xmax:.2e}] m&#34;)

        return str(self)


    def __str__(self):
        return (f&#39;&lt;{self.__class__.__name__}:{self.name}: &#39;
            f&#39;CF({(self.ttarget / plotconfig[&#34;tscale&#34;]).item():.4g} [{plotconfig[&#34;tunit&#34;]}]) = &#39;
            f&#39;{(self.CFtarget / plotconfig[&#34;Cscale&#34;]).item():.4g} [{plotconfig[&#34;Cunit&#34;]}]&gt;&#39;)



    def plotCF(self, t=None, trange=None):
        &#34;&#34;&#34;
        Plot the concentration in the food (CF) as a function of time and highlight the target time(s).

        Parameters
        ----------
        t : float, list, or None, optional
            Specific time(s) for which the concentration should be highlighted.
            If None, defaults to `ttarget`.
        trange : None, float, or list [t_min, t_max], optional
            If None, the full profile is shown.
            If a float, it is treated as an upper bound (lower bound assumed 0).
            If a list `[t_min, t_max]`, the profile is interpolated between these values.
        &#34;&#34;&#34;

        # extract plotconfig
        plotconfig = self._plotconfig

        # Ensure t is a list (even if a single value is given)
        if t is None:
            t_values = [self.ttarget]
        elif isinstance(t, (int, float)):
            t_values = [t]
        elif isinstance(t,np.ndarray):
            t_values = t.flatten()
        elif isinstance(t,tuple):
            t_values = check_units(t)[0]
        else:
            t_values = np.array(t)  # Convert to array

        # Interpolate CF values at given times
        CF_t_values = self.interp_CF(t_values)

        # Handle trange interpolation
        if trange is None:
            t_plot = self.t
            CF_plot = self.CF
        else:
            # Convert trange to a valid range
            if isinstance(trange, (int, float)):
                trange = [0, trange]  # Assume lower bound is 0
            elif len(trange) != 2:
                raise ValueError(&#34;trange must be None, a single float (upper bound), or a list of two values [t_min, t_max]&#34;)

            # Validate range
            t_min, t_max = trange
            if t_min &lt; self.t.min() or t_max &gt; self.t.max():
                print(&#34;Warning: trange values are outside the available time range and may cause extrapolation.&#34;)

            # Generate interpolated time values
            t_plot = np.linspace(t_min, t_max, 500)
            CF_plot = self.interp_CF(t_plot)  # Interpolated CF values

        # Set up colormap for multiple t values
        cmap = plt.get_cmap(&#39;viridis&#39;, len(t_values))
        norm = mcolors.Normalize(vmin=min(t_values), vmax=max(t_values))

        # Create the figure
        fig, ax = plt.subplots(figsize=(8, 6))

        # Plot CF curve (either original or interpolated)
        ax.plot(t_plot / plotconfig[&#34;tscale&#34;], CF_plot / plotconfig[&#34;Cscale&#34;],
                label=&#39;Concentration in Food&#39;, color=&#39;b&#39;)

        # Highlight each target time
        for i, tC in enumerate(t_values):
            color = tooclear(cmap(norm(tC))) if len(t_values) &gt; 1 else &#39;r&#39;  # Use color map only if multiple t values

            # Vertical and horizontal lines
            ax.axvline(tC / plotconfig[&#34;tscale&#34;], color=color, linestyle=&#39;--&#39;, linewidth=1)
            ax.axhline(CF_t_values[i] / plotconfig[&#34;Cscale&#34;], color=color, linestyle=&#39;--&#39;, linewidth=1)

            # Intersection point
            ax.scatter(tC / plotconfig[&#34;tscale&#34;], CF_t_values[i] / plotconfig[&#34;Cscale&#34;],
                       color=color, zorder=3)

            # Annotate time
            ax.text(tC / plotconfig[&#34;tscale&#34;], min(CF_plot) / plotconfig[&#34;Cscale&#34;],
                    f&#39;{(tC / plotconfig[&#34;tscale&#34;]).item():.2f} {plotconfig[&#34;tunit&#34;]}&#39;,
                    verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;right&#39;, rotation=90, fontsize=10, color=color)

            # Annotate concentration
            ax.text(min(t_plot) / plotconfig[&#34;tscale&#34;], CF_t_values[i] / plotconfig[&#34;Cscale&#34;],
                    f&#39;{(CF_t_values[i] / plotconfig[&#34;Cscale&#34;]).item():.2f} {plotconfig[&#34;Cunit&#34;]}&#39;,
                    verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;left&#39;, fontsize=10, color=color)

        # Labels and title
        ax.set_xlabel(f&#39;Time [{plotconfig[&#34;tunit&#34;]}]&#39;)
        ax.set_ylabel(f&#39;Concentration in Food [{plotconfig[&#34;Cunit&#34;]}]&#39;)
        title_main = &#34;Concentration in Food vs. Time&#34;
        title_sub = rf&#34;$\bf{{{self.name}}}$&#34; + (f&#34;: {self.description}&#34; if self.description else &#34;&#34;)
        ax.set_title(f&#34;{title_main}\n{title_sub}&#34;, fontsize=10)
        ax.text(0.5, 1.05, title_sub, fontsize=8, ha=&#34;center&#34;, va=&#34;bottom&#34;, transform=ax.transAxes)
        ax.set_title(title_main)
        ax.legend()
        ax.grid(True)
        plt.show()
        # store metadata
        setattr(fig,_fig_metadata_atrr_,f&#34;pltCF_{self.name}&#34;)
        return fig



    def plotCx(self, t=None, nmax=15):
        &#34;&#34;&#34;
        Plot the concentration profiles (Cx) in the packaging vs. position (x) for different times,
        using a color gradient similar to Parula, based on time values (not index order).
        Additionally, highlight the concentration profile at `ttarget` with a thick black line.

        Parameters
        ----------
        t : list, array-like, or None, optional
            List of specific times to plot. Only valid values (inside self.t) are used.
            If None, time values are selected using sqrt-spaced distribution.
        nmax : int, optional
            Maximum number of profiles to plot. The default is 15.
        &#34;&#34;&#34;

        # extract plotconfig
        plotconfig = self._plotconfig


        # Ensure time values are within the available time range
        if t is None:
            # Default: Select `nmax` time values using sqrt-spacing
            nt = len(self.t)
            if nt &lt;= nmax:
                t_values = self.t
            else:
                sqrt_t = np.sqrt(self.t)
                sqrt_t_values = np.linspace(sqrt_t[0], sqrt_t[-1], nmax)
                t_values = sqrt_t_values**2
        else:
            # Use user-specified time values
            if isinstance(t,tuple):
                t_values = check_units(t)[0]
            else:
                t_values = np.array(t)
            # Keep only valid times inside `self.t`
            t_values = t_values[(t_values &gt;= self.t.min()) &amp; (t_values &lt;= self.t.max())]
            if len(t_values) == 0:
                print(&#34;Warning: No valid time values found in the specified range.&#34;)
                return
            # If more than `nmax`, keep the first `nmax` values
            t_values = t_values[:nmax]

        # Normalize time for colormap (Ensure at least one valid value)
        norm = mcolors.Normalize(vmin=t_values.min(), vmax=t_values.max()) if len(t_values) &gt; 1 else mcolors.Normalize(vmin=self.t.min(), vmax=self.t.max())
        cmap = plt.get_cmap(&#39;viridis&#39;, nmax)  # &#39;viridis&#39; is similar to Parula

        fig, ax = plt.subplots(figsize=(8, 6))  # Explicitly create a figure and axis

        # Plot all valid concentration profiles with time-based colormap
        for tC in t_values:
            C = self.interp_Cx(tC)
            color = tooclear(cmap(norm(tC)))  # Get color from colormap
            ax.plot(self.x / plotconfig[&#34;lscale&#34;], C / plotconfig[&#34;Cscale&#34;],
                    color=color, alpha=0.9, label=f&#39;t={tC / plotconfig[&#34;tscale&#34;]:.3g} {plotconfig[&#34;tunit&#34;]}&#39;)

        # Highlight concentration profile at `ttarget`
        ax.plot(self.x / plotconfig[&#34;lscale&#34;], self.Cxtarget / plotconfig[&#34;Cscale&#34;], &#39;k-&#39;, linewidth=3,
                label=f&#39;t={self.ttarget[0] / plotconfig[&#34;tscale&#34;]:.2g} {plotconfig[&#34;tunit&#34;]} (target)&#39;)

        # Create ScalarMappable and add colorbar
        sm = cm.ScalarMappable(cmap=cmap, norm=norm)
        sm.set_array([])  # Needed for colorbar
        cbar = fig.colorbar(sm, ax=ax)  # Explicitly associate colorbar with axis
        cbar.set_label(f&#39;Time [{plotconfig[&#34;tunit&#34;]}]&#39;)

        ax.set_xlabel(f&#39;Position [{plotconfig[&#34;lunit&#34;]}]&#39;)
        ax.set_ylabel(f&#39;Concentration in Packaging [{plotconfig[&#34;Cunit&#34;]}]&#39;)
        title_main = &#34;Concentration Profiles in Packaging vs. Position&#34;
        title_sub = rf&#34;$\bf{{{self.name}}}$&#34; + (f&#34;: {self.description}&#34; if self.description else &#34;&#34;)
        ax.set_title(f&#34;{title_main}\n{title_sub}&#34;, fontsize=10)
        ax.text(0.5, 1.05, title_sub, fontsize=8, ha=&#34;center&#34;, va=&#34;bottom&#34;, transform=ax.transAxes)
        ax.set_title(title_main)
        ax.grid(True)
        ax.legend()
        plt.show()
        # store metadata
        setattr(fig,_fig_metadata_atrr_,f&#34;pltCx_{self.name}&#34;)
        return fig</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="migration.SensPatankarResult.chaining"><code class="name flex">
<span>def <span class="ident">chaining</span></span>(<span>self, multilayer, medium, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chaining(self,multilayer,medium,**kwargs):
    sim = self.resume(multilayer=multilayer,medium=medium,**kwargs)
    medium.lastsimulation = sim # store the last simulation result in medium
    medium.lastinput = multilayer # store the last input (in medium)
    sim.savestate(multilayer,medium) # store store the inputs in sim for chaining
    return sim</code></pre>
</details>
</dd>
<dt id="migration.SensPatankarResult.interpolate_CF"><code class="name flex">
<span>def <span class="ident">interpolate_CF</span></span>(<span>self, t, kind='linear', fill_value='extrapolate')</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolates the concentration in the food (CF) at given time(s).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>float, list, tuple,</code> or <code>ndarray</code></dt>
<dd>Time(s) at which to interpolate CF values.
- If a tuple, it should be (value or list, unit) and will be converted to SI.
- If a scalar or list, it is assumed to be in SI units already.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Interpolation method. Default is "linear".
Possible values:
- "linear": Piecewise linear interpolation (default).
- "nearest": Nearest-neighbor interpolation.
- "zero": Zero-order spline interpolation.
- "slinear", "quadratic", "cubic": Spline interpolations of various orders.</dd>
<dt><strong><code>fill_value</code></strong> :&ensp;<code>str</code> or <code>float</code>, optional</dt>
<dd>Specifies how to handle values outside the given range.
- "extrapolate" (default): Extrapolates values beyond available data.
- Any float: Uses a constant value for out-of-bounds interpolation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Interpolated CF values at the requested time(s).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_CF(self, t, kind=&#34;linear&#34;, fill_value=&#34;extrapolate&#34;):
    &#34;&#34;&#34;
    Interpolates the concentration in the food (CF) at given time(s).

    Parameters
    ----------
    t : float, list, tuple, or ndarray
        Time(s) at which to interpolate CF values.
        - If a tuple, it should be (value or list, unit) and will be converted to SI.
        - If a scalar or list, it is assumed to be in SI units already.
    kind : str, optional
        Interpolation method. Default is &#34;linear&#34;.
        Possible values:
        - &#34;linear&#34;: Piecewise linear interpolation (default).
        - &#34;nearest&#34;: Nearest-neighbor interpolation.
        - &#34;zero&#34;: Zero-order spline interpolation.
        - &#34;slinear&#34;, &#34;quadratic&#34;, &#34;cubic&#34;: Spline interpolations of various orders.
    fill_value : str or float, optional
        Specifies how to handle values outside the given range.
        - &#34;extrapolate&#34; (default): Extrapolates values beyond available data.
        - Any float: Uses a constant value for out-of-bounds interpolation.

    Returns
    -------
    ndarray
        Interpolated CF values at the requested time(s).
    &#34;&#34;&#34;
    # Convert time input to SI units if provided as a tuple
    if isinstance(t, tuple):
        t, _ = check_units(t)  # Convert to numeric array

    # Ensure t is a NumPy array for vectorized operations
    t = np.atleast_1d(t)

    # Create the interpolant on demand with user-defined settings
    interp_function = interp1d(self.t, self.CF, kind=kind, fill_value=fill_value, bounds_error=False)

    # Return interpolated values
    return interp_function(t)</code></pre>
</details>
</dd>
<dt id="migration.SensPatankarResult.plotCF"><code class="name flex">
<span>def <span class="ident">plotCF</span></span>(<span>self, t=None, trange=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the concentration in the food (CF) as a function of time and highlight the target time(s).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>float, list,</code> or <code>None</code>, optional</dt>
<dd>Specific time(s) for which the concentration should be highlighted.
If None, defaults to <code>ttarget</code>.</dd>
<dt><strong><code>trange</code></strong> :&ensp;<code>None, float,</code> or <code>list [t_min, t_max]</code>, optional</dt>
<dd>If None, the full profile is shown.
If a float, it is treated as an upper bound (lower bound assumed 0).
If a list <code>[t_min, t_max]</code>, the profile is interpolated between these values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotCF(self, t=None, trange=None):
    &#34;&#34;&#34;
    Plot the concentration in the food (CF) as a function of time and highlight the target time(s).

    Parameters
    ----------
    t : float, list, or None, optional
        Specific time(s) for which the concentration should be highlighted.
        If None, defaults to `ttarget`.
    trange : None, float, or list [t_min, t_max], optional
        If None, the full profile is shown.
        If a float, it is treated as an upper bound (lower bound assumed 0).
        If a list `[t_min, t_max]`, the profile is interpolated between these values.
    &#34;&#34;&#34;

    # extract plotconfig
    plotconfig = self._plotconfig

    # Ensure t is a list (even if a single value is given)
    if t is None:
        t_values = [self.ttarget]
    elif isinstance(t, (int, float)):
        t_values = [t]
    elif isinstance(t,np.ndarray):
        t_values = t.flatten()
    elif isinstance(t,tuple):
        t_values = check_units(t)[0]
    else:
        t_values = np.array(t)  # Convert to array

    # Interpolate CF values at given times
    CF_t_values = self.interp_CF(t_values)

    # Handle trange interpolation
    if trange is None:
        t_plot = self.t
        CF_plot = self.CF
    else:
        # Convert trange to a valid range
        if isinstance(trange, (int, float)):
            trange = [0, trange]  # Assume lower bound is 0
        elif len(trange) != 2:
            raise ValueError(&#34;trange must be None, a single float (upper bound), or a list of two values [t_min, t_max]&#34;)

        # Validate range
        t_min, t_max = trange
        if t_min &lt; self.t.min() or t_max &gt; self.t.max():
            print(&#34;Warning: trange values are outside the available time range and may cause extrapolation.&#34;)

        # Generate interpolated time values
        t_plot = np.linspace(t_min, t_max, 500)
        CF_plot = self.interp_CF(t_plot)  # Interpolated CF values

    # Set up colormap for multiple t values
    cmap = plt.get_cmap(&#39;viridis&#39;, len(t_values))
    norm = mcolors.Normalize(vmin=min(t_values), vmax=max(t_values))

    # Create the figure
    fig, ax = plt.subplots(figsize=(8, 6))

    # Plot CF curve (either original or interpolated)
    ax.plot(t_plot / plotconfig[&#34;tscale&#34;], CF_plot / plotconfig[&#34;Cscale&#34;],
            label=&#39;Concentration in Food&#39;, color=&#39;b&#39;)

    # Highlight each target time
    for i, tC in enumerate(t_values):
        color = tooclear(cmap(norm(tC))) if len(t_values) &gt; 1 else &#39;r&#39;  # Use color map only if multiple t values

        # Vertical and horizontal lines
        ax.axvline(tC / plotconfig[&#34;tscale&#34;], color=color, linestyle=&#39;--&#39;, linewidth=1)
        ax.axhline(CF_t_values[i] / plotconfig[&#34;Cscale&#34;], color=color, linestyle=&#39;--&#39;, linewidth=1)

        # Intersection point
        ax.scatter(tC / plotconfig[&#34;tscale&#34;], CF_t_values[i] / plotconfig[&#34;Cscale&#34;],
                   color=color, zorder=3)

        # Annotate time
        ax.text(tC / plotconfig[&#34;tscale&#34;], min(CF_plot) / plotconfig[&#34;Cscale&#34;],
                f&#39;{(tC / plotconfig[&#34;tscale&#34;]).item():.2f} {plotconfig[&#34;tunit&#34;]}&#39;,
                verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;right&#39;, rotation=90, fontsize=10, color=color)

        # Annotate concentration
        ax.text(min(t_plot) / plotconfig[&#34;tscale&#34;], CF_t_values[i] / plotconfig[&#34;Cscale&#34;],
                f&#39;{(CF_t_values[i] / plotconfig[&#34;Cscale&#34;]).item():.2f} {plotconfig[&#34;Cunit&#34;]}&#39;,
                verticalalignment=&#39;bottom&#39;, horizontalalignment=&#39;left&#39;, fontsize=10, color=color)

    # Labels and title
    ax.set_xlabel(f&#39;Time [{plotconfig[&#34;tunit&#34;]}]&#39;)
    ax.set_ylabel(f&#39;Concentration in Food [{plotconfig[&#34;Cunit&#34;]}]&#39;)
    title_main = &#34;Concentration in Food vs. Time&#34;
    title_sub = rf&#34;$\bf{{{self.name}}}$&#34; + (f&#34;: {self.description}&#34; if self.description else &#34;&#34;)
    ax.set_title(f&#34;{title_main}\n{title_sub}&#34;, fontsize=10)
    ax.text(0.5, 1.05, title_sub, fontsize=8, ha=&#34;center&#34;, va=&#34;bottom&#34;, transform=ax.transAxes)
    ax.set_title(title_main)
    ax.legend()
    ax.grid(True)
    plt.show()
    # store metadata
    setattr(fig,_fig_metadata_atrr_,f&#34;pltCF_{self.name}&#34;)
    return fig</code></pre>
</details>
</dd>
<dt id="migration.SensPatankarResult.plotCx"><code class="name flex">
<span>def <span class="ident">plotCx</span></span>(<span>self, t=None, nmax=15)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the concentration profiles (Cx) in the packaging vs. position (x) for different times,
using a color gradient similar to Parula, based on time values (not index order).
Additionally, highlight the concentration profile at <code>ttarget</code> with a thick black line.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>list, array-like,</code> or <code>None</code>, optional</dt>
<dd>List of specific times to plot. Only valid values (inside self.t) are used.
If None, time values are selected using sqrt-spaced distribution.</dd>
<dt><strong><code>nmax</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum number of profiles to plot. The default is 15.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotCx(self, t=None, nmax=15):
    &#34;&#34;&#34;
    Plot the concentration profiles (Cx) in the packaging vs. position (x) for different times,
    using a color gradient similar to Parula, based on time values (not index order).
    Additionally, highlight the concentration profile at `ttarget` with a thick black line.

    Parameters
    ----------
    t : list, array-like, or None, optional
        List of specific times to plot. Only valid values (inside self.t) are used.
        If None, time values are selected using sqrt-spaced distribution.
    nmax : int, optional
        Maximum number of profiles to plot. The default is 15.
    &#34;&#34;&#34;

    # extract plotconfig
    plotconfig = self._plotconfig


    # Ensure time values are within the available time range
    if t is None:
        # Default: Select `nmax` time values using sqrt-spacing
        nt = len(self.t)
        if nt &lt;= nmax:
            t_values = self.t
        else:
            sqrt_t = np.sqrt(self.t)
            sqrt_t_values = np.linspace(sqrt_t[0], sqrt_t[-1], nmax)
            t_values = sqrt_t_values**2
    else:
        # Use user-specified time values
        if isinstance(t,tuple):
            t_values = check_units(t)[0]
        else:
            t_values = np.array(t)
        # Keep only valid times inside `self.t`
        t_values = t_values[(t_values &gt;= self.t.min()) &amp; (t_values &lt;= self.t.max())]
        if len(t_values) == 0:
            print(&#34;Warning: No valid time values found in the specified range.&#34;)
            return
        # If more than `nmax`, keep the first `nmax` values
        t_values = t_values[:nmax]

    # Normalize time for colormap (Ensure at least one valid value)
    norm = mcolors.Normalize(vmin=t_values.min(), vmax=t_values.max()) if len(t_values) &gt; 1 else mcolors.Normalize(vmin=self.t.min(), vmax=self.t.max())
    cmap = plt.get_cmap(&#39;viridis&#39;, nmax)  # &#39;viridis&#39; is similar to Parula

    fig, ax = plt.subplots(figsize=(8, 6))  # Explicitly create a figure and axis

    # Plot all valid concentration profiles with time-based colormap
    for tC in t_values:
        C = self.interp_Cx(tC)
        color = tooclear(cmap(norm(tC)))  # Get color from colormap
        ax.plot(self.x / plotconfig[&#34;lscale&#34;], C / plotconfig[&#34;Cscale&#34;],
                color=color, alpha=0.9, label=f&#39;t={tC / plotconfig[&#34;tscale&#34;]:.3g} {plotconfig[&#34;tunit&#34;]}&#39;)

    # Highlight concentration profile at `ttarget`
    ax.plot(self.x / plotconfig[&#34;lscale&#34;], self.Cxtarget / plotconfig[&#34;Cscale&#34;], &#39;k-&#39;, linewidth=3,
            label=f&#39;t={self.ttarget[0] / plotconfig[&#34;tscale&#34;]:.2g} {plotconfig[&#34;tunit&#34;]} (target)&#39;)

    # Create ScalarMappable and add colorbar
    sm = cm.ScalarMappable(cmap=cmap, norm=norm)
    sm.set_array([])  # Needed for colorbar
    cbar = fig.colorbar(sm, ax=ax)  # Explicitly associate colorbar with axis
    cbar.set_label(f&#39;Time [{plotconfig[&#34;tunit&#34;]}]&#39;)

    ax.set_xlabel(f&#39;Position [{plotconfig[&#34;lunit&#34;]}]&#39;)
    ax.set_ylabel(f&#39;Concentration in Packaging [{plotconfig[&#34;Cunit&#34;]}]&#39;)
    title_main = &#34;Concentration Profiles in Packaging vs. Position&#34;
    title_sub = rf&#34;$\bf{{{self.name}}}$&#34; + (f&#34;: {self.description}&#34; if self.description else &#34;&#34;)
    ax.set_title(f&#34;{title_main}\n{title_sub}&#34;, fontsize=10)
    ax.text(0.5, 1.05, title_sub, fontsize=8, ha=&#34;center&#34;, va=&#34;bottom&#34;, transform=ax.transAxes)
    ax.set_title(title_main)
    ax.grid(True)
    ax.legend()
    plt.show()
    # store metadata
    setattr(fig,_fig_metadata_atrr_,f&#34;pltCx_{self.name}&#34;)
    return fig</code></pre>
</details>
</dd>
<dt id="migration.SensPatankarResult.resume"><code class="name flex">
<span>def <span class="ident">resume</span></span>(<span>self, t=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Resume simulation for a new duration (with all parameters are unchanged)</p>
<p>For convenience user overrides are provided as:
parameter = value
with parameter = "name","description"&hellip;"RelTol","AbsTol" (see senspantankar)
Use specifically:
CF0 to assign a different concentration for the food
Cx0 (Cprofile object) to assign a different concentration profile (not recommended)
medium to set a different medium (food) in contact</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resume(self,t=None,**kwargs):
    &#34;&#34;&#34;
    Resume simulation for a new duration (with all parameters are unchanged)

    For convenience user overrides are provided as:
        parameter = value
        with parameter = &#34;name&#34;,&#34;description&#34;...&#34;RelTol&#34;,&#34;AbsTol&#34; (see senspantankar)
    Use specifically:
        CF0 to assign a different concentration for the food
        Cx0 (Cprofile object) to assign a different concentration profile (not recommended)
        medium to set a different medium (food) in contact
    &#34;&#34;&#34;

    # retrieve previous results
    previousCF = self.restart.CF # CF at at target
    previousCx = self.restart.Cprofile # corresponding profile
    previousmedium = self.restart.inputs[&#34;medium&#34;].copy()
    previousmedium.CF0 = previousCF # we apply the concentration
    # CF override with CF=new value
    isCF0forced = &#34;CF0&#34; in kwargs
    newmedium = kwargs.get(&#34;medium&#34;,previousmedium)
    if isCF0forced:
        newCF0 = kwargs.get(&#34;CF0&#34;,previousCF)
        newmedium.CF0 = newCF0
    if t is None:
        ttarget = newmedium.get_param(&#34;contacttime&#34;,(10,&#34;days&#34;),acceptNone=False)
        t = 2*ttarget
    # Concentration profile override with Cx0=new profile
    newCx0 = kwargs.get(&#34;Cx0&#34;,previousCx)
    if not isinstance(newCx0,Cprofile):
        raise TypeError(f&#34;Cx0 should be a Cprofile object not a {type(newCx0).__name__}&#34;)

    # extend the existing solution
    inputs = self.restart.inputs # all previous inputs
    newsol = senspatankar(multilayer=inputs[&#34;multilayer&#34;],
                          medium=newmedium,
                          name=kwargs.get(&#34;name&#34;,inputs[&#34;name&#34;]),
                          description=kwargs.get(&#34;description&#34;,inputs[&#34;description&#34;]),
                          t=t,
                          autotime=kwargs.get(&#34;autotime&#34;,inputs[&#34;autotime&#34;]),
                          timescale=kwargs.get(&#34;timescale&#34;,inputs[&#34;timescale&#34;]),
                          Cxprevious=newCx0,
                          ntimes=kwargs.get(&#34;ntimes&#34;,inputs[&#34;ntimes&#34;]),
                          RelTol=kwargs.get(&#34;RelTol&#34;,inputs[&#34;RelTol&#34;]),
                          AbsTol=kwargs.get(&#34;AbsTol&#34;,inputs[&#34;AbsTol&#34;]))
    return newsol</code></pre>
</details>
</dd>
<dt id="migration.SensPatankarResult.savestate"><code class="name flex">
<span>def <span class="ident">savestate</span></span>(<span>self, multilayer, medium)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves senspantankar inputs for simulation chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def savestate(self,multilayer,medium):
    &#34;&#34;&#34;Saves senspantankar inputs for simulation chaining&#34;&#34;&#34;
    self._lastmedium = medium
    self._lastmultilayer = multilayer
    self._isstatesaved = True</code></pre>
</details>
</dd>
<dt id="migration.SensPatankarResult.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update modifiable parameters of the SensPatankarResult object.</p>
<h2 id="parameters">Parameters</h2>
<ul>
<li>name (str): New name for the object.</li>
<li>description (str): New description.</li>
<li>tscale (float or tuple): Time scale (can be tuple like (1, "day")).</li>
<li>tunit (str): Time unit.</li>
<li>lscale (float or tuple): Length scale (can be tuple like (1e-6, "µm")).</li>
<li>lunit (str): Length unit.</li>
<li>Cscale (float or tuple): Concentration scale (can be tuple like (1, "a.u.")).</li>
<li>Cunit (str): Concentration unit.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update modifiable parameters of the SensPatankarResult object.
    Parameters:
        - name (str): New name for the object.
        - description (str): New description.
        - tscale (float or tuple): Time scale (can be tuple like (1, &#34;day&#34;)).
        - tunit (str): Time unit.
        - lscale (float or tuple): Length scale (can be tuple like (1e-6, &#34;µm&#34;)).
        - lunit (str): Length unit.
        - Cscale (float or tuple): Concentration scale (can be tuple like (1, &#34;a.u.&#34;)).
        - Cunit (str): Concentration unit.
    &#34;&#34;&#34;
    def checkunits(value):
        &#34;&#34;&#34;Helper function to handle unit conversion for scale/unit tuples.&#34;&#34;&#34;
        if isinstance(value, tuple) and len(value) == 2:
            scale, unit = check_units(value)
            scale, unit = np.array(scale, dtype=float), str(unit)  # Ensure correct types
            return scale.item(), unit  # Convert numpy array to float
        elif isinstance(value, (int, float, np.ndarray)):
            value = np.array(value, dtype=float)  # Ensure float
            return value.item(), None  # Return as float with no unit change
        else:
            raise ValueError(f&#34;Invalid value for scale/unit: {value}&#34;)

    # Update `name` and `description` if provided
    if &#34;name&#34; in kwargs:
        self.name = str(kwargs[&#34;name&#34;])
    if &#34;description&#34; in kwargs:
        self.description = str(kwargs[&#34;description&#34;])
    # Update `_plotconfig` parameters
    for key in [&#34;tscale&#34;, &#34;tunit&#34;, &#34;lscale&#34;, &#34;lunit&#34;, &#34;Cscale&#34;, &#34;Cunit&#34;]:
        if key in kwargs:
            value = kwargs[key]

            if key in [&#34;tscale&#34;, &#34;lscale&#34;, &#34;Cscale&#34;]:
                value, unit = checkunits(value)  # Process unit conversion
                self._plotconfig[key] = value
                if unit is not None:
                    self._plotconfig[key.replace(&#34;scale&#34;, &#34;unit&#34;)] = unit  # Ensure unit consistency
            else:
                self._plotconfig[key] = str(value)  # Convert unit strings directly
    return self  # Return self for method chaining if needed</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="migration.foodlayer"><code class="flex name class">
<span>class <span class="ident">foodlayer</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Foodlayer class is a generic class to define food as a 1D layer in a symmetric manner with layer class
applicable to materials in contact.
Since mass transfer are much faster in the food than in the materials in contact, food is represented
as an almost 0D layer. Only a mass transfer resistance is applied at the food-material interface
controlled by the mass transfer coefficient h. A Henri-like coefficient k0 controls the eventual
partitioning of the substance between the food and the layer of the materials.</p>
<p>Food are geometrically defined by their volume and surface area in contact with the material.</p>
<p>Contact time (contacttime) and contact temperature (contacttemperature) are defined via foodlayer.</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class foodlayer(foodphysics):
    &#34;&#34;&#34;
    Foodlayer class is a generic class to define food as a 1D layer in a symmetric manner with layer class
    applicable to materials in contact.
    Since mass transfer are much faster in the food than in the materials in contact, food is represented
    as an almost 0D layer. Only a mass transfer resistance is applied at the food-material interface
    controlled by the mass transfer coefficient h. A Henri-like coefficient k0 controls the eventual
    partitioning of the substance between the food and the layer of the materials.

    Food are geometrically defined by their volume and surface area in contact with the material.

    Contact time (contacttime) and contact temperature (contacttemperature) are defined via foodlayer.

    &#34;&#34;&#34;
    level = &#34;root&#34;
    description = &#34;root food class&#34;  # Remains as class attribute
    name = &#34;generic food layer&#34;
    volume,volumeUnits = check_units((1,&#34;dm**3&#34;))
    surfacearea,surfaceareaUnits = check_units((6,&#34;dm**2&#34;))
    density,densityUnits = check_units((1000,&#34;kg/m**3&#34;))
    CF0,CF0units = check_units((0,NoUnits))  # initial concentration (arbitrary units)
    contacttime, contacttime_units = check_units((10,&#34;days&#34;))
    contactemperature,contactemperatureUnits = check_units((40,&#34;degC&#34;),ExpectedUnits=&#34;degC&#34;) # temperature ALWAYS in °C</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>patankar.food.foodphysics</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>patankar.food.foodproperty</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="migration.foodlayer.CF0"><code class="name">var <span class="ident">CF0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.CF0units"><code class="name">var <span class="ident">CF0units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.contactemperature"><code class="name">var <span class="ident">contactemperature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.contactemperatureUnits"><code class="name">var <span class="ident">contactemperatureUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.contacttime"><code class="name">var <span class="ident">contacttime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.contacttime_units"><code class="name">var <span class="ident">contacttime_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.density"><code class="name">var <span class="ident">density</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.densityUnits"><code class="name">var <span class="ident">densityUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.surfacearea"><code class="name">var <span class="ident">surfacearea</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.surfaceareaUnits"><code class="name">var <span class="ident">surfaceareaUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.volume"><code class="name">var <span class="ident">volume</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodlayer.volumeUnits"><code class="name">var <span class="ident">volumeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="migration.foodphysics"><code class="flex name class">
<span>class <span class="ident">foodphysics</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class that automatically assigns instance attributes from class defaults,
except for the 'description' attribute.
Check the physical meaning of quantities with units.</p>
<p>Implemented methods include:
- refresh() validates all quantities before a simulation
- update(name="new name", description="new description",parameter1=value)
assigns new values to physical parameters and attributes
- getparam() returns physical parameters even if they undefined
Available properties:
PBC returns True in periodic boundary conditions are enforced (setoff)
impervious returns True if impervious boundary condition is appled (no food)</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class foodphysics:
    &#34;&#34;&#34;
    Base class that automatically assigns instance attributes from class defaults,
    except for the &#39;description&#39; attribute.
    Check the physical meaning of quantities with units.

    Implemented methods include:
        - refresh() validates all quantities before a simulation
        - update(name=&#34;new name&#34;, description=&#34;new description&#34;,parameter1=value)
          assigns new values to physical parameters and attributes
        - getparam() returns physical parameters even if they undefined
    Available properties:
        PBC returns True in periodic boundary conditions are enforced (setoff)
        impervious returns True if impervious boundary condition is appled (no food)
    &#34;&#34;&#34;

    # General descriptors
    description = &#34;Root physics class used to implement food and mass transfer physics&#34;  # Remains as class attribute
    name = &#34;food physics&#34;
    level = &#34;base&#34;

    # ------------------------------------------------------
    # Transfer rules for food1 &gt;&gt; food2 and food1 &gt;&gt; result
    # ------------------------------------------------------

    # Mapping of properties to their respective categories
    _list_categories = {
        &#34;contacttemperature&#34;: &#34;contact&#34;,
        &#34;contacttime&#34;: &#34;contact&#34;,
        &#34;surfacearea&#34;: &#34;geometry&#34;,
        &#34;volume&#34;: &#34;geometry&#34;
    }

    # Rules for property transfer based on object type
    _transferable_properties = {
        &#34;contacttemperature&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: True,
                &#34;checkNumPy&#34;: False,
                &#34;as&#34;: &#34;&#34;,
                &#34;prototype&#34;: None,
                &#34;category&#34;: &#34;contact&#34;
            },
            &#34;layer&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;T&#34;,
                &#34;prototype&#34;: None
            }
        },
        &#34;contacttime&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: True,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;&#34;,
                &#34;prototype&#34;: None
            },
            &#34;SensPatankarResult&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;t&#34;,
                &#34;prototype&#34;: None
            }
        },
        &#34;surfacearea&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: False,
                &#34;as&#34;: &#34;surfacearea&#34;,
                &#34;prototype&#34;: None
            }
        },
        &#34;volume&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;&#34;,
                &#34;prototype&#34;: None
            }
        }
    }


    def __init__(self, **kwargs):
        &#34;&#34;&#34;general constructor&#34;&#34;&#34;

        # local import
        from patankar.migration import SensPatankarResult

        # numeric validator
        def numvalidator(key,value):
            if key in parametersWithUnits:          # the parameter is a physical quantity
                if isinstance(value,tuple):         # the supplied value as unit
                    value,_ = check_units(value)    # we convert to SI, we drop the units
                if not isinstance(value,np.ndarray):
                    value = np.array([value])       # we force NumPy class
            return value

        # Iterate through the MRO (excluding foodphysics and object)
        for cls in reversed(self.__class__.__mro__):
            if cls in (foodphysics, object):
                continue
            # For each attribute defined at the class level,
            # if it is not &#39;description&#39;, not callable, and not a dunder, set it as an instance attribute.
            for key, value in cls.__dict__.items(): # we loop on class attributes
                if key in (&#34;description&#34;,&#34;level&#34;) or key.startswith(&#34;__&#34;) or callable(value):
                    continue
                if key not in kwargs:
                    setattr(self, key, numvalidator(key,value))
        # Now update/override with any keyword arguments provided at instantiation.
        for key, value in kwargs.items():
            value = numvalidator(key,value)
            if key not in paramaterNamesWithUnits: # we protect the values of units (they are SI, they cannot be changed)
                setattr(self, key, value)
        # we initialize the acknowlegment process for future property propagation
        self._hasbeeninherited = {}
        # we initialize the _simstate storing the last simulation result available
        self._simstate = None # simulation results
        self._inpstate = None # their inputs
        # For cooperative multiple inheritance, call the next __init__ if it exists.
        super().__init__()
        # Define actual class references to avoid circular dependency issues
        if self.__class__._transferable_properties[&#34;contacttemperature&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] is None:
            self.__class__._transferable_properties[&#34;contacttemperature&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics
            self.__class__._transferable_properties[&#34;contacttemperature&#34;][&#34;layer&#34;][&#34;prototype&#34;] = layer
            self.__class__._transferable_properties[&#34;contacttime&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics
            self.__class__._transferable_properties[&#34;contacttime&#34;][&#34;SensPatankarResult&#34;][&#34;prototype&#34;] = SensPatankarResult
            self.__class__._transferable_properties[&#34;surfacearea&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics
            self.__class__._transferable_properties[&#34;volume&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics

    # ------- [properties to access/modify simstate] --------
    @property
    def lastinput(self):
        &#34;&#34;&#34;Getter for last layer input.&#34;&#34;&#34;
        return self._inpstate

    @lastinput.setter
    def lastinput(self, value):
        &#34;&#34;&#34;Setter for last layer input.&#34;&#34;&#34;
        self._inpstate = value

    @property
    def lastsimulation(self):
        &#34;&#34;&#34;Getter for last simulation results.&#34;&#34;&#34;
        return self._simstate

    @lastsimulation.setter
    def lastsimulation(self, value):
        &#34;&#34;&#34;Setter for last simulation results.&#34;&#34;&#34;
        self._simstate = value

    @property
    def hassimulation(self):
        &#34;&#34;&#34;Returns True if a simulation exists&#34;&#34;&#34;
        return self.lastsimulation is not None


    # ------- [inheritance registration mechanism] --------
    def acknowledge(self, what=None, category=None):
        &#34;&#34;&#34;
        Register inherited properties under a given category.

        Parameters:
        -----------
        what : str or list of str or a set
            The properties or attributes that have been inherited.
        category : str
            The category under which the properties are grouped.

        Example:
        --------
        &gt;&gt;&gt; b = B()
        &gt;&gt;&gt; b.acknowledge(what=&#34;volume&#34;, category=&#34;geometry&#34;)
        &gt;&gt;&gt; b.acknowledge(what=[&#34;surfacearea&#34;, &#34;diameter&#34;], category=&#34;geometry&#34;)
        &gt;&gt;&gt; print(b._hasbeeninherited)
        {&#39;geometry&#39;: {&#39;volume&#39;, &#39;surfacearea&#39;, &#39;diameter&#39;}}
        &#34;&#34;&#34;
        if category is None or what is None:
            raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
        if isinstance(what, str):
            what = {what}  # Convert string to a set
        elif isinstance(what, list):
            what = set(what)  # Convert list to a set for uniqueness
        elif not isinstance(what,set):
            raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
        if category not in self._hasbeeninherited:
            self._hasbeeninherited[category] = set()
        self._hasbeeninherited[category].update(what)


    def refresh(self):
        &#34;&#34;&#34;refresh all physcal paramaters after instantiation&#34;&#34;&#34;
        for key, value in self.__dict__.items():    # we loop on instance attributes
            if key in parametersWithUnits:          # the parameter is a physical quantity
                if isinstance(value,tuple):         # the supplied value as unit
                    value = check_units(value)[0]   # we convert to SI, we drop the units
                    setattr(self,key,value)
                if not isinstance(value,np.ndarray):
                    value = np.array([value])      # we force NumPy class
                    setattr(self,key,value)

    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update modifiable parameters of the foodphysics object.

        Modifiable Parameters:
            - name (str): New name for the object.
            - description (str): New description.
            - volume (float or tuple): Volume (can be tuple like (1, &#34;L&#34;)).
            - surfacearea (float or tuple): Surface area (can be tuple like (1, &#34;cm^2&#34;)).
            - density (float or tuple): Density (can be tuple like (1000, &#34;kg/m^3&#34;)).
            - CF0 (float or tuple): Initial concentration in the food.
            - contacttime (float or tuple): Contact time (can be tuple like (1, &#34;h&#34;)).
            - contacttemperature (float or tuple): Temperature (can be tuple like (25, &#34;degC&#34;)).
            - h (float or tuple): Mass transfer coefficient (can be tuple like (1e-6,&#34;m/s&#34;)).
            - k0 (float or tuple): Henri-like coefficient for the food (can be tuple like (1,&#34;a.u.&#34;)).

        &#34;&#34;&#34;
        if not kwargs:  # shortcut
            return self # for chaining
        def checkunits(value):
            &#34;&#34;&#34;Helper function to convert physical quantities to SI.&#34;&#34;&#34;
            if isinstance(value, tuple) and len(value) == 2:
                scale = check_units(value)[0]  # Convert to SI, drop unit
                return np.array([scale], dtype=float)  # Ensure NumPy array
            elif isinstance(value, (int, float, np.ndarray)):
                return np.array([value], dtype=float)  # Ensure NumPy array
            else:
                raise ValueError(f&#34;Invalid value for physical quantity: {value}&#34;)
        # Update `name` and `description` if provided
        if &#34;name&#34; in kwargs:
            self.name = str(kwargs[&#34;name&#34;])
        if &#34;description&#34; in kwargs:
            self.description = str(kwargs[&#34;description&#34;])
        # Update physical properties
        for key in parametersWithUnits.keys():
            if key in kwargs:
                value = kwargs[key]
                setattr(self, key, checkunits(value))  # Ensure NumPy array in SI
        return self  # Return self for method chaining if needed

    def get_param(self, key, default=None, acceptNone=True):
        &#34;&#34;&#34;Retrieve instance attribute with a default fallback if enabled.&#34;&#34;&#34;
        paramdefaultvalue = 1
        if isinstance(self,(setoff,nofood)):
            if key in parametersWithUnits_andfallback:
                value =  self.__dict__.get(key, paramdefaultvalue) if default is None else self.__dict__.get(key, default)
                if isinstance(value,np.ndarray):
                    value = value.item()
                if value is None and not acceptNone:
                    value = paramdefaultvalue if default is None else default
                return np.array([value])
            if key in paramaterNamesWithUnits:
                return self.__dict__.get(key, parametersWithUnits[key]) if default is None else self.__dict__.get(key, default)
        if key in parametersWithUnits:
            if hasattr(self, key):
                return getattr(self,key)
            else:
                raise KeyError(
                    f&#34;Missing property: &#39;{key}&#39; in instance of class &#39;{self.__class__.__name__}&#39;.\n&#34;
                    f&#34;To define it, use one of the following methods:\n&#34;
                    f&#34;  - Direct assignment:   object.{key} = value\n&#34;
                    f&#34;  - Using update method: object.update({key}=value)\n&#34;
                    f&#34;Note: The value can also be provided as a tuple (value, &#39;unit&#39;).&#34;
                )
        elif key in paramaterNamesWithUnits:
            return self.__dict__.get(key, paramaterNamesWithUnits[key]) if default is None else self.__dict__.get(key, default)
        raise KeyError(f&#39;Use getattr(&#34;{key}&#34;) to retrieve the value of {key}&#39;)

    def __repr__(self):
        &#34;&#34;&#34;Formatted string representation of the foodphysics object.&#34;&#34;&#34;
        # refresh all definitions
        self.refresh()
        # Header with name and description
        repr_str = f&#39;Food object &#34;{self.name}&#34; ({self.description}) with properties:\n&#39;

        # Helper function to extract a numerical value safely
        def format_value(value):
            &#34;&#34;&#34;Ensure the value is a float or a single-item NumPy array.&#34;&#34;&#34;
            if isinstance(value, np.ndarray):
                return value.item() if value.size == 1 else value[0]  # Ensure scalar representation
            elif value is None:
                return value
            return float(value)
        # Loop through parameters that should be printed
        for key, unit in parametersWithUnits.items():
            if hasattr(self, key):  # Print only defined parameters
                value = format_value(getattr(self, key))
                unit_str = self.get_param(key+&#34;Units&#34;, parametersWithUnits[key])  # Retrieve unit safely
                if value is not None:
                    repr_str += f&#34;{key:15s}: {value:0.8g} [{unit_str}]\n&#34;
        print(repr_str.strip())  # Remove trailing newline
        return str(self)


    def __str__(self):
        &#34;&#34;&#34;Formatted string representation of the property&#34;&#34;&#34;
        simstr = &#39; [simulated]&#39; if self.hassimulation else &#34;&#34;
        return f&#34;&lt;{self.__class__.__name__}: {self.name}&gt;{simstr}&#34;

    def copy(self,**kwargs):
        &#34;&#34;&#34;Creates a deep copy of the current food instance.&#34;&#34;&#34;
        return duplicate(self).update(**kwargs)


    @property
    def PBC(self):
        &#34;&#34;&#34;
        Returns true if h is not defined or None
            This property is used to identified periodic boundary condition also called setoff mass transfer.

        &#34;&#34;&#34;
        if not hasattr(self,&#34;h&#34;):
            return None
        htmp = getattr(self,&#34;h&#34;)
        if isinstance(htmp,np.ndarray):
            htmp = htmp.item()
        return htmp is None


    # --------------------------------------------------------------------
    # For convenience, several operators have been overloaded
    #   medium &gt;&gt; packaging      # sets the volume and the surfacearea
    #   medium &gt;&gt; material       # propgates the contact temperature from the medium to the material
    #   sol = medium &lt;&lt; material # simulate migration from the material to the medium
    # --------------------------------------------------------------------

    # method: medium._to(material) and its associated operator &gt;&gt;
    def _to(self, other = None):
        &#34;&#34;&#34;
        Transfers inherited properties to another object based on predefined rules.

        Parameters:
        -----------
        other : object
            The recipient object that will receive the transferred properties.

        Notes:
        ------
        - Only properties listed in `_transferable_properties` are transferred.
        - A property can only be transferred if `other` matches the expected class.
        - The property may have a different name in `other` as defined in `as`.
        - If `onlyifinherited` is True, the property must have been inherited by `self`.
        - If `checkNumPy` is True, ensures NumPy array compatibility.
        - Updates `other`&#39;s `_hasbeeninherited` tracking.
        &#34;&#34;&#34;
        for prop, classes in self._transferable_properties.items():
            if prop not in self._list_categories:
                continue  # Skip properties not categorized

            category = self._list_categories[prop]

            for class_name, rules in classes.items():

                if not isinstance(other, rules[&#34;prototype&#34;]):
                    continue  # Skip if other is not an instance of the expected prototype class

                if rules[&#34;onlyifinherited&#34;] and category not in self._hasbeeninherited:
                    continue  # Skip if property must be inherited but is not

                if rules[&#34;onlyifinherited&#34;] and prop not in self._hasbeeninherited[category]:
                    continue  # Skip if the specific property has not been inherited

                if not hasattr(self, prop):
                    continue  # Skip if the property does not exist on self

                # Determine the target attribute name in other
                target_attr = rules[&#34;as&#34;] if rules[&#34;as&#34;] else prop

                # Retrieve the property value
                value = getattr(self, prop)

                # Handle NumPy array check
                if rules[&#34;checkNumPy&#34;] and hasattr(other, target_attr):
                    existing_value = getattr(other, target_attr)
                    if isinstance(existing_value, np.ndarray):
                        value = np.full(existing_value.shape, value)

                # Assign the value to other
                setattr(other, target_attr, value)

                # Register the transfer in other’s inheritance tracking
                other.acknowledge(what=target_attr, category=category)

                # to chain &gt;&gt;
                return other

    def __rshift__(self, other):
        &#34;&#34;&#34;Overloads &gt;&gt; to propagate to other.&#34;&#34;&#34;
        return self._to(other)

    # migration method
    def migration(self,material,**kwargs):
        from patankar.migration import senspatankar
        self._to(material) # propagate contact conditions first
        return senspatankar(material,self,**kwargs)

    def contact(self,material,**kwargs):
        return self.migration(self,material,**kwargs)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>patankar.food.chemicalaffinity</li>
<li>patankar.food.foodlayer</li>
<li>patankar.food.nofood</li>
<li>patankar.food.realcontact</li>
<li>patankar.food.setoff</li>
<li>patankar.food.testcontact</li>
<li>patankar.food.texture</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="migration.foodphysics.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodphysics.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="migration.foodphysics.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="migration.foodphysics.PBC"><code class="name">var <span class="ident">PBC</span></code></dt>
<dd>
<div class="desc"><p>Returns true if h is not defined or None
This property is used to identified periodic boundary condition also called setoff mass transfer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def PBC(self):
    &#34;&#34;&#34;
    Returns true if h is not defined or None
        This property is used to identified periodic boundary condition also called setoff mass transfer.

    &#34;&#34;&#34;
    if not hasattr(self,&#34;h&#34;):
        return None
    htmp = getattr(self,&#34;h&#34;)
    if isinstance(htmp,np.ndarray):
        htmp = htmp.item()
    return htmp is None</code></pre>
</details>
</dd>
<dt id="migration.foodphysics.hassimulation"><code class="name">var <span class="ident">hassimulation</span></code></dt>
<dd>
<div class="desc"><p>Returns True if a simulation exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hassimulation(self):
    &#34;&#34;&#34;Returns True if a simulation exists&#34;&#34;&#34;
    return self.lastsimulation is not None</code></pre>
</details>
</dd>
<dt id="migration.foodphysics.lastinput"><code class="name">var <span class="ident">lastinput</span></code></dt>
<dd>
<div class="desc"><p>Getter for last layer input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lastinput(self):
    &#34;&#34;&#34;Getter for last layer input.&#34;&#34;&#34;
    return self._inpstate</code></pre>
</details>
</dd>
<dt id="migration.foodphysics.lastsimulation"><code class="name">var <span class="ident">lastsimulation</span></code></dt>
<dd>
<div class="desc"><p>Getter for last simulation results.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lastsimulation(self):
    &#34;&#34;&#34;Getter for last simulation results.&#34;&#34;&#34;
    return self._simstate</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="migration.foodphysics.acknowledge"><code class="name flex">
<span>def <span class="ident">acknowledge</span></span>(<span>self, what=None, category=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Register inherited properties under a given category.</p>
<h2 id="parameters">Parameters:</h2>
<p>what : str or list of str or a set
The properties or attributes that have been inherited.
category : str
The category under which the properties are grouped.</p>
<h2 id="example">Example:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; b = B()
&gt;&gt;&gt; b.acknowledge(what=&quot;volume&quot;, category=&quot;geometry&quot;)
&gt;&gt;&gt; b.acknowledge(what=[&quot;surfacearea&quot;, &quot;diameter&quot;], category=&quot;geometry&quot;)
&gt;&gt;&gt; print(b._hasbeeninherited)
{'geometry': {'volume', 'surfacearea', 'diameter'}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acknowledge(self, what=None, category=None):
    &#34;&#34;&#34;
    Register inherited properties under a given category.

    Parameters:
    -----------
    what : str or list of str or a set
        The properties or attributes that have been inherited.
    category : str
        The category under which the properties are grouped.

    Example:
    --------
    &gt;&gt;&gt; b = B()
    &gt;&gt;&gt; b.acknowledge(what=&#34;volume&#34;, category=&#34;geometry&#34;)
    &gt;&gt;&gt; b.acknowledge(what=[&#34;surfacearea&#34;, &#34;diameter&#34;], category=&#34;geometry&#34;)
    &gt;&gt;&gt; print(b._hasbeeninherited)
    {&#39;geometry&#39;: {&#39;volume&#39;, &#39;surfacearea&#39;, &#39;diameter&#39;}}
    &#34;&#34;&#34;
    if category is None or what is None:
        raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
    if isinstance(what, str):
        what = {what}  # Convert string to a set
    elif isinstance(what, list):
        what = set(what)  # Convert list to a set for uniqueness
    elif not isinstance(what,set):
        raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
    if category not in self._hasbeeninherited:
        self._hasbeeninherited[category] = set()
    self._hasbeeninherited[category].update(what)</code></pre>
</details>
</dd>
<dt id="migration.foodphysics.contact"><code class="name flex">
<span>def <span class="ident">contact</span></span>(<span>self, material, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contact(self,material,**kwargs):
    return self.migration(self,material,**kwargs)</code></pre>
</details>
</dd>
<dt id="migration.foodphysics.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a deep copy of the current food instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self,**kwargs):
    &#34;&#34;&#34;Creates a deep copy of the current food instance.&#34;&#34;&#34;
    return duplicate(self).update(**kwargs)</code></pre>
</details>
</dd>
<dt id="migration.foodphysics.get_param"><code class="name flex">
<span>def <span class="ident">get_param</span></span>(<span>self, key, default=None, acceptNone=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve instance attribute with a default fallback if enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_param(self, key, default=None, acceptNone=True):
    &#34;&#34;&#34;Retrieve instance attribute with a default fallback if enabled.&#34;&#34;&#34;
    paramdefaultvalue = 1
    if isinstance(self,(setoff,nofood)):
        if key in parametersWithUnits_andfallback:
            value =  self.__dict__.get(key, paramdefaultvalue) if default is None else self.__dict__.get(key, default)
            if isinstance(value,np.ndarray):
                value = value.item()
            if value is None and not acceptNone:
                value = paramdefaultvalue if default is None else default
            return np.array([value])
        if key in paramaterNamesWithUnits:
            return self.__dict__.get(key, parametersWithUnits[key]) if default is None else self.__dict__.get(key, default)
    if key in parametersWithUnits:
        if hasattr(self, key):
            return getattr(self,key)
        else:
            raise KeyError(
                f&#34;Missing property: &#39;{key}&#39; in instance of class &#39;{self.__class__.__name__}&#39;.\n&#34;
                f&#34;To define it, use one of the following methods:\n&#34;
                f&#34;  - Direct assignment:   object.{key} = value\n&#34;
                f&#34;  - Using update method: object.update({key}=value)\n&#34;
                f&#34;Note: The value can also be provided as a tuple (value, &#39;unit&#39;).&#34;
            )
    elif key in paramaterNamesWithUnits:
        return self.__dict__.get(key, paramaterNamesWithUnits[key]) if default is None else self.__dict__.get(key, default)
    raise KeyError(f&#39;Use getattr(&#34;{key}&#34;) to retrieve the value of {key}&#39;)</code></pre>
</details>
</dd>
<dt id="migration.foodphysics.migration"><code class="name flex">
<span>def <span class="ident">migration</span></span>(<span>self, material, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def migration(self,material,**kwargs):
    from patankar.migration import senspatankar
    self._to(material) # propagate contact conditions first
    return senspatankar(material,self,**kwargs)</code></pre>
</details>
</dd>
<dt id="migration.foodphysics.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>refresh all physcal paramaters after instantiation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;refresh all physcal paramaters after instantiation&#34;&#34;&#34;
    for key, value in self.__dict__.items():    # we loop on instance attributes
        if key in parametersWithUnits:          # the parameter is a physical quantity
            if isinstance(value,tuple):         # the supplied value as unit
                value = check_units(value)[0]   # we convert to SI, we drop the units
                setattr(self,key,value)
            if not isinstance(value,np.ndarray):
                value = np.array([value])      # we force NumPy class
                setattr(self,key,value)</code></pre>
</details>
</dd>
<dt id="migration.foodphysics.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update modifiable parameters of the foodphysics object.</p>
<p>Modifiable Parameters:
- name (str): New name for the object.
- description (str): New description.
- volume (float or tuple): Volume (can be tuple like (1, "L")).
- surfacearea (float or tuple): Surface area (can be tuple like (1, "cm^2")).
- density (float or tuple): Density (can be tuple like (1000, "kg/m^3")).
- CF0 (float or tuple): Initial concentration in the food.
- contacttime (float or tuple): Contact time (can be tuple like (1, "h")).
- contacttemperature (float or tuple): Temperature (can be tuple like (25, "degC")).
- h (float or tuple): Mass transfer coefficient (can be tuple like (1e-6,"m/s")).
- k0 (float or tuple): Henri-like coefficient for the food (can be tuple like (1,"a.u.")).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update modifiable parameters of the foodphysics object.

    Modifiable Parameters:
        - name (str): New name for the object.
        - description (str): New description.
        - volume (float or tuple): Volume (can be tuple like (1, &#34;L&#34;)).
        - surfacearea (float or tuple): Surface area (can be tuple like (1, &#34;cm^2&#34;)).
        - density (float or tuple): Density (can be tuple like (1000, &#34;kg/m^3&#34;)).
        - CF0 (float or tuple): Initial concentration in the food.
        - contacttime (float or tuple): Contact time (can be tuple like (1, &#34;h&#34;)).
        - contacttemperature (float or tuple): Temperature (can be tuple like (25, &#34;degC&#34;)).
        - h (float or tuple): Mass transfer coefficient (can be tuple like (1e-6,&#34;m/s&#34;)).
        - k0 (float or tuple): Henri-like coefficient for the food (can be tuple like (1,&#34;a.u.&#34;)).

    &#34;&#34;&#34;
    if not kwargs:  # shortcut
        return self # for chaining
    def checkunits(value):
        &#34;&#34;&#34;Helper function to convert physical quantities to SI.&#34;&#34;&#34;
        if isinstance(value, tuple) and len(value) == 2:
            scale = check_units(value)[0]  # Convert to SI, drop unit
            return np.array([scale], dtype=float)  # Ensure NumPy array
        elif isinstance(value, (int, float, np.ndarray)):
            return np.array([value], dtype=float)  # Ensure NumPy array
        else:
            raise ValueError(f&#34;Invalid value for physical quantity: {value}&#34;)
    # Update `name` and `description` if provided
    if &#34;name&#34; in kwargs:
        self.name = str(kwargs[&#34;name&#34;])
    if &#34;description&#34; in kwargs:
        self.description = str(kwargs[&#34;description&#34;])
    # Update physical properties
    for key in parametersWithUnits.keys():
        if key in kwargs:
            value = kwargs[key]
            setattr(self, key, checkunits(value))  # Ensure NumPy array in SI
    return self  # Return self for method chaining if needed</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="migration.layer"><code class="flex name class">
<span>class <span class="ident">layer</span></span>
<span>(</span><span>l=None, D=None, k=None, C0=None, rho=None, T=None, lunit=None, Dunit=None, kunit=None, Cunit=None, rhounit=None, Tunit=None, layername=None, layertype=None, layermaterial=None, layercode=None, substance=None, Dmodel=None, kmodel=None, nmesh=None, nmeshmin=None, verbose=None, verbosity=2, **unresolved)</span>
</code></dt>
<dd>
<div class="desc"><p>layer class from patankar package
&hellip;
strings properties: layername, layertype, layermaterial
scalar properties: D,k,l,C0
&hellip;</p>
<h2 id="example">Example</h2>
<p>A = layer(D=1e-14,l=50e-6,layername="layer A",layertype="polymer",layermaterial="PP")</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layername</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Name. The default is "my layer".</dd>
<dt><strong><code>layertype</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Type. The default is "unknown type".</dd>
<dt><strong><code>layermaterial</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Material identification . The default is "unknown material".</dd>
<dt>PHYSICAL QUANTITIES</dt>
<dt><strong><code>l</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Thickness. The default is 50e-6 (m).</dd>
<dt><strong><code>D</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).</dd>
<dt><strong><code>C0</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Initial concentration. The default is 1000 (a.u.).</dd>
<dt>PHYSICAL UNITS</dt>
<dt><strong><code>lunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Length units. The default unit is "m.</dd>
<dt><strong><code>Dunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Diffusivity units. The default unit is 1e-14 "m^2/s".</dd>
<dt><strong><code>kunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default unit is "a.u.".</dd>
<dt><strong><code>Cunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Initial concentration. The default unit is "a.u.".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>a monolayer object which can be assembled into a multilayer structure</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class layer:
    &#34;&#34;&#34;
        layer class from patankar package
        ...
        strings properties: layername, layertype, layermaterial
        scalar properties: D,k,l,C0
        ...
        Example:
            A = layer(D=1e-14,l=50e-6,layername=&#34;layer A&#34;,layertype=&#34;polymer&#34;,layermaterial=&#34;PP&#34;)
    &#34;&#34;&#34;
    # --------------------------------------------------------------------
    # PRIVATE PROPERTIES (cannot be changed by the user)
    # __ read only attributes
    #  _ private attributes (not public)
    # --------------------------------------------------------------------
    __description = &#34;LAYER object&#34;                # description
    __version = 1.0                               # version
    __contact = &#34;olivier.vitrac@agroparistech.fr&#34; # contact person
    _printformat = &#34;%0.4g&#34;   # format to display D, k, l values


    # Synonyms dictionary: Maps alternative names to the actual parameter
    # these synonyms can be used during construction
    _synonyms = {
        &#34;substance&#34;: {&#34;migrant&#34;, &#34;compound&#34;, &#34;chemical&#34;,&#34;molecule&#34;,&#34;solute&#34;},
        &#34;C0&#34;: {&#34;CP0&#34;, &#34;Cp0&#34;},
        &#34;l&#34;: {&#34;lp&#34;, &#34;lP&#34;},
        &#34;D&#34;: {&#34;Dp&#34;, &#34;DP&#34;},
        &#34;k&#34;: {&#34;kp&#34;, &#34;kP&#34;},
        &#34;T&#34;: {&#34;temp&#34;,&#34;Temp&#34;,&#34;temperature&#34;,&#34;Temperature&#34;,
              &#34;contacttemperature&#34;,&#34;ContactTemperature&#34;,&#34;contactTemperature&#34;}
    }
    # Default values for parameters (note that Td cannot be changed by the end-user)
    _defaults = {
        &#34;l&#34;: 5e-5,   # Thickness (m)
        &#34;D&#34;: 1e-14,  # Diffusion coefficient (m^2/s)
        &#34;k&#34;: 1.0,      # Henri-like coefficient (dimensionless)
        &#34;C0&#34;: 1000,  # Initial concentration (arbitrary units)
        &#34;rho&#34;: 1000, # Default density (kg/m³)
        &#34;T&#34;: 40.0,     # Default temperature (°C)
        &#34;Td&#34;: 25.0,    # Reference temperature for densities (°C)
        # Units (do not change)
        &#34;lunit&#34;: &#34;m&#34;,
        &#34;Dunit&#34;: &#34;m**2/s&#34;,
        &#34;kunit&#34;: &#34;a.u.&#34;,  # NoUnits
        &#34;Cunit&#34;: &#34;a.u.&#34;,  # NoUnits
        &#34;rhounit&#34;: &#34;kg/m**3&#34;,
        &#34;Tunit&#34;: &#34;degC&#34;,  # Temperatures are indicated in °C instead of K (to reduce end-user mistakes)
        # Layer properties
        &#34;layername&#34;: &#34;my layer&#34;,
        &#34;layertype&#34;: &#34;unknown type&#34;,
        &#34;layermaterial&#34;: &#34;unknown material&#34;,
        &#34;layercode&#34;: &#34;N/A&#34;,
        # Mesh parameters
        &#34;nmeshmin&#34;: 20,
        &#34;nmesh&#34;: 600,
        # Substance
        &#34;substance&#34;: None,
        # Other parameters
        &#34;verbose&#34;: None,
        &#34;verbosity&#34;: 2
    }

    # List units
    _parametersWithUnits = {
        &#34;l&#34;: &#34;m&#34;,
        &#34;D&#34;: &#34;m**2/s&#34;,
        &#34;k&#34;: &#34;a.u.&#34;,
        &#34;C&#34;: &#34;a.u.&#34;,
        &#34;rhp&#34;: &#34;kg/m**3&#34;,
        &#34;T&#34;: &#34;degC&#34;,
        }

    # Brief descriptions for each parameter
    _descriptionInputs = {
        &#34;l&#34;: &#34;Thickness of the layer (m)&#34;,
        &#34;D&#34;: &#34;Diffusion coefficient (m²/s)&#34;,
        &#34;k&#34;: &#34;Henri-like coefficient (dimensionless)&#34;,
        &#34;C0&#34;: &#34;Initial concentration (arbitrary units)&#34;,
        &#34;rho&#34;: &#34;Density of the material (kg/m³)&#34;,
        &#34;T&#34;: &#34;Layer temperature (°C)&#34;,
        &#34;Td&#34;: &#34;Reference temperature for densities (°C)&#34;,
        &#34;lunit&#34;: &#34;Unit of thickness (default: m)&#34;,
        &#34;Dunit&#34;: &#34;Unit of diffusion coefficient (default: m²/s)&#34;,
        &#34;kunit&#34;: &#34;Unit of Henri-like coefficient (default: a.u.)&#34;,
        &#34;Cunit&#34;: &#34;Unit of initial concentration (default: a.u.)&#34;,
        &#34;rhounit&#34;: &#34;Unit of density (default: kg/m³)&#34;,
        &#34;Tunit&#34;: &#34;Unit of temperature (default: degC)&#34;,
        &#34;layername&#34;: &#34;Name of the layer&#34;,
        &#34;layertype&#34;: &#34;Type of layer (e.g., polymer, ink, air)&#34;,
        &#34;layermaterial&#34;: &#34;Material composition of the layer&#34;,
        &#34;layercode&#34;: &#34;Identification code for the layer&#34;,
        &#34;nmeshmin&#34;: &#34;Minimum number of FV mesh elements for the layer&#34;,
        &#34;nmesh&#34;: &#34;Number of FV mesh elements for numerical computation&#34;,
        &#34;verbose&#34;: &#34;Verbose mode (None or boolean)&#34;,
        &#34;verbosity&#34;: &#34;Level of verbosity for debug messages (integer)&#34;
    }

    # --------------------------------------------------------------------
    # CONSTRUCTOR OF INSTANCE PROPERTIES
    # None = missing numeric value (managed by default)
    # --------------------------------------------------------------------
    def __init__(self,
                 l=None, D=None, k=None, C0=None, rho=None, T=None,
                 lunit=None, Dunit=None, kunit=None, Cunit=None, rhounit=None, Tunit=None,
                 layername=None,layertype=None,layermaterial=None,layercode=None,
                 substance = None, Dmodel = None, kmodel = None,
                 nmesh=None, nmeshmin=None,
                 verbose=None, verbosity=2,**unresolved):
        &#34;&#34;&#34;

        Parameters
        ----------

        layername : TYPE, optional, string
                    DESCRIPTION. Layer Name. The default is &#34;my layer&#34;.
        layertype : TYPE, optional, string
                    DESCRIPTION. Layer Type. The default is &#34;unknown type&#34;.
        layermaterial : TYPE, optional, string
                        DESCRIPTION. Material identification . The default is &#34;unknown material&#34;.
        PHYSICAL QUANTITIES
        l : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Thickness. The default is 50e-6 (m).
        D : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).
        k : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).
        C0 : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Initial concentration. The default is 1000 (a.u.).
        PHYSICAL UNITS
        lunit : TYPE, optional, string
                DESCRIPTION. Length units. The default unit is &#34;m.
        Dunit : TYPE, optional, string
                DESCRIPTION. Diffusivity units. The default unit is 1e-14 &#34;m^2/s&#34;.
        kunit : TYPE, optional, string
                DESCRIPTION. Henry-like coefficient. The default unit is &#34;a.u.&#34;.
        Cunit : TYPE, optional, string
                DESCRIPTION. Initial concentration. The default unit is &#34;a.u.&#34;.
        Returns
        -------
        a monolayer object which can be assembled into a multilayer structure

        &#34;&#34;&#34;
        # resolve alternative names used by end-users
        substance = layer.resolvename(substance,&#34;substance&#34;,**unresolved)
        C0 = layer.resolvename(C0,&#34;C0&#34;,**unresolved)
        l = layer.resolvename(l,&#34;l&#34;,**unresolved)
        D = layer.resolvename(D,&#34;D&#34;,**unresolved)
        k = layer.resolvename(k,&#34;k&#34;,**unresolved)
        T = layer.resolvename(T,&#34;T&#34;,**unresolved)

        # Assign defaults only if values are not provided
        l = l if l is not None else layer._defaults[&#34;l&#34;]
        D = D if D is not None else layer._defaults[&#34;D&#34;]
        k = k if k is not None else layer._defaults[&#34;k&#34;]
        C0 = C0 if C0 is not None else layer._defaults[&#34;C0&#34;]
        rho = rho if rho is not None else layer._defaults[&#34;rho&#34;]
        T = T if T is not None else layer._defaults[&#34;T&#34;]
        lunit = lunit if lunit is not None else layer._defaults[&#34;lunit&#34;]
        Dunit = Dunit if Dunit is not None else layer._defaults[&#34;Dunit&#34;]
        kunit = kunit if kunit is not None else layer._defaults[&#34;kunit&#34;]
        Cunit = Cunit if Cunit is not None else layer._defaults[&#34;Cunit&#34;]
        rhounit = rhounit if rhounit is not None else layer._defaults[&#34;rhounit&#34;]
        Tunit = Tunit if Tunit is not None else layer._defaults[&#34;Tunit&#34;]
        nmesh = nmesh if nmesh is not None else layer._defaults[&#34;nmesh&#34;]
        nmeshmin = nmeshmin if nmeshmin is not None else layer._defaults[&#34;nmeshmin&#34;]
        verbose = verbose if verbose is not None else layer._defaults[&#34;verbose&#34;]
        verbosity = verbosity if verbosity is not None else layer._defaults[&#34;verbosity&#34;]

        # Assign layer id properties
        layername = layername if layername is not None else layer._defaults[&#34;layername&#34;]
        layertype = layertype if layertype is not None else layer._defaults[&#34;layertype&#34;]
        layermaterial = layermaterial if layermaterial is not None else layer._defaults[&#34;layermaterial&#34;]
        layercode = layercode if layercode is not None else layer._defaults[&#34;layercode&#34;]

        # validate all physical paramaters with their units
        l,lunit = check_units(l,lunit,layer._defaults[&#34;lunit&#34;])
        D,Dunit = check_units(D,Dunit,layer._defaults[&#34;Dunit&#34;])
        k,kunit = check_units(k,kunit,layer._defaults[&#34;kunit&#34;])
        C0,Cunit = check_units(C0,Cunit,layer._defaults[&#34;Cunit&#34;])
        rho,rhounit = check_units(rho,rhounit,layer._defaults[&#34;rhounit&#34;])
        T,Tunit = check_units(T,Tunit,layer._defaults[&#34;Tunit&#34;])

        # set attributes: id and physical properties
        self._name = [layername]
        self._type = [layertype]
        self._material = [layermaterial]
        self._code = [layercode]
        self._nlayer = 1
        self._l = l[:1]
        self._D = D[:1]
        self._k = k[:1]
        self._C0 = C0[:1]
        self._rho = rho[:1]
        self._T = T
        self._lunit = lunit
        self._Dunit = Dunit
        self._kunit = kunit
        self._Cunit = Cunit
        self._rhounit = rhounit
        self._Tunit = Tunit
        self._nmesh = nmesh
        self._nmeshmin = nmeshmin

        # set substance and property models
        self._substance = substance

        # set history for all layers merged with +
        self._layerclass_history = []

        # set verbosity attributes
        self.verbosity = 0 if verbosity is None else verbosity
        self.verbose = verbosity&gt;0 if verbose is None else verbose

        # we initialize the acknowlegment process for future property propagation
        self._hasbeeninherited = {}

    # --------------------------------------------------------------------
    # Class method returning help() for the end user
    # --------------------------------------------------------------------
    @classmethod
    def help(cls):
        &#34;&#34;&#34;
        Prints a dynamically formatted summary of all input parameters,
        adjusting column widths based on content and wrapping long descriptions.
        &#34;&#34;&#34;

        # Column Headers
        headers = [&#34;Parameter&#34;, &#34;Default Value&#34;, &#34;Has Synonyms?&#34;, &#34;Description&#34;]
        col_widths = [len(h) for h in headers]  # Start with header widths

        # Collect Data Rows
        rows = []
        for param, default in cls._defaults.items():
            has_synonyms = &#34;✅ Yes&#34; if param in cls._synonyms else &#34;❌ No&#34;
            description = cls._descriptionInputs.get(param, &#34;No description available&#34;)

            # Update column widths dynamically
            col_widths[0] = max(col_widths[0], len(param))
            col_widths[1] = max(col_widths[1], len(str(default)))
            col_widths[2] = max(col_widths[2], len(has_synonyms))
            col_widths[3] = max(col_widths[3], len(description))

            rows.append([param, str(default), has_synonyms, description])

        # Function to wrap text for a given column width
        def wrap_text(text, width):
            return textwrap.fill(text, width)

        # Print Table with Adjusted Column Widths
        separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in col_widths) + &#34;-+&#34;
        print(&#34;\n### **Accepted Parameters and Defaults**\n&#34;)
        print(separator)
        print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(col_widths[i]) for i, h in enumerate(headers)) + &#34; |&#34;)
        print(separator)
        for row in rows:
            # Wrap text in the description column
            row[3] = wrap_text(row[3], col_widths[3])

            # Print row
            print(&#34;| &#34; + &#34; | &#34;.join(row[i].ljust(col_widths[i]) for i in range(3)) + &#34; | &#34; + row[3])
        print(separator)

        # Synonyms Table
        print(&#34;\n### **Parameter Synonyms**\n&#34;)
        syn_headers = [&#34;Parameter&#34;, &#34;Synonyms&#34;]
        syn_col_widths = [
            max(len(&#34;Parameter&#34;), max(len(k) for k in cls._synonyms.keys())),  # Ensure it fits &#34;Parameter&#34;
            max(len(&#34;Synonyms&#34;), max(len(&#34;, &#34;.join(v)) for v in cls._synonyms.values()))  # Ensure it fits &#34;Synonyms&#34;
        ]
        syn_separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in syn_col_widths) + &#34;-+&#34;
        print(syn_separator)
        print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(syn_col_widths[i]) for i, h in enumerate(syn_headers)) + &#34; |&#34;)
        print(syn_separator)
        for param, synonyms in cls._synonyms.items():
            print(f&#34;| {param.ljust(syn_col_widths[0])} | {&#39;, &#39;.join(synonyms).ljust(syn_col_widths[1])} |&#34;)
        print(syn_separator)


    # --------------------------------------------------------------------
    # Class method to handle ambiguous definition from end-user
    # --------------------------------------------------------------------
    @classmethod
    def resolvename(cls, param_value, param_key, **unresolved):
        &#34;&#34;&#34;
        Resolves the correct parameter value using known synonyms.

        - If param_value is already set (not None), return it.
        - If a synonym exists in **unresolved, assign its value.
        - If multiple synonyms of the same parameter appear in **unresolved, raise an error.
        - Otherwise, return None.

        Parameters:
        - `param_name` (any): The original value (if provided).
        - `param_key` (str): The legitimate parameter name we are resolving.
        - `unresolved` (dict): The dictionary of unrecognized keyword arguments.

        Returns:
        - The resolved value or None if not found.
        &#34;&#34;&#34;
        if param_value is not None:
            return param_value  # The parameter is explicitly defined, do not override
        if not unresolved:      # shortcut
            return None
        resolved_value = None
        found_keys = []
        # Check if param_key itself is present in unresolved
        if param_key in unresolved:
            found_keys.append(param_key)
            resolved_value = unresolved[param_key]
        # Check if any of its synonyms are in unresolved
        if param_key in cls._synonyms:
            for synonym in cls._synonyms[param_key]:
                if synonym in unresolved:
                    found_keys.append(synonym)
                    resolved_value = unresolved[synonym]
        # Raise error if multiple synonyms were found
        if len(found_keys) &gt; 1:
            raise ValueError(
                f&#34;Conflicting definitions: Multiple synonyms {found_keys} were provided for &#39;{param_key}&#39;.&#34;
            )
        return resolved_value


    # --------------------------------------------------------------------
    # overloading binary addition (note that the output is of type layer)
    # --------------------------------------------------------------------
    def __add__(self,other):
        &#34;&#34;&#34; C=A+B | overload + operator &#34;&#34;&#34;
        if isinstance(other, layer):
            res = duplicate(self)
            res._nmeshmin = min(self._nmeshmin,other._nmeshmin)
            # propage substance
            if self._substance is None:
                res._substance = other._substance
            else:
                if isinstance(self._substance,migrant) and isinstance(other._substance,migrant):
                    if self._substance.M != other._substance.M:
                        print(&#34;Warning: the smallest subtance is propagated everywhere&#34;)
                    res._substance = self._substance if self._substance.M&lt;=other._substance.M else other._substance
                else:
                    res._substance = None
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_code&#34;,&#34;_nlayer&#34;]:
                setattr(res,p,getattr(self,p)+getattr(other,p))
            for p in [&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;,&#34;_rho&#34;,&#34;_T&#34;]:
                setattr(res,p,np.concatenate((getattr(self,p),getattr(other,p))))
            # we add the history of all layers
            res._layerclass_history = self.layerclass_history + other.layerclass_history
            return res
        else: raise ValueError(&#34;invalid layer object&#34;)


    # --------------------------------------------------------------------
    # overloading binary multiplication (note that the output is of type layer)
    # --------------------------------------------------------------------
    def __mul__(self,ntimes):
        &#34;&#34;&#34; nA = A*n | overload * operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
            res = duplicate(self)
            if ntimes&gt;1:
                for n in range(1,ntimes): res += self
            return res
        else: raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)


    # --------------------------------------------------------------------
    # len method
    # --------------------------------------------------------------------
    def __len__(self):
        &#34;&#34;&#34; length method &#34;&#34;&#34;
        return self._nlayer

    # --------------------------------------------------------------------
    # object indexing (get,set) method
    # --------------------------------------------------------------------
    def __getitem__(self,i):
        &#34;&#34;&#34; get indexing method &#34;&#34;&#34;
        res = duplicate(self)
        # check indices
        isscalar = isinstance(i,int)
        if isinstance(i,slice):
            if i.step==None: j = list(range(i.start,i.stop))
            else: j = list(range(i.start,i.stop,i.step))
            res._nlayer = len(j)
        if isinstance(i,int): res._nlayer = 1
        # pick indices for each property
        for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
            content = getattr(self,p)
            try:
                if isscalar: setattr(res,p,content[i:i+1])
                else: setattr(res,p,content[i])
            except IndexError as err:
                if self.verbosity&gt;0 and self.verbose:
                    print(&#34;bad layer object indexing: &#34;,err)
        return res

    def __setitem__(self,i,other):
        &#34;&#34;&#34; set indexing method &#34;&#34;&#34;
        # check indices
        if isinstance(i,slice):
            if i.step==None: j = list(range(i.start,i.stop))
            else: j = list(range(i.start,i.stop,i.step))
        elif isinstance(i,int): j = [i]
        else:raise IndexError(&#34;invalid index&#34;)
        islayer = isinstance(other,layer)
        isempty = not islayer and isinstance(other,list) and len(other)&lt;1
        if isempty:         # empty right hand side
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
                content = getattr(self,p)
                try:
                    newcontent = [content[k] for k in range(self._nlayer) if k not in j]
                except IndexError as err:
                    if self.verbosity&gt;0 and self.verbose:
                        print(&#34;bad layer object indexing: &#34;,err)
                if isinstance(content,np.ndarray) and not isinstance(newcontent,np.ndarray):
                    newcontent = np.array(newcontent)
                setattr(self,p,newcontent)
            self._nlayer = len(newcontent)
        elif islayer:        # islayer right hand side
            nk1 = len(j)
            nk2 = other._nlayer
            if nk1 != nk2:
                raise IndexError(&#34;the number of elements does not match the number of indices&#34;)
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
                content1 = getattr(self,p)
                content2 = getattr(other,p)
                for k in range(nk1):
                    try:
                        content1[j[k]] = content2[k]
                    except IndexError as err:
                        if self.verbosity&gt;0 and self.verbose:
                            print(&#34;bad layer object indexing: &#34;,err)
                setattr(self,p,content1)
        else:
            raise ValueError(&#34;only [] or layer object are accepted&#34;)


    # --------------------------------------------------------------------
    # Getter methods (show private/hidden properties and meta-properties)
    # --------------------------------------------------------------------
    @property
    def layerclass_history(self):
        return self._layerclass_history if self._layerclass_history != [] else [self.layerclass]
    @property
    def layerclass(self): return type(self).__name__
    @property
    def name(self): return self._name
    @property
    def type(self): return self._type
    @property
    def material(self): return self._material
    @property
    def code(self): return self._code
    @property
    def l(self): return self._l
    @property
    def D(self):
        Dtmp = self.Dmodel()
        if Dtmp is not None:
            return np.full_like(self._D, Dtmp)
        else:
            return self._D
    @property
    def k(self):
        ktmp = self.kmodel()
        if ktmp:
            return np.full_like(self._D, ktmp)
        else:
            return self._k
    @property
    def C0(self): return self._C0
    @property
    def rho(self): return self._rho
    @property
    def T(self): return self._T
    @property
    def TK(self): return self._T+T0K
    @property
    def lunit(self): return self._lunit
    @property
    def Dunit(self): return self._Dunit
    @property
    def kunit(self): return self._kunit
    @property
    def Cunit(self): return self._Cunit
    @property
    def rhounit(self): return self._rhounit
    @property
    def Tunit(self): return self._Tunit
    @property
    def TKunit(self): return &#34;K&#34;
    @property
    def n(self): return self._nlayer
    @property
    def nmesh(self): return self._nmesh
    @property
    def nmeshmin(self): return self._nmeshmin
    @property
    def resistance(self): return self.l*self.k/self.D
    @property
    def permeability(self): return self.D/(self.l*self.k)
    @property
    def lag(self): return self.l**2/(6*self.D)
    @property
    def pressure(self): return self.k*self.C0
    @property
    def thickness(self): return sum(self.l)
    @property
    def concentration(self): return sum(self.l*self.C0)/self.thickness
    @property
    def relative_thickness(self): return self.l/self.thickness
    @property
    def relative_resistance(self): return self.resistance/sum(self.resistance)
    @property
    def rank(self): return np.flip(np.argsort(np.array(self.resistance))+1).tolist()
    @property
    def referencelayer(self): return np.argmax(self.resistance)
    @property
    def lreferencelayer(self): return self.l[self.referencelayer]
    @property
    def Foscale(self): return self.D[self.referencelayer]/self.lreferencelayer**2

    # layer substance (of class migrant or None)
    @property
    def substance(self): return self._substance

    # Dmodel and kmodel returned as properties (they are lambda functions)
    # polymer and mass are udpdated on the fly (the code loops over all layers)
    @property
    def Dmodel(self):
        &#34;&#34;&#34;Return a callable function that evaluates D with updated parameters.&#34;&#34;&#34;
        if not isinstance(self._substance,migrant) or self._substance.Deval() is None:
            return lambda **kwargs: None  # Return a function that always returns None
        template = self._substance.Dtemplate.copy()
        template.update()
        def func(**kwargs):
            D = np.empty_like(self._D)
            for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
                template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
                # inherit eventual user parameters
                D[i] = self._substance.D.evaluate(**dict(template, **kwargs))
            return D
        return func

    @property
    def kmodel(self):
        &#34;&#34;&#34;Return a callable function that evaluates k with updated parameters.&#34;&#34;&#34;
        if not isinstance(self._substance,migrant) or self._substance.keval() is None:
            return lambda **kwargs: None  # Return a function that always returns None
        template = self._substance.ktemplate.copy()
        template.update()
        def func(**kwargs):
            k = np.empty_like(self._k)
            for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
                template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
                # inherit eventual user parameters
                k[i] = self._substance.k.evaluate(**dict(template, **kwargs))
            return k
        return func


    # --------------------------------------------------------------------
    # comparators based resistance
    # --------------------------------------------------------------------
    def __eq__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1==value2

    def __ne__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1!=value2

    def __lt__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&lt;value2

    def __gt__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&gt;value2

    def __le__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&lt;=value2

    def __ge__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&gt;=value2


    # --------------------------------------------------------------------
    # Generates mesh
    # --------------------------------------------------------------------
    def mesh(self,nmesh=None,nmeshmin=None):
        &#34;&#34;&#34; nmesh() generates mesh based on nmesh and nmeshmin, nmesh(nmesh=value,nmeshmin=value) &#34;&#34;&#34;
        if nmesh==None: nmesh = self.nmesh
        if nmeshmin==None: nmeshmin = self.nmeshmin
        if nmeshmin&gt;nmesh: nmeshmin,nmesh = nmesh, nmeshmin
        # X = mesh distribution (number of nodes per layer)
        X = np.ones(self._nlayer)
        for i in range(1,self._nlayer):
           X[i] = X[i-1]*(self.permeability[i-1]*self.l[i])/(self.permeability[i]*self.l[i-1])
        X = np.maximum(nmeshmin,np.ceil(nmesh*X/sum(X)))
        X = np.round((X/sum(X))*nmesh).astype(int)
        # do the mesh
        x0 = 0
        mymesh = []
        for i in range(self._nlayer):
            mymesh.append(mesh(self.l[i]/self.l[self.referencelayer],X[i],x0=x0,index=i))
            x0 += self.l[i]
        return mymesh

    # --------------------------------------------------------------------
    # Getter methods and tools to validate inputs checknumvalue and checktextvalue
    # --------------------------------------------------------------------
    def checknumvalue(self,value,ExpectedUnits=None):
        &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
        if isinstance(value,tuple):
            value = check_units(value,ExpectedUnits=ExpectedUnits)
        if isinstance(value,int): value = float(value)
        if isinstance(value,float): value = np.array([value])
        if isinstance(value,list): value = np.array(value)
        if len(value)&gt;self._nlayer:
            value = value[:self._nlayer]
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the extra value(s) has been removed&#39;)
        elif len(value)&lt;self._nlayer:
            value = np.concatenate((value,value[-1:]*np.ones(self._nlayer-len(value))))
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the last value has been repeated&#39;)
        return value

    def checktextvalue(self,value):
        &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
        if not isinstance(value,list): value = [value]
        if len(value)&gt;self._nlayer:
            value = value[:self._nlayer]
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the extra entry(ies) has been removed&#39;)
        elif len(value)&lt;self._nlayer:
            value = value + value[-1:]*(self._nlayer-len(value))
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the last entry has been repeated&#39;)
        return value

    @l.setter
    def l(self,value): self._l =self.checknumvalue(value,layer._defaults[&#34;lunit&#34;])
    @D.setter
    def D(self,value): self._D=self.checknumvalue(value,layer._defaults[&#34;Dunit&#34;])
    @k.setter
    def k(self,value): self._k =self.checknumvalue(value,layer._defaults[&#34;kunit&#34;])
    @C0.setter
    def C0(self,value): self._C0 =self.checknumvalue(value,layer._defaults[&#34;Cunit&#34;])
    @rho.setter
    def rho(self,value): self._rho =self.checknumvalue(value,layer._defaults[&#34;rhounit&#34;])
    @T.setter
    def T(self,value): self._T =self.checknumvalue(value,layer._defaults[&#34;Tunit&#34;])
    @name.setter
    def name(self,value): self._name =self.checktextvalue(value)
    @type.setter
    def type(self,value): self._type =self.checktextvalue(value)
    @material.setter
    def material(self,value): self._material =self.checktextvalue(value)
    @nmesh.setter
    def nmesh(self,value): self._nmesh = max(value,self._nlayer*self._nmeshmin)
    @nmeshmin.setter
    def nmeshmin(self,value): self._nmeshmin = max(value,round(self._nmesh/(2*self._nlayer)))
    @substance.setter
    def substance(self,value):
        if not isinstance(value,migrant):
            raise TypeError(f&#34;value must be a migrant class not a {type(value).__name__}&#34;)
        self._substance = value


    # --------------------------------------------------------------------
    # hash methods (assembly and layer-by-layer)
    # note that list needs to be converted into tuples to be hashed
    # --------------------------------------------------------------------
    def __hash__(self):
        &#34;&#34;&#34; hash layer-object (assembly) method &#34;&#34;&#34;
        return hash((tuple(self._name),
                     tuple(self._type),
                     tuple(self._material),
                     tuple(self._l),
                     tuple(self._D),
                     tuple(self.k),
                     tuple(self._C0),
                     tuple(self._rho)))

    # layer-by-layer @property = decoration to consider it
    # as a property instead of a method/attribute
    # comprehension for n in range(self._nlayer) applies it to all layers
    @property
    def hashlayer(self):
        &#34;&#34;&#34; hash layer (layer-by-layer) method &#34;&#34;&#34;
        return [hash((self._name[n],
                      self._type[n],
                      self._material[n],
                      self._l[n],
                      self._D[n],
                      self.k[n],
                      self._C0[n],
                      self._rho[n]))
                for n in range(self._nlayer)
                ]


    # --------------------------------------------------------------------
    # repr method (since the getter are defined, the &#39;_&#39; is dropped)
    # --------------------------------------------------------------------
    # density and temperature are not shown
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        print(&#34;\n[%s version=%0.4g, contact=%s]&#34; % (self.__description,self.__version,self.__contact))
        if self._nlayer==0:
            print(&#34;empty %s&#34; % (self.__description))
        else:
            hasDmodel = self.Dmodel() is not None
            haskmodel = self.kmodel() is not None
            properties_ = {&#34;l&#34;:False,&#34;D&#34;:hasDmodel,&#34;k&#34;:haskmodel,&#34;C0&#34;:False}
            if hasDmodel or haskmodel:
                properties_[&#34;T&#34;] = False
            fmtval = &#39;%10s: &#39;+self._printformat+&#34; [%s]&#34;
            fmtstr = &#39;%10s= %s&#39;
            if self._nlayer==1:
                print(f&#39;monolayer of {self.__description}:&#39;)
            else:
                print(f&#39;{self._nlayer}-multilayer of {self.__description}:&#39;)
            for n in range(1,self._nlayer+1):
                modelinfo = {
                    &#34;D&#34;: f&#34;{self._substance.D.__name__}({self.layerclass_history[n-1]},{self._substance},T={float(self.T[0])} {self.Tunit})&#34; if hasDmodel else &#34;&#34;,
                    &#34;k&#34;: f&#34;{self._substance.k.__name__}({self.layerclass_history[n-1]},{self._substance} g/mol,T={float(self.T[0])} {self.Tunit})&#34; if haskmodel else &#34;&#34;,
                    }
                print(&#39;-- [ layer %d of %d ] ---------- barrier rank=%d --------------&#39;
                      % (n,self._nlayer,self.rank[n-1]))
                for p in [&#34;name&#34;,&#34;type&#34;,&#34;material&#34;,&#34;code&#34;]:
                    v = getattr(self,p)
                    print(&#39;%10s: &#34;%s&#34;&#39; % (p,v[n-1]),flush=True)
                for p in properties_.keys():
                    v = getattr(self,p)                 # value
                    vunit = getattr(self,p[0]+&#34;unit&#34;)   # value unit
                    print(fmtval % (p,v[n-1],vunit),flush=True)
                    if properties_[p]:
                        print(fmtstr % (&#34;&#34;,modelinfo[p]),flush=True)
        return str(self)

    def __str__(self):
        &#34;&#34;&#34;Formatted string representation of layer&#34;&#34;&#34;
        all_identical = len(set(self.layerclass_history)) == 1
        cls = self.__class__.__name__ if all_identical else &#34;multilayer&#34;
        return f&#34;&lt;{cls} with {self.n} layer{&#39;s&#39; if self.n&gt;1 else &#39;&#39;}: {self.name}&gt;&#34;

    # --------------------------------------------------------------------
    # Returns the equivalent dictionary from an object for debugging
    # --------------------------------------------------------------------
    def _todict(self):
        &#34;&#34;&#34; returns the equivalent dictionary from an object &#34;&#34;&#34;
        return dict((key, getattr(self, key)) for key in dir(self) if key not in dir(self.__class__))
    # --------------------------------------------------------------------

    # --------------------------------------------------------------------
    # Simplify layers by collecting similar ones
    # --------------------------------------------------------------------
    def simplify(self):
        &#34;&#34;&#34; merge continuous layers of the same type &#34;&#34;&#34;
        nlayer = self._nlayer
        if nlayer&gt;1:
           res = self[0]
           ires = 0
           ireshash = res.hashlayer[0]
           for i in range(1,nlayer):
               if self.hashlayer[i]==ireshash:
                   res.l[ires] = res.l[ires]+self.l[i]
               else:
                   res = res + self[i]
                   ires = ires+1
                   ireshash = self.hashlayer[i]
        else:
             res = self.copy()
        return res

    # --------------------------------------------------------------------
    # Split layers into a tuple
    # --------------------------------------------------------------------
    def split(self):
        &#34;&#34;&#34; split layers &#34;&#34;&#34;
        out = ()
        if self._nlayer&gt;0:
            for i in range(self._nlayer):
                out = out + (self[i],) # (,) special syntax for tuple singleton
        return out

    # --------------------------------------------------------------------
    # deepcopy
    # --------------------------------------------------------------------
    def copy(self,**kwargs):
        &#34;&#34;&#34;
        Creates a deep copy of the current layer instance.

        Returns:
        - layer: A new layer instance identical to the original.
        &#34;&#34;&#34;
        return duplicate(self).update(**kwargs)

    # --------------------------------------------------------------------
    # update contact conditions from a foodphysics instance (or do the reverse)
    # material &lt;&lt; medium
    # --------------------------------------------------------------------
    def _from(self,medium=None):
        &#34;&#34;&#34;Propagates contact conditions from food instance&#34;&#34;&#34;
        from patankar.food import foodphysics
        if not isinstance(medium,foodphysics):
            raise TypeError(f&#34;medium must be a foodphysics, foodlayer not a {type(medium).__name__}&#34;)
        if not hasattr(medium, &#34;contacttemperature&#34;):
            medium.contacttemperature = self.T[0]
        T = self.get_param(&#34;contacttemperature&#34;,40,acceptNone=False)
        self.T = np.full_like(self.T,T)

    # overloading operation
    def __lshift__(self, medium):
        &#34;&#34;&#34;Overloads &lt;&lt; to propagate contact conditions from food.&#34;&#34;&#34;
        self._from(medium)

    # --------------------------------------------------------------------
    # Inheritance registration mechanism associated with food &gt;&gt; layer
    # It is used by food, not by layer (please refer to food.py).
    # Note that layer &gt;&gt; food means mass transfer simulation
    # --------------------------------------------------------------------
    def acknowledge(self, what=None, category=None):
        &#34;&#34;&#34;
        Register inherited properties under a given category.

        Parameters:
        -----------
        what : str or list of str or a set
            The properties or attributes that have been inherited.
        category : str
            The category under which the properties are grouped.
        &#34;&#34;&#34;
        if category is None or what is None:
            raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
        if isinstance(what, str):
            what = {what}  # Convert string to a set
        elif isinstance(what, list):
            what = set(what)  # Convert list to a set for uniqueness
        elif not isinstance(what,set):
            raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
        if category not in self._hasbeeninherited:
            self._hasbeeninherited[category] = set()
        self._hasbeeninherited[category].update(what)

    # --------------------------------------------------------------------
    # migration simulation overloaded as sim = layer &gt;&gt; food
    # using layer &gt;&gt; food without output works also.
    # The result is stored in food.lastsimulation
    # --------------------------------------------------------------------
    def contact(self,medium,**kwargs):
        return self.migration(medium,**kwargs)

    def migration(self,medium,**kwargs):
        from patankar.migration import senspatankar
        sim = senspatankar(self,medium,**kwargs)
        medium.lastsimulation = sim # store the last simulation result in medium
        medium.lastinput = self # store the last input (self)
        sim.savestate(self,medium) # store store the inputs in sim for chaining
        return sim

    # overloading operation
    def __rshift__(self, medium):
        &#34;&#34;&#34;Overloads &gt;&gt; to propagate migration to food.&#34;&#34;&#34;
        from patankar.food import foodphysics
        if not isinstance(medium,foodphysics):
            raise TypeError(f&#34;medium must be a foodphysics object not a {type(medium).__name__}&#34;)
        return self.contact(medium)

    # --------------------------------------------------------------------
    # Safe update method
    # --------------------------------------------------------------------
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update layer parameters following strict validation rules.

        Rules:
        1) key should be listed in self._defaults
        2) for some keys, synonyms are acceptable as reported in self._synonyms
        3) values cannot be None if they were not None in _defaults
        4) values should be str if they were initially str, idem with bool
        5) values which were numeric (int, float, np.ndarray) should remain numeric.
        6) lists are acceptable as numeric arrays
        7) all numerical (float, np.ndarray, list) except int must be converted into numpy arrays.
           Values which were int in _defaults must remain int and an error should be raised
           if a float value is proposed.
        8) keys listed in _parametersWithUnits can be assigned with tuples (value, &#34;unit&#34;).
           They will be converted automatically with check_units(value).
        9) for parameters with a default value None, any value is acceptable
        10) A clear error message should be displayed for any bad value showing the
            current value of the parameter and its default value.
        &#34;&#34;&#34;

        if not kwargs:  # shortcut
            return self # for chaining

        param_counts = {key: 0 for key in self._defaults}  # Track how many times each param is set

        def resolve_key(key):
            &#34;&#34;&#34;Resolve key considering synonyms and check for duplicates.&#34;&#34;&#34;
            for main_key, synonyms in self._synonyms.items():
                if key == main_key or key in synonyms:
                    param_counts[main_key] += 1
                    return main_key
            param_counts[key] += 1
            return key

        def validate_value(key, value):
            &#34;&#34;&#34;Validate and process the value according to the rules.&#34;&#34;&#34;
            default_value = self._defaults[key]

            # Rule 3: values cannot be None if they were not None in _defaults
            if value is None and default_value is not None:
                raise ValueError(f&#34;Invalid value for &#39;{key}&#39;: None is not allowed. &#34;
                                 f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 9: If default is None, any value is acceptable
            if default_value is None:
                return value

            # Rule 4 &amp; 5: Ensure type consistency (str, bool, or numeric types)
            if isinstance(default_value, str) and not isinstance(value, str):
                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected str, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
            if isinstance(default_value, bool) and not isinstance(value, bool):
                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected bool, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 6 &amp; 7: Convert numeric types properly
            if isinstance(default_value, (int, float, np.ndarray)):
                if isinstance(value, list):
                    value = np.array(value)

                if isinstance(default_value, int):
                    if isinstance(value, float) or (isinstance(value, np.ndarray) and np.issubdtype(value.dtype, np.floating)):
                        raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got float. &#34;
                                        f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
                    if isinstance(value, (int, np.integer)):
                        return int(value)  # Ensure it remains an int
                    raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got {type(value).__name__}. &#34;
                                    f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

                if isinstance(value, (int, float, list, np.ndarray)):
                    return np.array(value, dtype=float)  # Convert everything to np.array for floats

                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected numeric, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 8: Convert units if applicable
            if key in self._parametersWithUnits and isinstance(value, tuple):
                value, unit = value
                converted_value, _ = check_units((value, unit), ExpectedUnits=self._parametersWithUnits[key])
                return converted_value

            return value

        # Apply updates while tracking parameter occurrences
        for key, value in kwargs.items():
            resolved_key = resolve_key(key)

            if resolved_key not in self._defaults:
                raise KeyError(f&#34;Invalid key &#39;{key}&#39;. Allowed keys: {list(self._defaults.keys())}.&#34;)

            try:
                validated_value = validate_value(resolved_key, value)
                setattr(self, resolved_key, validated_value)
            except (TypeError, ValueError) as e:
                raise ValueError(f&#34;Error updating &#39;{key}&#39;: {e}&#34;)

        # Ensure that no parameter was set multiple times due to synonyms
        duplicate_keys = [k for k, v in param_counts.items() if v &gt; 1]
        if duplicate_keys:
            raise ValueError(f&#34;Duplicate assignment detected for parameters: {duplicate_keys}. &#34;
                             &#34;Use only one synonym per parameter.&#34;)

        return self # to enable chaining</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>patankar.layer.AdhesiveAcrylate</li>
<li>patankar.layer.AdhesiveEVA</li>
<li>patankar.layer.AdhesiveNaturalRubber</li>
<li>patankar.layer.AdhesivePU</li>
<li>patankar.layer.AdhesivePVAC</li>
<li>patankar.layer.AdhesiveSyntheticRubber</li>
<li>patankar.layer.AdhesiveVAE</li>
<li>patankar.layer.Cardboard</li>
<li>patankar.layer.HDPE</li>
<li>patankar.layer.HIPS</li>
<li>patankar.layer.LDPE</li>
<li>patankar.layer.LLDPE</li>
<li>patankar.layer.PA6</li>
<li>patankar.layer.PA66</li>
<li>patankar.layer.PBT</li>
<li>patankar.layer.PEN</li>
<li>patankar.layer.PP</li>
<li>patankar.layer.PPrubber</li>
<li>patankar.layer.PS</li>
<li>patankar.layer.Paper</li>
<li>patankar.layer.SBS</li>
<li>patankar.layer.air</li>
<li>patankar.layer.gPET</li>
<li>patankar.layer.oPP</li>
<li>patankar.layer.plasticizedPVC</li>
<li>patankar.layer.rPET</li>
<li>patankar.layer.rigidPVC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="migration.layer.help"><code class="name flex">
<span>def <span class="ident">help</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a dynamically formatted summary of all input parameters,
adjusting column widths based on content and wrapping long descriptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def help(cls):
    &#34;&#34;&#34;
    Prints a dynamically formatted summary of all input parameters,
    adjusting column widths based on content and wrapping long descriptions.
    &#34;&#34;&#34;

    # Column Headers
    headers = [&#34;Parameter&#34;, &#34;Default Value&#34;, &#34;Has Synonyms?&#34;, &#34;Description&#34;]
    col_widths = [len(h) for h in headers]  # Start with header widths

    # Collect Data Rows
    rows = []
    for param, default in cls._defaults.items():
        has_synonyms = &#34;✅ Yes&#34; if param in cls._synonyms else &#34;❌ No&#34;
        description = cls._descriptionInputs.get(param, &#34;No description available&#34;)

        # Update column widths dynamically
        col_widths[0] = max(col_widths[0], len(param))
        col_widths[1] = max(col_widths[1], len(str(default)))
        col_widths[2] = max(col_widths[2], len(has_synonyms))
        col_widths[3] = max(col_widths[3], len(description))

        rows.append([param, str(default), has_synonyms, description])

    # Function to wrap text for a given column width
    def wrap_text(text, width):
        return textwrap.fill(text, width)

    # Print Table with Adjusted Column Widths
    separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in col_widths) + &#34;-+&#34;
    print(&#34;\n### **Accepted Parameters and Defaults**\n&#34;)
    print(separator)
    print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(col_widths[i]) for i, h in enumerate(headers)) + &#34; |&#34;)
    print(separator)
    for row in rows:
        # Wrap text in the description column
        row[3] = wrap_text(row[3], col_widths[3])

        # Print row
        print(&#34;| &#34; + &#34; | &#34;.join(row[i].ljust(col_widths[i]) for i in range(3)) + &#34; | &#34; + row[3])
    print(separator)

    # Synonyms Table
    print(&#34;\n### **Parameter Synonyms**\n&#34;)
    syn_headers = [&#34;Parameter&#34;, &#34;Synonyms&#34;]
    syn_col_widths = [
        max(len(&#34;Parameter&#34;), max(len(k) for k in cls._synonyms.keys())),  # Ensure it fits &#34;Parameter&#34;
        max(len(&#34;Synonyms&#34;), max(len(&#34;, &#34;.join(v)) for v in cls._synonyms.values()))  # Ensure it fits &#34;Synonyms&#34;
    ]
    syn_separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in syn_col_widths) + &#34;-+&#34;
    print(syn_separator)
    print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(syn_col_widths[i]) for i, h in enumerate(syn_headers)) + &#34; |&#34;)
    print(syn_separator)
    for param, synonyms in cls._synonyms.items():
        print(f&#34;| {param.ljust(syn_col_widths[0])} | {&#39;, &#39;.join(synonyms).ljust(syn_col_widths[1])} |&#34;)
    print(syn_separator)</code></pre>
</details>
</dd>
<dt id="migration.layer.resolvename"><code class="name flex">
<span>def <span class="ident">resolvename</span></span>(<span>param_value, param_key, **unresolved)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolves the correct parameter value using known synonyms.</p>
<ul>
<li>If param_value is already set (not None), return it.</li>
<li>If a synonym exists in **unresolved, assign its value.</li>
<li>If multiple synonyms of the same parameter appear in **unresolved, raise an error.</li>
<li>Otherwise, return None.</li>
</ul>
<p>Parameters:
- <code>param_name</code> (any): The original value (if provided).
- <code>param_key</code> (str): The legitimate parameter name we are resolving.
- <code>unresolved</code> (dict): The dictionary of unrecognized keyword arguments.</p>
<p>Returns:
- The resolved value or None if not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def resolvename(cls, param_value, param_key, **unresolved):
    &#34;&#34;&#34;
    Resolves the correct parameter value using known synonyms.

    - If param_value is already set (not None), return it.
    - If a synonym exists in **unresolved, assign its value.
    - If multiple synonyms of the same parameter appear in **unresolved, raise an error.
    - Otherwise, return None.

    Parameters:
    - `param_name` (any): The original value (if provided).
    - `param_key` (str): The legitimate parameter name we are resolving.
    - `unresolved` (dict): The dictionary of unrecognized keyword arguments.

    Returns:
    - The resolved value or None if not found.
    &#34;&#34;&#34;
    if param_value is not None:
        return param_value  # The parameter is explicitly defined, do not override
    if not unresolved:      # shortcut
        return None
    resolved_value = None
    found_keys = []
    # Check if param_key itself is present in unresolved
    if param_key in unresolved:
        found_keys.append(param_key)
        resolved_value = unresolved[param_key]
    # Check if any of its synonyms are in unresolved
    if param_key in cls._synonyms:
        for synonym in cls._synonyms[param_key]:
            if synonym in unresolved:
                found_keys.append(synonym)
                resolved_value = unresolved[synonym]
    # Raise error if multiple synonyms were found
    if len(found_keys) &gt; 1:
        raise ValueError(
            f&#34;Conflicting definitions: Multiple synonyms {found_keys} were provided for &#39;{param_key}&#39;.&#34;
        )
    return resolved_value</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="migration.layer.C0"><code class="name">var <span class="ident">C0</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def C0(self): return self._C0</code></pre>
</details>
</dd>
<dt id="migration.layer.Cunit"><code class="name">var <span class="ident">Cunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Cunit(self): return self._Cunit</code></pre>
</details>
</dd>
<dt id="migration.layer.D"><code class="name">var <span class="ident">D</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def D(self):
    Dtmp = self.Dmodel()
    if Dtmp is not None:
        return np.full_like(self._D, Dtmp)
    else:
        return self._D</code></pre>
</details>
</dd>
<dt id="migration.layer.Dmodel"><code class="name">var <span class="ident">Dmodel</span></code></dt>
<dd>
<div class="desc"><p>Return a callable function that evaluates D with updated parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Dmodel(self):
    &#34;&#34;&#34;Return a callable function that evaluates D with updated parameters.&#34;&#34;&#34;
    if not isinstance(self._substance,migrant) or self._substance.Deval() is None:
        return lambda **kwargs: None  # Return a function that always returns None
    template = self._substance.Dtemplate.copy()
    template.update()
    def func(**kwargs):
        D = np.empty_like(self._D)
        for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
            template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
            # inherit eventual user parameters
            D[i] = self._substance.D.evaluate(**dict(template, **kwargs))
        return D
    return func</code></pre>
</details>
</dd>
<dt id="migration.layer.Dunit"><code class="name">var <span class="ident">Dunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Dunit(self): return self._Dunit</code></pre>
</details>
</dd>
<dt id="migration.layer.Foscale"><code class="name">var <span class="ident">Foscale</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Foscale(self): return self.D[self.referencelayer]/self.lreferencelayer**2</code></pre>
</details>
</dd>
<dt id="migration.layer.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def T(self): return self._T</code></pre>
</details>
</dd>
<dt id="migration.layer.TK"><code class="name">var <span class="ident">TK</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def TK(self): return self._T+T0K</code></pre>
</details>
</dd>
<dt id="migration.layer.TKunit"><code class="name">var <span class="ident">TKunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def TKunit(self): return &#34;K&#34;</code></pre>
</details>
</dd>
<dt id="migration.layer.Tunit"><code class="name">var <span class="ident">Tunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tunit(self): return self._Tunit</code></pre>
</details>
</dd>
<dt id="migration.layer.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def code(self): return self._code</code></pre>
</details>
</dd>
<dt id="migration.layer.concentration"><code class="name">var <span class="ident">concentration</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def concentration(self): return sum(self.l*self.C0)/self.thickness</code></pre>
</details>
</dd>
<dt id="migration.layer.hashlayer"><code class="name">var <span class="ident">hashlayer</span></code></dt>
<dd>
<div class="desc"><p>hash layer (layer-by-layer) method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hashlayer(self):
    &#34;&#34;&#34; hash layer (layer-by-layer) method &#34;&#34;&#34;
    return [hash((self._name[n],
                  self._type[n],
                  self._material[n],
                  self._l[n],
                  self._D[n],
                  self.k[n],
                  self._C0[n],
                  self._rho[n]))
            for n in range(self._nlayer)
            ]</code></pre>
</details>
</dd>
<dt id="migration.layer.k"><code class="name">var <span class="ident">k</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def k(self):
    ktmp = self.kmodel()
    if ktmp:
        return np.full_like(self._D, ktmp)
    else:
        return self._k</code></pre>
</details>
</dd>
<dt id="migration.layer.kmodel"><code class="name">var <span class="ident">kmodel</span></code></dt>
<dd>
<div class="desc"><p>Return a callable function that evaluates k with updated parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kmodel(self):
    &#34;&#34;&#34;Return a callable function that evaluates k with updated parameters.&#34;&#34;&#34;
    if not isinstance(self._substance,migrant) or self._substance.keval() is None:
        return lambda **kwargs: None  # Return a function that always returns None
    template = self._substance.ktemplate.copy()
    template.update()
    def func(**kwargs):
        k = np.empty_like(self._k)
        for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
            template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
            # inherit eventual user parameters
            k[i] = self._substance.k.evaluate(**dict(template, **kwargs))
        return k
    return func</code></pre>
</details>
</dd>
<dt id="migration.layer.kunit"><code class="name">var <span class="ident">kunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kunit(self): return self._kunit</code></pre>
</details>
</dd>
<dt id="migration.layer.l"><code class="name">var <span class="ident">l</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def l(self): return self._l</code></pre>
</details>
</dd>
<dt id="migration.layer.lag"><code class="name">var <span class="ident">lag</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lag(self): return self.l**2/(6*self.D)</code></pre>
</details>
</dd>
<dt id="migration.layer.layerclass"><code class="name">var <span class="ident">layerclass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def layerclass(self): return type(self).__name__</code></pre>
</details>
</dd>
<dt id="migration.layer.layerclass_history"><code class="name">var <span class="ident">layerclass_history</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def layerclass_history(self):
    return self._layerclass_history if self._layerclass_history != [] else [self.layerclass]</code></pre>
</details>
</dd>
<dt id="migration.layer.lreferencelayer"><code class="name">var <span class="ident">lreferencelayer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lreferencelayer(self): return self.l[self.referencelayer]</code></pre>
</details>
</dd>
<dt id="migration.layer.lunit"><code class="name">var <span class="ident">lunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lunit(self): return self._lunit</code></pre>
</details>
</dd>
<dt id="migration.layer.material"><code class="name">var <span class="ident">material</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def material(self): return self._material</code></pre>
</details>
</dd>
<dt id="migration.layer.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self): return self._nlayer</code></pre>
</details>
</dd>
<dt id="migration.layer.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self): return self._name</code></pre>
</details>
</dd>
<dt id="migration.layer.nmesh"><code class="name">var <span class="ident">nmesh</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nmesh(self): return self._nmesh</code></pre>
</details>
</dd>
<dt id="migration.layer.nmeshmin"><code class="name">var <span class="ident">nmeshmin</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nmeshmin(self): return self._nmeshmin</code></pre>
</details>
</dd>
<dt id="migration.layer.permeability"><code class="name">var <span class="ident">permeability</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def permeability(self): return self.D/(self.l*self.k)</code></pre>
</details>
</dd>
<dt id="migration.layer.pressure"><code class="name">var <span class="ident">pressure</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pressure(self): return self.k*self.C0</code></pre>
</details>
</dd>
<dt id="migration.layer.rank"><code class="name">var <span class="ident">rank</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rank(self): return np.flip(np.argsort(np.array(self.resistance))+1).tolist()</code></pre>
</details>
</dd>
<dt id="migration.layer.referencelayer"><code class="name">var <span class="ident">referencelayer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def referencelayer(self): return np.argmax(self.resistance)</code></pre>
</details>
</dd>
<dt id="migration.layer.relative_resistance"><code class="name">var <span class="ident">relative_resistance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relative_resistance(self): return self.resistance/sum(self.resistance)</code></pre>
</details>
</dd>
<dt id="migration.layer.relative_thickness"><code class="name">var <span class="ident">relative_thickness</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relative_thickness(self): return self.l/self.thickness</code></pre>
</details>
</dd>
<dt id="migration.layer.resistance"><code class="name">var <span class="ident">resistance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resistance(self): return self.l*self.k/self.D</code></pre>
</details>
</dd>
<dt id="migration.layer.rho"><code class="name">var <span class="ident">rho</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rho(self): return self._rho</code></pre>
</details>
</dd>
<dt id="migration.layer.rhounit"><code class="name">var <span class="ident">rhounit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rhounit(self): return self._rhounit</code></pre>
</details>
</dd>
<dt id="migration.layer.substance"><code class="name">var <span class="ident">substance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def substance(self): return self._substance</code></pre>
</details>
</dd>
<dt id="migration.layer.thickness"><code class="name">var <span class="ident">thickness</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def thickness(self): return sum(self.l)</code></pre>
</details>
</dd>
<dt id="migration.layer.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self): return self._type</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="migration.layer.acknowledge"><code class="name flex">
<span>def <span class="ident">acknowledge</span></span>(<span>self, what=None, category=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Register inherited properties under a given category.</p>
<h2 id="parameters">Parameters:</h2>
<p>what : str or list of str or a set
The properties or attributes that have been inherited.
category : str
The category under which the properties are grouped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acknowledge(self, what=None, category=None):
    &#34;&#34;&#34;
    Register inherited properties under a given category.

    Parameters:
    -----------
    what : str or list of str or a set
        The properties or attributes that have been inherited.
    category : str
        The category under which the properties are grouped.
    &#34;&#34;&#34;
    if category is None or what is None:
        raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
    if isinstance(what, str):
        what = {what}  # Convert string to a set
    elif isinstance(what, list):
        what = set(what)  # Convert list to a set for uniqueness
    elif not isinstance(what,set):
        raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
    if category not in self._hasbeeninherited:
        self._hasbeeninherited[category] = set()
    self._hasbeeninherited[category].update(what)</code></pre>
</details>
</dd>
<dt id="migration.layer.checknumvalue"><code class="name flex">
<span>def <span class="ident">checknumvalue</span></span>(<span>self, value, ExpectedUnits=None)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a validate value to set properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checknumvalue(self,value,ExpectedUnits=None):
    &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
    if isinstance(value,tuple):
        value = check_units(value,ExpectedUnits=ExpectedUnits)
    if isinstance(value,int): value = float(value)
    if isinstance(value,float): value = np.array([value])
    if isinstance(value,list): value = np.array(value)
    if len(value)&gt;self._nlayer:
        value = value[:self._nlayer]
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the extra value(s) has been removed&#39;)
    elif len(value)&lt;self._nlayer:
        value = np.concatenate((value,value[-1:]*np.ones(self._nlayer-len(value))))
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the last value has been repeated&#39;)
    return value</code></pre>
</details>
</dd>
<dt id="migration.layer.checktextvalue"><code class="name flex">
<span>def <span class="ident">checktextvalue</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a validate value to set properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checktextvalue(self,value):
    &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
    if not isinstance(value,list): value = [value]
    if len(value)&gt;self._nlayer:
        value = value[:self._nlayer]
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the extra entry(ies) has been removed&#39;)
    elif len(value)&lt;self._nlayer:
        value = value + value[-1:]*(self._nlayer-len(value))
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the last entry has been repeated&#39;)
    return value</code></pre>
</details>
</dd>
<dt id="migration.layer.contact"><code class="name flex">
<span>def <span class="ident">contact</span></span>(<span>self, medium, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contact(self,medium,**kwargs):
    return self.migration(medium,**kwargs)</code></pre>
</details>
</dd>
<dt id="migration.layer.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a deep copy of the current layer instance.</p>
<p>Returns:
- layer: A new layer instance identical to the original.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self,**kwargs):
    &#34;&#34;&#34;
    Creates a deep copy of the current layer instance.

    Returns:
    - layer: A new layer instance identical to the original.
    &#34;&#34;&#34;
    return duplicate(self).update(**kwargs)</code></pre>
</details>
</dd>
<dt id="migration.layer.mesh"><code class="name flex">
<span>def <span class="ident">mesh</span></span>(<span>self, nmesh=None, nmeshmin=None)</span>
</code></dt>
<dd>
<div class="desc"><p>nmesh() generates mesh based on nmesh and nmeshmin, nmesh(nmesh=value,nmeshmin=value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mesh(self,nmesh=None,nmeshmin=None):
    &#34;&#34;&#34; nmesh() generates mesh based on nmesh and nmeshmin, nmesh(nmesh=value,nmeshmin=value) &#34;&#34;&#34;
    if nmesh==None: nmesh = self.nmesh
    if nmeshmin==None: nmeshmin = self.nmeshmin
    if nmeshmin&gt;nmesh: nmeshmin,nmesh = nmesh, nmeshmin
    # X = mesh distribution (number of nodes per layer)
    X = np.ones(self._nlayer)
    for i in range(1,self._nlayer):
       X[i] = X[i-1]*(self.permeability[i-1]*self.l[i])/(self.permeability[i]*self.l[i-1])
    X = np.maximum(nmeshmin,np.ceil(nmesh*X/sum(X)))
    X = np.round((X/sum(X))*nmesh).astype(int)
    # do the mesh
    x0 = 0
    mymesh = []
    for i in range(self._nlayer):
        mymesh.append(mesh(self.l[i]/self.l[self.referencelayer],X[i],x0=x0,index=i))
        x0 += self.l[i]
    return mymesh</code></pre>
</details>
</dd>
<dt id="migration.layer.migration"><code class="name flex">
<span>def <span class="ident">migration</span></span>(<span>self, medium, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def migration(self,medium,**kwargs):
    from patankar.migration import senspatankar
    sim = senspatankar(self,medium,**kwargs)
    medium.lastsimulation = sim # store the last simulation result in medium
    medium.lastinput = self # store the last input (self)
    sim.savestate(self,medium) # store store the inputs in sim for chaining
    return sim</code></pre>
</details>
</dd>
<dt id="migration.layer.simplify"><code class="name flex">
<span>def <span class="ident">simplify</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>merge continuous layers of the same type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify(self):
    &#34;&#34;&#34; merge continuous layers of the same type &#34;&#34;&#34;
    nlayer = self._nlayer
    if nlayer&gt;1:
       res = self[0]
       ires = 0
       ireshash = res.hashlayer[0]
       for i in range(1,nlayer):
           if self.hashlayer[i]==ireshash:
               res.l[ires] = res.l[ires]+self.l[i]
           else:
               res = res + self[i]
               ires = ires+1
               ireshash = self.hashlayer[i]
    else:
         res = self.copy()
    return res</code></pre>
</details>
</dd>
<dt id="migration.layer.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>split layers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self):
    &#34;&#34;&#34; split layers &#34;&#34;&#34;
    out = ()
    if self._nlayer&gt;0:
        for i in range(self._nlayer):
            out = out + (self[i],) # (,) special syntax for tuple singleton
    return out</code></pre>
</details>
</dd>
<dt id="migration.layer.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update layer parameters following strict validation rules.</p>
<p>Rules:
1) key should be listed in self._defaults
2) for some keys, synonyms are acceptable as reported in self._synonyms
3) values cannot be None if they were not None in _defaults
4) values should be str if they were initially str, idem with bool
5) values which were numeric (int, float, np.ndarray) should remain numeric.
6) lists are acceptable as numeric arrays
7) all numerical (float, np.ndarray, list) except int must be converted into numpy arrays.
Values which were int in _defaults must remain int and an error should be raised
if a float value is proposed.
8) keys listed in _parametersWithUnits can be assigned with tuples (value, "unit").
They will be converted automatically with check_units(value).
9) for parameters with a default value None, any value is acceptable
10) A clear error message should be displayed for any bad value showing the
current value of the parameter and its default value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update layer parameters following strict validation rules.

    Rules:
    1) key should be listed in self._defaults
    2) for some keys, synonyms are acceptable as reported in self._synonyms
    3) values cannot be None if they were not None in _defaults
    4) values should be str if they were initially str, idem with bool
    5) values which were numeric (int, float, np.ndarray) should remain numeric.
    6) lists are acceptable as numeric arrays
    7) all numerical (float, np.ndarray, list) except int must be converted into numpy arrays.
       Values which were int in _defaults must remain int and an error should be raised
       if a float value is proposed.
    8) keys listed in _parametersWithUnits can be assigned with tuples (value, &#34;unit&#34;).
       They will be converted automatically with check_units(value).
    9) for parameters with a default value None, any value is acceptable
    10) A clear error message should be displayed for any bad value showing the
        current value of the parameter and its default value.
    &#34;&#34;&#34;

    if not kwargs:  # shortcut
        return self # for chaining

    param_counts = {key: 0 for key in self._defaults}  # Track how many times each param is set

    def resolve_key(key):
        &#34;&#34;&#34;Resolve key considering synonyms and check for duplicates.&#34;&#34;&#34;
        for main_key, synonyms in self._synonyms.items():
            if key == main_key or key in synonyms:
                param_counts[main_key] += 1
                return main_key
        param_counts[key] += 1
        return key

    def validate_value(key, value):
        &#34;&#34;&#34;Validate and process the value according to the rules.&#34;&#34;&#34;
        default_value = self._defaults[key]

        # Rule 3: values cannot be None if they were not None in _defaults
        if value is None and default_value is not None:
            raise ValueError(f&#34;Invalid value for &#39;{key}&#39;: None is not allowed. &#34;
                             f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

        # Rule 9: If default is None, any value is acceptable
        if default_value is None:
            return value

        # Rule 4 &amp; 5: Ensure type consistency (str, bool, or numeric types)
        if isinstance(default_value, str) and not isinstance(value, str):
            raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected str, got {type(value).__name__}. &#34;
                            f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
        if isinstance(default_value, bool) and not isinstance(value, bool):
            raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected bool, got {type(value).__name__}. &#34;
                            f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

        # Rule 6 &amp; 7: Convert numeric types properly
        if isinstance(default_value, (int, float, np.ndarray)):
            if isinstance(value, list):
                value = np.array(value)

            if isinstance(default_value, int):
                if isinstance(value, float) or (isinstance(value, np.ndarray) and np.issubdtype(value.dtype, np.floating)):
                    raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got float. &#34;
                                    f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
                if isinstance(value, (int, np.integer)):
                    return int(value)  # Ensure it remains an int
                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            if isinstance(value, (int, float, list, np.ndarray)):
                return np.array(value, dtype=float)  # Convert everything to np.array for floats

            raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected numeric, got {type(value).__name__}. &#34;
                            f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

        # Rule 8: Convert units if applicable
        if key in self._parametersWithUnits and isinstance(value, tuple):
            value, unit = value
            converted_value, _ = check_units((value, unit), ExpectedUnits=self._parametersWithUnits[key])
            return converted_value

        return value

    # Apply updates while tracking parameter occurrences
    for key, value in kwargs.items():
        resolved_key = resolve_key(key)

        if resolved_key not in self._defaults:
            raise KeyError(f&#34;Invalid key &#39;{key}&#39;. Allowed keys: {list(self._defaults.keys())}.&#34;)

        try:
            validated_value = validate_value(resolved_key, value)
            setattr(self, resolved_key, validated_value)
        except (TypeError, ValueError) as e:
            raise ValueError(f&#34;Error updating &#39;{key}&#39;: {e}&#34;)

    # Ensure that no parameter was set multiple times due to synonyms
    duplicate_keys = [k for k, v in param_counts.items() if v &gt; 1]
    if duplicate_keys:
        raise ValueError(f&#34;Duplicate assignment detected for parameters: {duplicate_keys}. &#34;
                         &#34;Use only one synonym per parameter.&#34;)

    return self # to enable chaining</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="migration.restartfile"><code class="flex name class">
<span>class <span class="ident">restartfile</span></span>
</code></dt>
<dd>
<div class="desc"><p>Containter for the restartfile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class restartfile:
    &#34;&#34;&#34;
    Containter for the restartfile
    &#34;&#34;&#34;
    @classmethod
    def copy(cls, what):
        &#34;&#34;&#34;Safely copy a parameter that can be a float, str, dict, or a NumPy array&#34;&#34;&#34;
        if isinstance(what, (int, float, str, tuple,bool)):  # Immutable types (direct copy)
            return what
        elif isinstance(what, np.ndarray):  # NumPy array (ensure a separate copy)
            return np.copy(what)
        elif isinstance(what, dict):  # Dictionary (deep copy)
            return duplicate(what)
        elif what is None:
            return None
        else:  # Fallback for other complex types
            return duplicate(what)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="migration.restartfile_senspantakar" href="#migration.restartfile_senspantakar">restartfile_senspantakar</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="migration.restartfile.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>what)</span>
</code></dt>
<dd>
<div class="desc"><p>Safely copy a parameter that can be a float, str, dict, or a NumPy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def copy(cls, what):
    &#34;&#34;&#34;Safely copy a parameter that can be a float, str, dict, or a NumPy array&#34;&#34;&#34;
    if isinstance(what, (int, float, str, tuple,bool)):  # Immutable types (direct copy)
        return what
    elif isinstance(what, np.ndarray):  # NumPy array (ensure a separate copy)
        return np.copy(what)
    elif isinstance(what, dict):  # Dictionary (deep copy)
        return duplicate(what)
    elif what is None:
        return None
    else:  # Fallback for other complex types
        return duplicate(what)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="migration.restartfile_senspantakar"><code class="flex name class">
<span>class <span class="ident">restartfile_senspantakar</span></span>
<span>(</span><span>multilayer, medium, name, description, t, autotime, timescale, Cxprevious, ntimes, RelTol, AbsTol)</span>
</code></dt>
<dd>
<div class="desc"><p>Containter for the restartfile</p>
<p>constructor to be called at the intialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class restartfile_senspantakar(restartfile):
    &#34;&#34;&#34;
    Containter for the restartfile
    &#34;&#34;&#34;
    def __init__(self,multilayer,medium,name,description,
                 t,autotime,timescale,Cxprevious,
                 ntimes,RelTol,AbsTol):
        &#34;&#34;&#34;constructor to be called at the intialization&#34;&#34;&#34;
        inputs = {
            &#34;multilayer&#34;:multilayer.copy(),
            &#34;medium&#34;:medium.copy(),
            &#34;name&#34;:restartfile.copy(name),
            &#34;description&#34;:restartfile.copy(description),
            &#34;t&#34;:restartfile.copy(t), # t is a duration not absolute time (it should not be reused)
            &#34;autotime&#34;:restartfile.copy(autotime),
            &#34;timescale&#34;:restartfile.copy(timescale),
            &#34;Cxprevious&#34;:Cxprevious,
            &#34;ntimes&#34;:restartfile.copy(ntimes),
            &#34;RelTol&#34;:restartfile.copy(RelTol),
            &#34;AbsTol&#34;:restartfile.copy(AbsTol)
            }
        # inputs
        self.inputs = inputs
        # outputs
        self.t = None # no result yet
        self.CF = None # no result yet
        self.Cprofile = None # no result yet

    def freezeCF(self,t,CF):
        &#34;&#34;&#34;Freeze the CF solution CF(t)&#34;&#34;&#34;
        self.t = t
        self.CF = CF

    def freezeCx(self,x,Cx):
        &#34;&#34;&#34;Freeze the Cx solution Cx(x)&#34;&#34;&#34;
        self.Cprofile = Cprofile(x,Cx)

    def __repr__(self):
        &#34;&#34;&#34;representation of the restart object&#34;&#34;&#34;
        if self.t is None:
            print(&#34;Restart file with no result&#34;)
        else:
            print(f&#34;Restart file at t={self.t} with CF={self.CF}&#34;)
            print(&#34;Details of the profile:&#34;)
            repr(self.Cprofile)
        return str(self)

    def __str__(self):
        &#34;&#34;&#34;Formatted representation of the restart object&#34;&#34;&#34;
        res = &#34;no result&#34; if self.t is None else f&#34;solution at t={self.t}&#34;
        return f&#34;&lt;{self.__class__.__name__}: {res}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="migration.restartfile" href="#migration.restartfile">restartfile</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="migration.restartfile_senspantakar.freezeCF"><code class="name flex">
<span>def <span class="ident">freezeCF</span></span>(<span>self, t, CF)</span>
</code></dt>
<dd>
<div class="desc"><p>Freeze the CF solution CF(t)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freezeCF(self,t,CF):
    &#34;&#34;&#34;Freeze the CF solution CF(t)&#34;&#34;&#34;
    self.t = t
    self.CF = CF</code></pre>
</details>
</dd>
<dt id="migration.restartfile_senspantakar.freezeCx"><code class="name flex">
<span>def <span class="ident">freezeCx</span></span>(<span>self, x, Cx)</span>
</code></dt>
<dd>
<div class="desc"><p>Freeze the Cx solution Cx(x)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freezeCx(self,x,Cx):
    &#34;&#34;&#34;Freeze the Cx solution Cx(x)&#34;&#34;&#34;
    self.Cprofile = Cprofile(x,Cx)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="migration.restartfile" href="#migration.restartfile">restartfile</a></b></code>:
<ul class="hlist">
<li><code><a title="migration.restartfile.copy" href="#migration.restartfile.copy">copy</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#classes">Classes</a></li>
<li><a href="#functions">Functions</a></li>
<li><a href="#example">Example</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="migration.autoname" href="#migration.autoname">autoname</a></code></li>
<li><code><a title="migration.check_units" href="#migration.check_units">check_units</a></code></li>
<li><code><a title="migration.compute_fc_profile_PBC" href="#migration.compute_fc_profile_PBC">compute_fc_profile_PBC</a></code></li>
<li><code><a title="migration.compute_fv_profile" href="#migration.compute_fv_profile">compute_fv_profile</a></code></li>
<li><code><a title="migration.custom_plt_figure" href="#migration.custom_plt_figure">custom_plt_figure</a></code></li>
<li><code><a title="migration.custom_plt_subplots" href="#migration.custom_plt_subplots">custom_plt_subplots</a></code></li>
<li><code><a title="migration.is_valid_figure" href="#migration.is_valid_figure">is_valid_figure</a></code></li>
<li><code><a title="migration.print_figure" href="#migration.print_figure">print_figure</a></code></li>
<li><code><a title="migration.print_pdf" href="#migration.print_pdf">print_pdf</a></code></li>
<li><code><a title="migration.print_png" href="#migration.print_png">print_png</a></code></li>
<li><code><a title="migration.rgb" href="#migration.rgb">rgb</a></code></li>
<li><code><a title="migration.senspatankar" href="#migration.senspatankar">senspatankar</a></code></li>
<li><code><a title="migration.tooclear" href="#migration.tooclear">tooclear</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="migration.CFSimulationContainer" href="#migration.CFSimulationContainer">CFSimulationContainer</a></code></h4>
<ul class="two-column">
<li><code><a title="migration.CFSimulationContainer.add" href="#migration.CFSimulationContainer.add">add</a></code></li>
<li><code><a title="migration.CFSimulationContainer.delete" href="#migration.CFSimulationContainer.delete">delete</a></code></li>
<li><code><a title="migration.CFSimulationContainer.description" href="#migration.CFSimulationContainer.description">description</a></code></li>
<li><code><a title="migration.CFSimulationContainer.name" href="#migration.CFSimulationContainer.name">name</a></code></li>
<li><code><a title="migration.CFSimulationContainer.plotCF" href="#migration.CFSimulationContainer.plotCF">plotCF</a></code></li>
<li><code><a title="migration.CFSimulationContainer.rgb" href="#migration.CFSimulationContainer.rgb">rgb</a></code></li>
<li><code><a title="migration.CFSimulationContainer.save_as_csv" href="#migration.CFSimulationContainer.save_as_csv">save_as_csv</a></code></li>
<li><code><a title="migration.CFSimulationContainer.save_as_excel" href="#migration.CFSimulationContainer.save_as_excel">save_as_excel</a></code></li>
<li><code><a title="migration.CFSimulationContainer.to_dataframe" href="#migration.CFSimulationContainer.to_dataframe">to_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="migration.Cprofile" href="#migration.Cprofile">Cprofile</a></code></h4>
<ul class="">
<li><code><a title="migration.Cprofile.assign_values" href="#migration.Cprofile.assign_values">assign_values</a></code></li>
<li><code><a title="migration.Cprofile.find_indices_Cxrange" href="#migration.Cprofile.find_indices_Cxrange">find_indices_Cxrange</a></code></li>
<li><code><a title="migration.Cprofile.find_indices_xrange" href="#migration.Cprofile.find_indices_xrange">find_indices_xrange</a></code></li>
<li><code><a title="migration.Cprofile.integrate" href="#migration.Cprofile.integrate">integrate</a></code></li>
<li><code><a title="migration.Cprofile.interp" href="#migration.Cprofile.interp">interp</a></code></li>
<li><code><a title="migration.Cprofile.mean_concentration" href="#migration.Cprofile.mean_concentration">mean_concentration</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="migration.PrintableFigure" href="#migration.PrintableFigure">PrintableFigure</a></code></h4>
<ul class="">
<li><code><a title="migration.PrintableFigure.print" href="#migration.PrintableFigure.print">print</a></code></li>
<li><code><a title="migration.PrintableFigure.print_pdf" href="#migration.PrintableFigure.print_pdf">print_pdf</a></code></li>
<li><code><a title="migration.PrintableFigure.print_png" href="#migration.PrintableFigure.print_png">print_png</a></code></li>
<li><code><a title="migration.PrintableFigure.set" href="#migration.PrintableFigure.set">set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="migration.SensPatankarResult" href="#migration.SensPatankarResult">SensPatankarResult</a></code></h4>
<ul class="two-column">
<li><code><a title="migration.SensPatankarResult.chaining" href="#migration.SensPatankarResult.chaining">chaining</a></code></li>
<li><code><a title="migration.SensPatankarResult.interpolate_CF" href="#migration.SensPatankarResult.interpolate_CF">interpolate_CF</a></code></li>
<li><code><a title="migration.SensPatankarResult.plotCF" href="#migration.SensPatankarResult.plotCF">plotCF</a></code></li>
<li><code><a title="migration.SensPatankarResult.plotCx" href="#migration.SensPatankarResult.plotCx">plotCx</a></code></li>
<li><code><a title="migration.SensPatankarResult.resume" href="#migration.SensPatankarResult.resume">resume</a></code></li>
<li><code><a title="migration.SensPatankarResult.savestate" href="#migration.SensPatankarResult.savestate">savestate</a></code></li>
<li><code><a title="migration.SensPatankarResult.update" href="#migration.SensPatankarResult.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="migration.foodlayer" href="#migration.foodlayer">foodlayer</a></code></h4>
<ul class="">
<li><code><a title="migration.foodlayer.CF0" href="#migration.foodlayer.CF0">CF0</a></code></li>
<li><code><a title="migration.foodlayer.CF0units" href="#migration.foodlayer.CF0units">CF0units</a></code></li>
<li><code><a title="migration.foodlayer.contactemperature" href="#migration.foodlayer.contactemperature">contactemperature</a></code></li>
<li><code><a title="migration.foodlayer.contactemperatureUnits" href="#migration.foodlayer.contactemperatureUnits">contactemperatureUnits</a></code></li>
<li><code><a title="migration.foodlayer.contacttime" href="#migration.foodlayer.contacttime">contacttime</a></code></li>
<li><code><a title="migration.foodlayer.contacttime_units" href="#migration.foodlayer.contacttime_units">contacttime_units</a></code></li>
<li><code><a title="migration.foodlayer.density" href="#migration.foodlayer.density">density</a></code></li>
<li><code><a title="migration.foodlayer.densityUnits" href="#migration.foodlayer.densityUnits">densityUnits</a></code></li>
<li><code><a title="migration.foodlayer.description" href="#migration.foodlayer.description">description</a></code></li>
<li><code><a title="migration.foodlayer.level" href="#migration.foodlayer.level">level</a></code></li>
<li><code><a title="migration.foodlayer.name" href="#migration.foodlayer.name">name</a></code></li>
<li><code><a title="migration.foodlayer.surfacearea" href="#migration.foodlayer.surfacearea">surfacearea</a></code></li>
<li><code><a title="migration.foodlayer.surfaceareaUnits" href="#migration.foodlayer.surfaceareaUnits">surfaceareaUnits</a></code></li>
<li><code><a title="migration.foodlayer.volume" href="#migration.foodlayer.volume">volume</a></code></li>
<li><code><a title="migration.foodlayer.volumeUnits" href="#migration.foodlayer.volumeUnits">volumeUnits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="migration.foodphysics" href="#migration.foodphysics">foodphysics</a></code></h4>
<ul class="two-column">
<li><code><a title="migration.foodphysics.PBC" href="#migration.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="migration.foodphysics.acknowledge" href="#migration.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="migration.foodphysics.contact" href="#migration.foodphysics.contact">contact</a></code></li>
<li><code><a title="migration.foodphysics.copy" href="#migration.foodphysics.copy">copy</a></code></li>
<li><code><a title="migration.foodphysics.description" href="#migration.foodphysics.description">description</a></code></li>
<li><code><a title="migration.foodphysics.get_param" href="#migration.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="migration.foodphysics.hassimulation" href="#migration.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="migration.foodphysics.lastinput" href="#migration.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="migration.foodphysics.lastsimulation" href="#migration.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="migration.foodphysics.level" href="#migration.foodphysics.level">level</a></code></li>
<li><code><a title="migration.foodphysics.migration" href="#migration.foodphysics.migration">migration</a></code></li>
<li><code><a title="migration.foodphysics.name" href="#migration.foodphysics.name">name</a></code></li>
<li><code><a title="migration.foodphysics.refresh" href="#migration.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="migration.foodphysics.update" href="#migration.foodphysics.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="migration.layer" href="#migration.layer">layer</a></code></h4>
<ul class="two-column">
<li><code><a title="migration.layer.C0" href="#migration.layer.C0">C0</a></code></li>
<li><code><a title="migration.layer.Cunit" href="#migration.layer.Cunit">Cunit</a></code></li>
<li><code><a title="migration.layer.D" href="#migration.layer.D">D</a></code></li>
<li><code><a title="migration.layer.Dmodel" href="#migration.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="migration.layer.Dunit" href="#migration.layer.Dunit">Dunit</a></code></li>
<li><code><a title="migration.layer.Foscale" href="#migration.layer.Foscale">Foscale</a></code></li>
<li><code><a title="migration.layer.T" href="#migration.layer.T">T</a></code></li>
<li><code><a title="migration.layer.TK" href="#migration.layer.TK">TK</a></code></li>
<li><code><a title="migration.layer.TKunit" href="#migration.layer.TKunit">TKunit</a></code></li>
<li><code><a title="migration.layer.Tunit" href="#migration.layer.Tunit">Tunit</a></code></li>
<li><code><a title="migration.layer.acknowledge" href="#migration.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="migration.layer.checknumvalue" href="#migration.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="migration.layer.checktextvalue" href="#migration.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="migration.layer.code" href="#migration.layer.code">code</a></code></li>
<li><code><a title="migration.layer.concentration" href="#migration.layer.concentration">concentration</a></code></li>
<li><code><a title="migration.layer.contact" href="#migration.layer.contact">contact</a></code></li>
<li><code><a title="migration.layer.copy" href="#migration.layer.copy">copy</a></code></li>
<li><code><a title="migration.layer.hashlayer" href="#migration.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="migration.layer.help" href="#migration.layer.help">help</a></code></li>
<li><code><a title="migration.layer.k" href="#migration.layer.k">k</a></code></li>
<li><code><a title="migration.layer.kmodel" href="#migration.layer.kmodel">kmodel</a></code></li>
<li><code><a title="migration.layer.kunit" href="#migration.layer.kunit">kunit</a></code></li>
<li><code><a title="migration.layer.l" href="#migration.layer.l">l</a></code></li>
<li><code><a title="migration.layer.lag" href="#migration.layer.lag">lag</a></code></li>
<li><code><a title="migration.layer.layerclass" href="#migration.layer.layerclass">layerclass</a></code></li>
<li><code><a title="migration.layer.layerclass_history" href="#migration.layer.layerclass_history">layerclass_history</a></code></li>
<li><code><a title="migration.layer.lreferencelayer" href="#migration.layer.lreferencelayer">lreferencelayer</a></code></li>
<li><code><a title="migration.layer.lunit" href="#migration.layer.lunit">lunit</a></code></li>
<li><code><a title="migration.layer.material" href="#migration.layer.material">material</a></code></li>
<li><code><a title="migration.layer.mesh" href="#migration.layer.mesh">mesh</a></code></li>
<li><code><a title="migration.layer.migration" href="#migration.layer.migration">migration</a></code></li>
<li><code><a title="migration.layer.n" href="#migration.layer.n">n</a></code></li>
<li><code><a title="migration.layer.name" href="#migration.layer.name">name</a></code></li>
<li><code><a title="migration.layer.nmesh" href="#migration.layer.nmesh">nmesh</a></code></li>
<li><code><a title="migration.layer.nmeshmin" href="#migration.layer.nmeshmin">nmeshmin</a></code></li>
<li><code><a title="migration.layer.permeability" href="#migration.layer.permeability">permeability</a></code></li>
<li><code><a title="migration.layer.pressure" href="#migration.layer.pressure">pressure</a></code></li>
<li><code><a title="migration.layer.rank" href="#migration.layer.rank">rank</a></code></li>
<li><code><a title="migration.layer.referencelayer" href="#migration.layer.referencelayer">referencelayer</a></code></li>
<li><code><a title="migration.layer.relative_resistance" href="#migration.layer.relative_resistance">relative_resistance</a></code></li>
<li><code><a title="migration.layer.relative_thickness" href="#migration.layer.relative_thickness">relative_thickness</a></code></li>
<li><code><a title="migration.layer.resistance" href="#migration.layer.resistance">resistance</a></code></li>
<li><code><a title="migration.layer.resolvename" href="#migration.layer.resolvename">resolvename</a></code></li>
<li><code><a title="migration.layer.rho" href="#migration.layer.rho">rho</a></code></li>
<li><code><a title="migration.layer.rhounit" href="#migration.layer.rhounit">rhounit</a></code></li>
<li><code><a title="migration.layer.simplify" href="#migration.layer.simplify">simplify</a></code></li>
<li><code><a title="migration.layer.split" href="#migration.layer.split">split</a></code></li>
<li><code><a title="migration.layer.substance" href="#migration.layer.substance">substance</a></code></li>
<li><code><a title="migration.layer.thickness" href="#migration.layer.thickness">thickness</a></code></li>
<li><code><a title="migration.layer.type" href="#migration.layer.type">type</a></code></li>
<li><code><a title="migration.layer.update" href="#migration.layer.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="migration.restartfile" href="#migration.restartfile">restartfile</a></code></h4>
<ul class="">
<li><code><a title="migration.restartfile.copy" href="#migration.restartfile.copy">copy</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="migration.restartfile_senspantakar" href="#migration.restartfile_senspantakar">restartfile_senspantakar</a></code></h4>
<ul class="">
<li><code><a title="migration.restartfile_senspantakar.freezeCF" href="#migration.restartfile_senspantakar.freezeCF">freezeCF</a></code></li>
<li><code><a title="migration.restartfile_senspantakar.freezeCx" href="#migration.restartfile_senspantakar.freezeCx">freezeCx</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>