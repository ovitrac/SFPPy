<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>food API documentation</title>
<meta name="description" content="SFPPy Module: Food Layer
Defines **food materials** for migration simulations. Models food as a **0D layer** with:
- **Mass transfer resistance …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>food</code></h1>
</header>
<section id="section-intro">
<p>===============================================================================
SFPPy Module: Food Layer
===============================================================================
Defines <strong>food materials</strong> for migration simulations. Models food as a <strong>0D layer</strong> with:
- <strong>Mass transfer resistance (<code>h</code>)</strong>
- <strong>Partitioning (<code>k0</code>)</strong>
- <strong>Contact time &amp; temperature</strong></p>
<p><strong>Main Components:</strong>
- <strong>Base Class: <code><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></code></strong> (Stores all food-related parameters)
- Defines mass transfer properties (<code>h</code>, <code>k0</code>)
- Implements property propagation (<code>food &gt;&gt; layer</code>)
- <strong>Subclasses:</strong>
- <code><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></code>: General food layer model
- <code><a title="food.setoff" href="#food.setoff">setoff</a></code>: Periodic boundary conditions (e.g., stacked packaging)
- <code><a title="food.nofood" href="#food.nofood">nofood</a></code>: Impervious boundary (no mass transfer)
- <code><a title="food.realcontact" href="#food.realcontact">realcontact</a></code> &amp; <code><a title="food.testcontact" href="#food.testcontact">testcontact</a></code>: Standardized storage and testing conditions</p>
<p><strong>Integration with SFPPy Modules:</strong>
- Works with <code>migration.py</code> as the <strong>left-side boundary</strong> for simulations.
- Can inherit properties from <code>layer.py</code> for <strong>contact temperature propagation</strong>.
- Used in <code>geometry.py</code> when defining food-contacting packaging.</p>
<p>Example:</p>
<pre><code class="language-python">from patankar.food import foodlayer
medium = foodlayer(name=&quot;ethanol&quot;, contacttemperature=(40, &quot;degC&quot;))
</code></pre>
<p>@version: 1.2
@project: SFPPy - SafeFoodPackaging Portal in Python initiative
@author: INRAE\olivier.vitrac@agroparistech.fr
@licence: MIT
@Date: 2023-01-25
@rev: 2025-02-14</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
===============================================================================
SFPPy Module: Food Layer
===============================================================================
Defines **food materials** for migration simulations. Models food as a **0D layer** with:
- **Mass transfer resistance (`h`)**
- **Partitioning (`k0`)**
- **Contact time &amp; temperature**

**Main Components:**
- **Base Class: `foodphysics`** (Stores all food-related parameters)
    - Defines mass transfer properties (`h`, `k0`)
    - Implements property propagation (`food &gt;&gt; layer`)
- **Subclasses:**
    - `foodlayer`: General food layer model
    - `setoff`: Periodic boundary conditions (e.g., stacked packaging)
    - `nofood`: Impervious boundary (no mass transfer)
    - `realcontact` &amp; `testcontact`: Standardized storage and testing conditions

**Integration with SFPPy Modules:**
- Works with `migration.py` as the **left-side boundary** for simulations.
- Can inherit properties from `layer.py` for **contact temperature propagation**.
- Used in `geometry.py` when defining food-contacting packaging.

Example:
```python
from patankar.food import foodlayer
medium = foodlayer(name=&#34;ethanol&#34;, contacttemperature=(40, &#34;degC&#34;))
```


@version: 1.2
@project: SFPPy - SafeFoodPackaging Portal in Python initiative
@author: INRAE\\olivier.vitrac@agroparistech.fr
@licence: MIT
@Date: 2023-01-25
@rev: 2025-02-14

&#34;&#34;&#34;

# Dependencies
import sys
import inspect
import textwrap
import numpy as np
from copy import deepcopy as duplicate

from patankar.layer import check_units, NoUnits, layer # to convert units to SI

__all__ = [&#39;ambient&#39;, &#39;aqueous&#39;, &#39;boiling&#39;, &#39;check_units&#39;, &#39;chemicalaffinity&#39;, &#39;chilled&#39;, &#39;ethanol&#39;, &#39;ethanol50&#39;, &#39;fat&#39;, &#39;foodlayer&#39;, &#39;foodphysics&#39;, &#39;foodproperty&#39;, &#39;frozen&#39;, &#39;get_defined_init_params&#39;, &#39;help_food&#39;, &#39;hotfilled&#39;, &#39;intermediate&#39;, &#39;is_valid_classname&#39;, &#39;layer&#39;, &#39;liquid&#39;, &#39;list_food_classes&#39;, &#39;nofood&#39;, &#39;oven&#39;, &#39;pasteurization&#39;, &#39;perfectlymixed&#39;, &#39;realcontact&#39;, &#39;realfood&#39;, &#39;rolled&#39;, &#39;semisolid&#39;, &#39;setoff&#39;, &#39;simulant&#39;, &#39;solid&#39;, &#39;stacked&#39;, &#39;sterilization&#39;, &#39;tenax&#39;, &#39;testcontact&#39;, &#39;texture&#39;, &#39;water&#39;, &#39;wrap_text&#39;, &#39;yogurt&#39;]

__project__ = &#34;SFPPy&#34;
__author__ = &#34;Olivier Vitrac&#34;
__copyright__ = &#34;Copyright 2022&#34;
__credits__ = [&#34;Olivier Vitrac&#34;]
__license__ = &#34;MIT&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;1.2&#34;
#%% Private Properties and functions

# List of the default SI units used by physical quantity
parametersWithUnits = {&#34;volume&#34;:&#34;m**3&#34;,
                       &#34;surfacearea&#34;:&#34;m**2&#34;,
                       &#34;density&#34;:&#34;kg/m**3&#34;,
                       &#34;contacttemperature&#34;:&#34;degC&#34;,
                       &#34;h&#34;:&#34;m/s&#34;,
                       &#34;k0&#34;:NoUnits,
                       &#34;CF0&#34;:NoUnits,
                       &#34;contacttime&#34;:&#34;s&#34;
                       }
# corresponding protperty names                       }
paramaterNamesWithUnits = [p+&#34;Units&#34; for p in parametersWithUnits.keys()]

# List parameters not used with nofood, noPBC
parametersWithUnits_andfallback = [key for key in parametersWithUnits if key != &#34;contacttime&#34;]

LEVEL_ORDER = {&#34;base&#34;: 0, &#34;root&#34;: 1, &#34;property&#34;:2, &#34;contact&#34;:3, &#34;user&#34;: 4}  # Priority order for sorting

def wrap_text(text, width=20):
    &#34;&#34;&#34;Wraps text within a specified width and returns a list of wrapped lines.&#34;&#34;&#34;
    if not isinstance(text, str):
        return [str(text)]
    return textwrap.wrap(text, width) or [&#34;&#34;]  # Ensure at least one line

def get_defined_init_params(instance):
    &#34;&#34;&#34;Returns which parameters from parametersWithUnits are defined in the instance.&#34;&#34;&#34;
    return [param for param in parametersWithUnits.keys() if hasattr(instance, param)]

def is_valid_classname(name):
    &#34;&#34;&#34;Returns True if class name is valid (not private/internal).&#34;&#34;&#34;
    return name.isidentifier() and not name.startswith(&#34;_&#34;)  # Exclude _10, __, etc.

def list_food_classes():
    &#34;&#34;&#34;
    Lists all classes in the &#39;food&#39; module with:
    - name and description
    - level (class attribute)
    - Inheritance details
    - Parameters from parametersWithUnits that are set in the instance
    &#34;&#34;&#34;
    subclasses_info = []
    current_module = sys.modules[__name__]  # Reference to the food module

    for name, obj in inspect.getmembers(current_module, inspect.isclass):
        if obj.__module__ == current_module.__name__ and is_valid_classname(name):  # Ensure valid class name
            try:
                instance = obj()  # Try to instantiate
                init_params = get_defined_init_params(instance)
                level = getattr(obj, &#34;level&#34;, &#34;other&#34;)  # Default to &#34;other&#34; if no level is set

                class_info = {
                    &#34;Class Name&#34;: wrap_text(name),
                    &#34;Name&#34;: wrap_text(getattr(instance, &#34;name&#34;, &#34;N/A&#34;)),
                    &#34;Description&#34;: wrap_text(getattr(instance, &#34;description&#34;, &#34;N/A&#34;)),
                    &#34;Level&#34;: wrap_text(level),
                    &#34;Inheritance&#34;: wrap_text(&#34;, &#34;.join(base.__name__ for base in obj.__bases__)),
                    &#34;Init Params&#34;: wrap_text(&#34;, &#34;.join(init_params) if init_params else &#34;&#34;),
                    &#34;Level Sorting&#34;: LEVEL_ORDER.get(level, 3)  # Used for sorting, not for table output
                }
                subclasses_info.append(class_info)
            except TypeError:
                class_info = {
                    &#34;Class Name&#34;: wrap_text(name),
                    &#34;Name&#34;: [&#34;N/A&#34;],
                    &#34;Description&#34;: [&#34;N/A&#34;],
                    &#34;Level&#34;: wrap_text(getattr(obj, &#34;level&#34;, &#34;other&#34;)),
                    &#34;Inheritance&#34;: wrap_text(&#34;, &#34;.join(base.__name__ for base in obj.__bases__)),
                    &#34;Init Params&#34;: wrap_text(&#34;⚠️ Cannot instantiate&#34;),
                    &#34;Level Sorting&#34;: LEVEL_ORDER.get(getattr(obj, &#34;level&#34;, &#34;other&#34;), 3)
                }
                subclasses_info.append(class_info)

    # **Sort first by level priority, then alphabetically within each level**
    subclasses_info.sort(key=lambda x: (x[&#34;Level Sorting&#34;], x[&#34;Class Name&#34;]))

    return subclasses_info

def help_food():
    &#34;&#34;&#34;
    Prints all food-related classes with relevant attributes in a **formatted Markdown table**.
    &#34;&#34;&#34;
    derived = list_food_classes()

    # Define table headers (excluding &#34;Level Sorting&#34; because it&#39;s only used for sorting)
    headers = [&#34;Class Name&#34;, &#34;Name&#34;, &#34;Description&#34;, &#34;Level&#34;, &#34;Inheritance&#34;, &#34;Init Params&#34;]

    # Find the maximum number of lines in any wrapped column (excluding &#34;Level Sorting&#34;)
    max_lines_per_row = [
        max(len(value) for key, value in row.items() if key != &#34;Level Sorting&#34;)
        for row in derived
    ]

    # Convert dictionary entries to lists and ensure they all have the same number of lines
    formatted_rows = []
    for row, max_lines in zip(derived, max_lines_per_row):
        wrapped_row = {
            key: (value if isinstance(value, list) else [value]) + [&#34;&#34;] * (max_lines - len(value))
            for key, value in row.items() if key != &#34;Level Sorting&#34;  # Exclude &#34;Level Sorting&#34;
        }
        for i in range(max_lines):  # Transpose wrapped lines into multiple rows
            formatted_rows.append([wrapped_row[key][i] for key in headers])

    # Compute column widths dynamically
    col_widths = [max(len(str(cell)) for cell in col) for col in zip(headers, *formatted_rows)]

    # Create a formatting row template
    row_format = &#34;| &#34; + &#34; | &#34;.join(f&#34;{{:&lt;{w}}}&#34; for w in col_widths) + &#34; |&#34;

    # Print the table header
    print(row_format.format(*headers))
    print(&#34;|-&#34; + &#34;-|-&#34;.join(&#34;-&#34; * w for w in col_widths) + &#34;-|&#34;)

    # Print all table rows
    for row in formatted_rows:
        print(row_format.format(*row))


#%% Base physics class
# -------------------------------------------------------------------
# Base Class to convert class defaults to instance attributes
# -------------------------------------------------------------------
class foodphysics:
    &#34;&#34;&#34;
    Base class that automatically assigns instance attributes from class defaults,
    except for the &#39;description&#39; attribute.
    Check the physical meaning of quantities with units.

    Implemented methods include:
        - refresh() validates all quantities before a simulation
        - update(name=&#34;new name&#34;, description=&#34;new description&#34;,parameter1=value)
          assigns new values to physical parameters and attributes
        - getparam() returns physical parameters even if they undefined
    Available properties:
        PBC returns True in periodic boundary conditions are enforced (setoff)
        impervious returns True if impervious boundary condition is appled (no food)
    &#34;&#34;&#34;

    # General descriptors
    description = &#34;Root physics class used to implement food and mass transfer physics&#34;  # Remains as class attribute
    name = &#34;food physics&#34;
    level = &#34;base&#34;

    # ------------------------------------------------------
    # Transfer rules for food1 &gt;&gt; food2 and food1 &gt;&gt; result
    # ------------------------------------------------------

    # Mapping of properties to their respective categories
    _list_categories = {
        &#34;contacttemperature&#34;: &#34;contact&#34;,
        &#34;contacttime&#34;: &#34;contact&#34;,
        &#34;surfacearea&#34;: &#34;geometry&#34;,
        &#34;volume&#34;: &#34;geometry&#34;
    }

    # Rules for property transfer based on object type
    _transferable_properties = {
        &#34;contacttemperature&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: True,
                &#34;checkNumPy&#34;: False,
                &#34;as&#34;: &#34;&#34;,
                &#34;prototype&#34;: None,
                &#34;category&#34;: &#34;contact&#34;
            },
            &#34;layer&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;T&#34;,
                &#34;prototype&#34;: None
            }
        },
        &#34;contacttime&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: True,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;&#34;,
                &#34;prototype&#34;: None
            },
            &#34;SensPatankarResult&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;t&#34;,
                &#34;prototype&#34;: None
            }
        },
        &#34;surfacearea&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: False,
                &#34;as&#34;: &#34;surfacearea&#34;,
                &#34;prototype&#34;: None
            }
        },
        &#34;volume&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;&#34;,
                &#34;prototype&#34;: None
            }
        }
    }


    def __init__(self, **kwargs):
        &#34;&#34;&#34;general constructor&#34;&#34;&#34;

        # local import
        from patankar.migration import SensPatankarResult

        # numeric validator
        def numvalidator(key,value):
            if key in parametersWithUnits:          # the parameter is a physical quantity
                if isinstance(value,tuple):         # the supplied value as unit
                    value,_ = check_units(value)    # we convert to SI, we drop the units
                if not isinstance(value,np.ndarray):
                    value = np.array([value])       # we force NumPy class
            return value

        # Iterate through the MRO (excluding foodphysics and object)
        for cls in reversed(self.__class__.__mro__):
            if cls in (foodphysics, object):
                continue
            # For each attribute defined at the class level,
            # if it is not &#39;description&#39;, not callable, and not a dunder, set it as an instance attribute.
            for key, value in cls.__dict__.items(): # we loop on class attributes
                if key in (&#34;description&#34;,&#34;level&#34;) or key.startswith(&#34;__&#34;) or callable(value):
                    continue
                if key not in kwargs:
                    setattr(self, key, numvalidator(key,value))
        # Now update/override with any keyword arguments provided at instantiation.
        for key, value in kwargs.items():
            value = numvalidator(key,value)
            if key not in paramaterNamesWithUnits: # we protect the values of units (they are SI, they cannot be changed)
                setattr(self, key, value)
        # we initialize the acknowlegment process for future property propagation
        self._hasbeeninherited = {}
        # we initialize the _simstate storing the last simulation result available
        self._simstate = None # simulation results
        self._inpstate = None # their inputs
        # For cooperative multiple inheritance, call the next __init__ if it exists.
        super().__init__()
        # Define actual class references to avoid circular dependency issues
        if self.__class__._transferable_properties[&#34;contacttemperature&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] is None:
            self.__class__._transferable_properties[&#34;contacttemperature&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics
            self.__class__._transferable_properties[&#34;contacttemperature&#34;][&#34;layer&#34;][&#34;prototype&#34;] = layer
            self.__class__._transferable_properties[&#34;contacttime&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics
            self.__class__._transferable_properties[&#34;contacttime&#34;][&#34;SensPatankarResult&#34;][&#34;prototype&#34;] = SensPatankarResult
            self.__class__._transferable_properties[&#34;surfacearea&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics
            self.__class__._transferable_properties[&#34;volume&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics

    # ------- [properties to access/modify simstate] --------
    @property
    def lastinput(self):
        &#34;&#34;&#34;Getter for last layer input.&#34;&#34;&#34;
        return self._inpstate

    @lastinput.setter
    def lastinput(self, value):
        &#34;&#34;&#34;Setter for last layer input.&#34;&#34;&#34;
        self._inpstate = value

    @property
    def lastsimulation(self):
        &#34;&#34;&#34;Getter for last simulation results.&#34;&#34;&#34;
        return self._simstate

    @lastsimulation.setter
    def lastsimulation(self, value):
        &#34;&#34;&#34;Setter for last simulation results.&#34;&#34;&#34;
        self._simstate = value

    @property
    def hassimulation(self):
        &#34;&#34;&#34;Returns True if a simulation exists&#34;&#34;&#34;
        return self.lastsimulation is not None


    # ------- [inheritance registration mechanism] --------
    def acknowledge(self, what=None, category=None):
        &#34;&#34;&#34;
        Register inherited properties under a given category.

        Parameters:
        -----------
        what : str or list of str or a set
            The properties or attributes that have been inherited.
        category : str
            The category under which the properties are grouped.

        Example:
        --------
        &gt;&gt;&gt; b = B()
        &gt;&gt;&gt; b.acknowledge(what=&#34;volume&#34;, category=&#34;geometry&#34;)
        &gt;&gt;&gt; b.acknowledge(what=[&#34;surfacearea&#34;, &#34;diameter&#34;], category=&#34;geometry&#34;)
        &gt;&gt;&gt; print(b._hasbeeninherited)
        {&#39;geometry&#39;: {&#39;volume&#39;, &#39;surfacearea&#39;, &#39;diameter&#39;}}
        &#34;&#34;&#34;
        if category is None or what is None:
            raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
        if isinstance(what, str):
            what = {what}  # Convert string to a set
        elif isinstance(what, list):
            what = set(what)  # Convert list to a set for uniqueness
        elif not isinstance(what,set):
            raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
        if category not in self._hasbeeninherited:
            self._hasbeeninherited[category] = set()
        self._hasbeeninherited[category].update(what)


    def refresh(self):
        &#34;&#34;&#34;refresh all physcal paramaters after instantiation&#34;&#34;&#34;
        for key, value in self.__dict__.items():    # we loop on instance attributes
            if key in parametersWithUnits:          # the parameter is a physical quantity
                if isinstance(value,tuple):         # the supplied value as unit
                    value = check_units(value)[0]   # we convert to SI, we drop the units
                    setattr(self,key,value)
                if not isinstance(value,np.ndarray):
                    value = np.array([value])      # we force NumPy class
                    setattr(self,key,value)

    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update modifiable parameters of the foodphysics object.

        Modifiable Parameters:
            - name (str): New name for the object.
            - description (str): New description.
            - volume (float or tuple): Volume (can be tuple like (1, &#34;L&#34;)).
            - surfacearea (float or tuple): Surface area (can be tuple like (1, &#34;cm^2&#34;)).
            - density (float or tuple): Density (can be tuple like (1000, &#34;kg/m^3&#34;)).
            - CF0 (float or tuple): Initial concentration in the food.
            - contacttime (float or tuple): Contact time (can be tuple like (1, &#34;h&#34;)).
            - contacttemperature (float or tuple): Temperature (can be tuple like (25, &#34;degC&#34;)).
            - h (float or tuple): Mass transfer coefficient (can be tuple like (1e-6,&#34;m/s&#34;)).
            - k0 (float or tuple): Henri-like coefficient for the food (can be tuple like (1,&#34;a.u.&#34;)).

        &#34;&#34;&#34;
        if not kwargs:  # shortcut
            return self # for chaining
        def checkunits(value):
            &#34;&#34;&#34;Helper function to convert physical quantities to SI.&#34;&#34;&#34;
            if isinstance(value, tuple) and len(value) == 2:
                scale = check_units(value)[0]  # Convert to SI, drop unit
                return np.array([scale], dtype=float)  # Ensure NumPy array
            elif isinstance(value, (int, float, np.ndarray)):
                return np.array([value], dtype=float)  # Ensure NumPy array
            else:
                raise ValueError(f&#34;Invalid value for physical quantity: {value}&#34;)
        # Update `name` and `description` if provided
        if &#34;name&#34; in kwargs:
            self.name = str(kwargs[&#34;name&#34;])
        if &#34;description&#34; in kwargs:
            self.description = str(kwargs[&#34;description&#34;])
        # Update physical properties
        for key in parametersWithUnits.keys():
            if key in kwargs:
                value = kwargs[key]
                setattr(self, key, checkunits(value))  # Ensure NumPy array in SI
        return self  # Return self for method chaining if needed

    def get_param(self, key, default=None, acceptNone=True):
        &#34;&#34;&#34;Retrieve instance attribute with a default fallback if enabled.&#34;&#34;&#34;
        paramdefaultvalue = 1
        if isinstance(self,(setoff,nofood)):
            if key in parametersWithUnits_andfallback:
                value =  self.__dict__.get(key, paramdefaultvalue) if default is None else self.__dict__.get(key, default)
                if isinstance(value,np.ndarray):
                    value = value.item()
                if value is None and not acceptNone:
                    value = paramdefaultvalue if default is None else default
                return np.array([value])
            if key in paramaterNamesWithUnits:
                return self.__dict__.get(key, parametersWithUnits[key]) if default is None else self.__dict__.get(key, default)
        if key in parametersWithUnits:
            if hasattr(self, key):
                return getattr(self,key)
            else:
                raise KeyError(
                    f&#34;Missing property: &#39;{key}&#39; in instance of class &#39;{self.__class__.__name__}&#39;.\n&#34;
                    f&#34;To define it, use one of the following methods:\n&#34;
                    f&#34;  - Direct assignment:   object.{key} = value\n&#34;
                    f&#34;  - Using update method: object.update({key}=value)\n&#34;
                    f&#34;Note: The value can also be provided as a tuple (value, &#39;unit&#39;).&#34;
                )
        elif key in paramaterNamesWithUnits:
            return self.__dict__.get(key, paramaterNamesWithUnits[key]) if default is None else self.__dict__.get(key, default)
        raise KeyError(f&#39;Use getattr(&#34;{key}&#34;) to retrieve the value of {key}&#39;)

    def __repr__(self):
        &#34;&#34;&#34;Formatted string representation of the foodphysics object.&#34;&#34;&#34;
        # refresh all definitions
        self.refresh()
        # Header with name and description
        repr_str = f&#39;Food object &#34;{self.name}&#34; ({self.description}) with properties:\n&#39;

        # Helper function to extract a numerical value safely
        def format_value(value):
            &#34;&#34;&#34;Ensure the value is a float or a single-item NumPy array.&#34;&#34;&#34;
            if isinstance(value, np.ndarray):
                return value.item() if value.size == 1 else value[0]  # Ensure scalar representation
            elif value is None:
                return value
            return float(value)
        # Loop through parameters that should be printed
        for key, unit in parametersWithUnits.items():
            if hasattr(self, key):  # Print only defined parameters
                value = format_value(getattr(self, key))
                unit_str = self.get_param(key+&#34;Units&#34;, parametersWithUnits[key])  # Retrieve unit safely
                if value is not None:
                    repr_str += f&#34;{key:15s}: {value:0.8g} [{unit_str}]\n&#34;
        print(repr_str.strip())  # Remove trailing newline
        return str(self)


    def __str__(self):
        &#34;&#34;&#34;Formatted string representation of the property&#34;&#34;&#34;
        simstr = &#39; [simulated]&#39; if self.hassimulation else &#34;&#34;
        return f&#34;&lt;{self.__class__.__name__}: {self.name}&gt;{simstr}&#34;

    def copy(self,**kwargs):
        &#34;&#34;&#34;Creates a deep copy of the current food instance.&#34;&#34;&#34;
        return duplicate(self).update(**kwargs)


    @property
    def PBC(self):
        &#34;&#34;&#34;
        Returns true if h is not defined or None
            This property is used to identified periodic boundary condition also called setoff mass transfer.

        &#34;&#34;&#34;
        if not hasattr(self,&#34;h&#34;):
            return None
        htmp = getattr(self,&#34;h&#34;)
        if isinstance(htmp,np.ndarray):
            htmp = htmp.item()
        return htmp is None


    # --------------------------------------------------------------------
    # For convenience, several operators have been overloaded
    #   medium &gt;&gt; packaging      # sets the volume and the surfacearea
    #   medium &gt;&gt; material       # propgates the contact temperature from the medium to the material
    #   sol = medium &lt;&lt; material # simulate migration from the material to the medium
    # --------------------------------------------------------------------

    # method: medium._to(material) and its associated operator &gt;&gt;
    def _to(self, other = None):
        &#34;&#34;&#34;
        Transfers inherited properties to another object based on predefined rules.

        Parameters:
        -----------
        other : object
            The recipient object that will receive the transferred properties.

        Notes:
        ------
        - Only properties listed in `_transferable_properties` are transferred.
        - A property can only be transferred if `other` matches the expected class.
        - The property may have a different name in `other` as defined in `as`.
        - If `onlyifinherited` is True, the property must have been inherited by `self`.
        - If `checkNumPy` is True, ensures NumPy array compatibility.
        - Updates `other`&#39;s `_hasbeeninherited` tracking.
        &#34;&#34;&#34;
        for prop, classes in self._transferable_properties.items():
            if prop not in self._list_categories:
                continue  # Skip properties not categorized

            category = self._list_categories[prop]

            for class_name, rules in classes.items():

                if not isinstance(other, rules[&#34;prototype&#34;]):
                    continue  # Skip if other is not an instance of the expected prototype class

                if rules[&#34;onlyifinherited&#34;] and category not in self._hasbeeninherited:
                    continue  # Skip if property must be inherited but is not

                if rules[&#34;onlyifinherited&#34;] and prop not in self._hasbeeninherited[category]:
                    continue  # Skip if the specific property has not been inherited

                if not hasattr(self, prop):
                    continue  # Skip if the property does not exist on self

                # Determine the target attribute name in other
                target_attr = rules[&#34;as&#34;] if rules[&#34;as&#34;] else prop

                # Retrieve the property value
                value = getattr(self, prop)

                # Handle NumPy array check
                if rules[&#34;checkNumPy&#34;] and hasattr(other, target_attr):
                    existing_value = getattr(other, target_attr)
                    if isinstance(existing_value, np.ndarray):
                        value = np.full(existing_value.shape, value)

                # Assign the value to other
                setattr(other, target_attr, value)

                # Register the transfer in other’s inheritance tracking
                other.acknowledge(what=target_attr, category=category)

                # to chain &gt;&gt;
                return other

    def __rshift__(self, other):
        &#34;&#34;&#34;Overloads &gt;&gt; to propagate to other.&#34;&#34;&#34;
        return self._to(other)

    # migration method
    def migration(self,material,**kwargs):
        from patankar.migration import senspatankar
        self._to(material) # propagate contact conditions first
        return senspatankar(material,self,**kwargs)

    def contact(self,material,**kwargs):
        return self.migration(self,material,**kwargs)


# %% Root classes
# -------------------------------------------------------------------
# ROOT CLASSES
#   - The foodlayer class represents physically the food
#   - The chemicalaffinity class represents the polarity of the medium (with respect to the substance)
#   - The texture class represents the mass transfer reistance between the food and the material in contact
#   - The nofood class enforces an impervious boundary condition on the food side preventing any transfer.
#     This class is useful to simulate mass transfer within the packaging layer in the absence of food.
#   - The setoff class enforces periodic conditions such as when packaging are stacked together.
# -------------------------------------------------------------------

class foodlayer(foodphysics):
    &#34;&#34;&#34;
    Foodlayer class is a generic class to define food as a 1D layer in a symmetric manner with layer class
    applicable to materials in contact.
    Since mass transfer are much faster in the food than in the materials in contact, food is represented
    as an almost 0D layer. Only a mass transfer resistance is applied at the food-material interface
    controlled by the mass transfer coefficient h. A Henri-like coefficient k0 controls the eventual
    partitioning of the substance between the food and the layer of the materials.

    Food are geometrically defined by their volume and surface area in contact with the material.

    Contact time (contacttime) and contact temperature (contacttemperature) are defined via foodlayer.

    &#34;&#34;&#34;
    level = &#34;root&#34;
    description = &#34;root food class&#34;  # Remains as class attribute
    name = &#34;generic food layer&#34;
    volume,volumeUnits = check_units((1,&#34;dm**3&#34;))
    surfacearea,surfaceareaUnits = check_units((6,&#34;dm**2&#34;))
    density,densityUnits = check_units((1000,&#34;kg/m**3&#34;))
    CF0,CF0units = check_units((0,NoUnits))  # initial concentration (arbitrary units)
    contacttime, contacttime_units = check_units((10,&#34;days&#34;))
    contactemperature,contactemperatureUnits = check_units((40,&#34;degC&#34;),ExpectedUnits=&#34;degC&#34;) # temperature ALWAYS in °C


class texture(foodphysics):
    &#34;&#34;&#34;Parent food texture class&#34;&#34;&#34;
    description = &#34;default class texture&#34;
    name = &#34;undefined&#34;
    level = &#34;root&#34;
    h = 1e-3

class chemicalaffinity(foodphysics):
    &#34;&#34;&#34;Parent chemical affinity class&#34;&#34;&#34;
    description = &#34;default chemical affinity&#34;
    name = &#34;undefined&#34;
    level = &#34;root&#34;
    k0 = 1

class nofood(foodphysics):
    &#34;&#34;&#34;Impervious boundary condition&#34;&#34;&#34;
    description = &#34;impervious boundary condition&#34;
    name = &#34;undefined&#34;
    level = &#34;root&#34;
    h = 0

class setoff(foodphysics):
    &#34;&#34;&#34;periodic boundary conditions&#34;&#34;&#34;
    description = &#34;periodic boundary conditions&#34;
    name = &#34;setoff&#34;
    level = &#34;root&#34;
    h = None

class realcontact(foodphysics):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;real storage conditions&#34;
    name = &#34;contact conditions&#34;
    level = &#34;root&#34;
    [contacttime,contacttimeUnits] = check_units((200,&#34;days&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((25,&#34;degC&#34;))

class testcontact(foodphysics):
    &#34;&#34;&#34;conditions of migration testing&#34;&#34;&#34;
    description = &#34;migration testing conditions&#34;
    name = &#34;migration testing&#34;
    level = &#34;root&#34;
    [contacttime,contacttimeUnits] = check_units((10,&#34;days&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((40,&#34;degC&#34;))

# %% Property classes
# -------------------------------------------------------------------
# SECOND LEVEL CLASSES
# This classes are used as keyword to define new food with a combination of properties.
# -------------------------------------------------------------------

# Food/chemical properties
class foodproperty(foodlayer):
    &#34;&#34;&#34;Class wrapper of food properties&#34;&#34;&#34;
    level=&#34;property&#34;

class realfood(foodproperty):
    &#34;&#34;&#34;Core real food class (second level)&#34;&#34;&#34;
    description = &#34;real food class&#34;

class simulant(foodproperty):
    &#34;&#34;&#34;Core food simulant class (second level)&#34;&#34;&#34;
    name = &#34;generic food simulant&#34;
    description = &#34;food simulant&#34;

class solid(foodproperty):
    &#34;&#34;&#34;Solid food texture&#34;&#34;&#34;
    name = &#34;solid food&#34;
    description = &#34;solid food products&#34;
    [h,hUnits] = check_units((1e-8,&#34;m/s&#34;))

class semisolid(texture):
    &#34;&#34;&#34;Semi-solid food texture&#34;&#34;&#34;
    name = &#34;solid food&#34;
    description = &#34;solid food products&#34;
    [h,hUnits] = check_units((1e-7,&#34;m/s&#34;))

class liquid(texture):
    &#34;&#34;&#34;Liquid food texture&#34;&#34;&#34;
    name = &#34;liquid food&#34;
    description = &#34;liquid food products&#34;
    [h,hUnits] = check_units((1e-6,&#34;m/s&#34;))

class perfectlymixed(texture):
    &#34;&#34;&#34;Perfectly mixed liquid (texture)&#34;&#34;&#34;
    name = &#34;perfectly mixed liquid&#34;
    description = &#34;maximize mixing, minimize the mass transfer boundary layer&#34;
    [h,hUnits] = check_units((1e-4,&#34;m/s&#34;))

class fat(chemicalaffinity):
    &#34;&#34;&#34;Fat contact&#34;&#34;&#34;
    name = &#34;fat contact&#34;
    description = &#34;maximize mass transfer&#34;
    [k0,k0Units] = check_units((1,NoUnits))

class aqueous(chemicalaffinity):
    &#34;&#34;&#34;Aqueous food contact&#34;&#34;&#34;
    name = &#34;aqueous contact&#34;
    description = &#34;minimize mass transfer&#34;
    [k0,k0Units] = check_units((1000,NoUnits))

class intermediate(chemicalaffinity):
    &#34;&#34;&#34;Intermediate chemical affinity&#34;&#34;&#34;
    name = &#34;intermediate&#34;
    description = &#34;intermediate chemical affinity&#34;
    [k0,k0Units] = check_units((10,NoUnits))

# Contact conditions

class chilled(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;ambient storage conditions&#34;
    name = &#34;ambient&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((30,&#34;days&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((4,&#34;degC&#34;))

class frozen(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;freezing storage conditions&#34;
    name = &#34;frrozen&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((6,&#34;months&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((-20,&#34;degC&#34;))

class ambient(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;ambient storage conditions&#34;
    name = &#34;ambient&#34;
    level = &#34;contact&#34;
    #[contacttime,contacttimeUnits] = check_units((200,&#34;days&#34;))
    #[contacttemperature,contacttemperatureUnits] = check_units((25,&#34;degC&#34;))

class hotfilled(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;hot-filling conditions&#34;
    name = &#34;hotfilled&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((20,&#34;min&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((80,&#34;degC&#34;))

class boiling(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;boiling conditions&#34;
    name = &#34;boiling&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((30,&#34;min&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((100,&#34;degC&#34;))

class pasteurization(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;pasteurization conditions&#34;
    name = &#34;pasteurization&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((20,&#34;min&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((100,&#34;degC&#34;))

class sterilization(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;sterilization conditions&#34;
    name = &#34;sterilization&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((20,&#34;min&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((121,&#34;degC&#34;))

class oven(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;oven conditions&#34;
    name = &#34;oven&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((1,&#34;hour&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((180,&#34;degC&#34;))


# %% End-User classes
# -------------------------------------------------------------------
# THIRD LEVEL CLASSES
# Theses classes correspond to real cases and can be hybridized to
# derive new classes, for instance, for a specific brand of yoghurt.
# -------------------------------------------------------------------
class stacked(setoff):
    &#34;&#34;&#34;stacked storage&#34;&#34;&#34;
    name = &#34;stacked&#34;
    description = &#34;storage in stacks&#34;
    level = &#34;user&#34;

class rolled(setoff):
    &#34;&#34;&#34;rolled storage&#34;&#34;&#34;
    name = &#34;rolled&#34;
    description = &#34;storage in rolls&#34;
    level = &#34;user&#34;

class ethanol(simulant, perfectlymixed, fat):
    &#34;&#34;&#34;Ethanol food simulant&#34;&#34;&#34;
    name = &#34;ethanol&#34;
    description = &#34;ethanol = from pure ethanol down to ethanol 95%&#34;
    level = &#34;user&#34;

class ethanol50(simulant, perfectlymixed, intermediate):
    &#34;&#34;&#34;Ethanol 50 food simulant&#34;&#34;&#34;
    name = &#34;ethanol 50&#34;
    description = &#34;ethanol 50, food simulant of dairy products&#34;
    level = &#34;user&#34;

class water(simulant, perfectlymixed, aqueous):
    &#34;&#34;&#34;Water food simulant&#34;&#34;&#34;
    name = &#34;water&#34;
    description = &#34;water food simulant&#34;
    level = &#34;user&#34;

class tenax(simulant, solid, fat):
    &#34;&#34;&#34;Tenax(r) food simulant&#34;&#34;&#34;
    name = &#34;Tenax&#34;
    description = &#34;simulant of dry food products&#34;
    level = &#34;user&#34;

class yogurt(realfood, semisolid, ethanol50):
    &#34;&#34;&#34;Yogurt as an example of real food&#34;&#34;&#34;
    description = &#34;yogurt&#34;
    level = &#34;user&#34;
    [k0,k0Units] = check_units((1,NoUnits))
    volume,volumeUnits = check_units((125,&#34;mL&#34;))

    # def __init__(self, name=&#34;no brand&#34;, volume=None, **kwargs):
    #     # Prepare a parameters dict: if a value is provided (e.g. volume), use it;
    #     # otherwise, the default (from class) is used.
    #     params = {}
    #     if volume is not None:
    #         params[&#39;volume&#39;] = volume
    #     params[&#39;name&#39;] = name
    #     params.update(kwargs)
    #     super().__init__(**params)

# -------------------------------------------------------------------
# Example usage (for debugging)
# -------------------------------------------------------------------
if __name__ == &#39;__main__&#39;:
    F = foodlayer()
    E95 = ethanol()
    Y = yogurt()
    YF = yogurt(name=&#34;danone&#34;, volume=(150,&#34;mL&#34;))
    YF.description = &#34;yogurt with fruits&#34;  # You can still update the description on the instance if needed

    print(&#34;\n&#34;,repr(F),&#34;\n&#34;*2)
    print(&#34;\n&#34;,repr(E95),&#34;\n&#34;*2)
    print(&#34;\n&#34;,repr(Y),&#34;\n&#34;*2)
    print(&#34;\n&#34;,repr(YF),&#34;\n&#34;*2)

    # How to define a new food easily:
    class sandwich(realfood, solid, fat):
        name = &#34;sandwich&#34;
    S = sandwich()
    print(&#34;\n&#34;, repr(S))

    help_food()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="food.check_units"><code class="name flex">
<span>def <span class="ident">check_units</span></span>(<span>value, ProvidedUnits=None, ExpectedUnits=None, defaulttempUnits='degC')</span>
</code></dt>
<dd>
<div class="desc"><p>check numeric inputs and convert them to SI units</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_units(value,ProvidedUnits=None,ExpectedUnits=None,defaulttempUnits=&#34;degC&#34;):
    &#34;&#34;&#34; check numeric inputs and convert them to SI units &#34;&#34;&#34;
    # by convention, NumPy arrays and None are return unchanged (prevent nesting)
    if isinstance(value,np.ndarray) or value is None:
        return value,UnknownUnits
    if isinstance(value,tuple):
        if len(value) != 2:
            raise ValueError(&#39;value should be a tuple: (value,&#34;unit&#34;&#39;)
        ProvidedUnits = value[1]
        value = value[0]
    if isinstance(value,list): # the function is vectorized
        value = np.array(value)
    if {&#34;degC&#34;, &#34;K&#34;} &amp; {ProvidedUnits, ExpectedUnits}: # the value is a temperature
        ExpectedUnits = defaulttempUnits if ExpectedUnits is None else ExpectedUnits
        ProvidedUnits = ExpectedUnits if ProvidedUnits is None else ProvidedUnits
        if ProvidedUnits==&#34;degC&#34; and ExpectedUnits==&#34;K&#34;:
            value += constants[&#34;T0K&#34;]
        elif ProvidedUnits==&#34;K&#34; and ExpectedUnits==&#34;degC&#34;:
            value -= constants[&#34;T0K&#34;]
        return np.array([value]),ExpectedUnits
    else: # the value is not a temperature
        ExpectedUnits = NoUnits if ExpectedUnits is None else ExpectedUnits
        if (ProvidedUnits==ExpectedUnits) or (ProvidedUnits==NoUnits) or (ExpectedUnits==None):
            conversion =1               # no conversion needed
            units = ExpectedUnits if ExpectedUnits is not None else NoUnits
        else:
            q0,conversion,units = toSI(qSI(1,ProvidedUnits))
        return np.array([value*conversion]),units</code></pre>
</details>
</dd>
<dt id="food.get_defined_init_params"><code class="name flex">
<span>def <span class="ident">get_defined_init_params</span></span>(<span>instance)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns which parameters from parametersWithUnits are defined in the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_defined_init_params(instance):
    &#34;&#34;&#34;Returns which parameters from parametersWithUnits are defined in the instance.&#34;&#34;&#34;
    return [param for param in parametersWithUnits.keys() if hasattr(instance, param)]</code></pre>
</details>
</dd>
<dt id="food.help_food"><code class="name flex">
<span>def <span class="ident">help_food</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints all food-related classes with relevant attributes in a <strong>formatted Markdown table</strong>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def help_food():
    &#34;&#34;&#34;
    Prints all food-related classes with relevant attributes in a **formatted Markdown table**.
    &#34;&#34;&#34;
    derived = list_food_classes()

    # Define table headers (excluding &#34;Level Sorting&#34; because it&#39;s only used for sorting)
    headers = [&#34;Class Name&#34;, &#34;Name&#34;, &#34;Description&#34;, &#34;Level&#34;, &#34;Inheritance&#34;, &#34;Init Params&#34;]

    # Find the maximum number of lines in any wrapped column (excluding &#34;Level Sorting&#34;)
    max_lines_per_row = [
        max(len(value) for key, value in row.items() if key != &#34;Level Sorting&#34;)
        for row in derived
    ]

    # Convert dictionary entries to lists and ensure they all have the same number of lines
    formatted_rows = []
    for row, max_lines in zip(derived, max_lines_per_row):
        wrapped_row = {
            key: (value if isinstance(value, list) else [value]) + [&#34;&#34;] * (max_lines - len(value))
            for key, value in row.items() if key != &#34;Level Sorting&#34;  # Exclude &#34;Level Sorting&#34;
        }
        for i in range(max_lines):  # Transpose wrapped lines into multiple rows
            formatted_rows.append([wrapped_row[key][i] for key in headers])

    # Compute column widths dynamically
    col_widths = [max(len(str(cell)) for cell in col) for col in zip(headers, *formatted_rows)]

    # Create a formatting row template
    row_format = &#34;| &#34; + &#34; | &#34;.join(f&#34;{{:&lt;{w}}}&#34; for w in col_widths) + &#34; |&#34;

    # Print the table header
    print(row_format.format(*headers))
    print(&#34;|-&#34; + &#34;-|-&#34;.join(&#34;-&#34; * w for w in col_widths) + &#34;-|&#34;)

    # Print all table rows
    for row in formatted_rows:
        print(row_format.format(*row))</code></pre>
</details>
</dd>
<dt id="food.is_valid_classname"><code class="name flex">
<span>def <span class="ident">is_valid_classname</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if class name is valid (not private/internal).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_classname(name):
    &#34;&#34;&#34;Returns True if class name is valid (not private/internal).&#34;&#34;&#34;
    return name.isidentifier() and not name.startswith(&#34;_&#34;)  # Exclude _10, __, etc.</code></pre>
</details>
</dd>
<dt id="food.list_food_classes"><code class="name flex">
<span>def <span class="ident">list_food_classes</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all classes in the 'food' module with:
- name and description
- level (class attribute)
- Inheritance details
- Parameters from parametersWithUnits that are set in the instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_food_classes():
    &#34;&#34;&#34;
    Lists all classes in the &#39;food&#39; module with:
    - name and description
    - level (class attribute)
    - Inheritance details
    - Parameters from parametersWithUnits that are set in the instance
    &#34;&#34;&#34;
    subclasses_info = []
    current_module = sys.modules[__name__]  # Reference to the food module

    for name, obj in inspect.getmembers(current_module, inspect.isclass):
        if obj.__module__ == current_module.__name__ and is_valid_classname(name):  # Ensure valid class name
            try:
                instance = obj()  # Try to instantiate
                init_params = get_defined_init_params(instance)
                level = getattr(obj, &#34;level&#34;, &#34;other&#34;)  # Default to &#34;other&#34; if no level is set

                class_info = {
                    &#34;Class Name&#34;: wrap_text(name),
                    &#34;Name&#34;: wrap_text(getattr(instance, &#34;name&#34;, &#34;N/A&#34;)),
                    &#34;Description&#34;: wrap_text(getattr(instance, &#34;description&#34;, &#34;N/A&#34;)),
                    &#34;Level&#34;: wrap_text(level),
                    &#34;Inheritance&#34;: wrap_text(&#34;, &#34;.join(base.__name__ for base in obj.__bases__)),
                    &#34;Init Params&#34;: wrap_text(&#34;, &#34;.join(init_params) if init_params else &#34;&#34;),
                    &#34;Level Sorting&#34;: LEVEL_ORDER.get(level, 3)  # Used for sorting, not for table output
                }
                subclasses_info.append(class_info)
            except TypeError:
                class_info = {
                    &#34;Class Name&#34;: wrap_text(name),
                    &#34;Name&#34;: [&#34;N/A&#34;],
                    &#34;Description&#34;: [&#34;N/A&#34;],
                    &#34;Level&#34;: wrap_text(getattr(obj, &#34;level&#34;, &#34;other&#34;)),
                    &#34;Inheritance&#34;: wrap_text(&#34;, &#34;.join(base.__name__ for base in obj.__bases__)),
                    &#34;Init Params&#34;: wrap_text(&#34;⚠️ Cannot instantiate&#34;),
                    &#34;Level Sorting&#34;: LEVEL_ORDER.get(getattr(obj, &#34;level&#34;, &#34;other&#34;), 3)
                }
                subclasses_info.append(class_info)

    # **Sort first by level priority, then alphabetically within each level**
    subclasses_info.sort(key=lambda x: (x[&#34;Level Sorting&#34;], x[&#34;Class Name&#34;]))

    return subclasses_info</code></pre>
</details>
</dd>
<dt id="food.wrap_text"><code class="name flex">
<span>def <span class="ident">wrap_text</span></span>(<span>text, width=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps text within a specified width and returns a list of wrapped lines.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrap_text(text, width=20):
    &#34;&#34;&#34;Wraps text within a specified width and returns a list of wrapped lines.&#34;&#34;&#34;
    if not isinstance(text, str):
        return [str(text)]
    return textwrap.wrap(text, width) or [&#34;&#34;]  # Ensure at least one line</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="food.ambient"><code class="flex name class">
<span>class <span class="ident">ambient</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>real contact conditions</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ambient(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;ambient storage conditions&#34;
    name = &#34;ambient&#34;
    level = &#34;contact&#34;
    #[contacttime,contacttimeUnits] = check_units((200,&#34;days&#34;))
    #[contacttemperature,contacttemperatureUnits] = check_units((25,&#34;degC&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.realcontact" href="#food.realcontact">realcontact</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.ambient.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.ambient.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.ambient.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.realcontact" href="#food.realcontact">realcontact</a></b></code>:
<ul class="hlist">
<li><code><a title="food.realcontact.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.realcontact.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.realcontact.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.realcontact.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.realcontact.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.realcontact.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.realcontact.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.realcontact.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.realcontact.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.aqueous"><code class="flex name class">
<span>class <span class="ident">aqueous</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Aqueous food contact</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class aqueous(chemicalaffinity):
    &#34;&#34;&#34;Aqueous food contact&#34;&#34;&#34;
    name = &#34;aqueous contact&#34;
    description = &#34;minimize mass transfer&#34;
    [k0,k0Units] = check_units((1000,NoUnits))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.water" href="#food.water">water</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.aqueous.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.aqueous.k0"><code class="name">var <span class="ident">k0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.aqueous.k0Units"><code class="name">var <span class="ident">k0Units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.aqueous.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></b></code>:
<ul class="hlist">
<li><code><a title="food.chemicalaffinity.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.chemicalaffinity.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.chemicalaffinity.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.chemicalaffinity.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.chemicalaffinity.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.chemicalaffinity.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.chemicalaffinity.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.chemicalaffinity.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.chemicalaffinity.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.boiling"><code class="flex name class">
<span>class <span class="ident">boiling</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>real contact conditions</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class boiling(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;boiling conditions&#34;
    name = &#34;boiling&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((30,&#34;min&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((100,&#34;degC&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.realcontact" href="#food.realcontact">realcontact</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.boiling.contacttemperature"><code class="name">var <span class="ident">contacttemperature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.boiling.contacttemperatureUnits"><code class="name">var <span class="ident">contacttemperatureUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.boiling.contacttime"><code class="name">var <span class="ident">contacttime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.boiling.contacttimeUnits"><code class="name">var <span class="ident">contacttimeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.boiling.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.boiling.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.boiling.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.realcontact" href="#food.realcontact">realcontact</a></b></code>:
<ul class="hlist">
<li><code><a title="food.realcontact.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.realcontact.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.realcontact.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.realcontact.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.realcontact.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.realcontact.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.realcontact.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.realcontact.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.realcontact.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.chemicalaffinity"><code class="flex name class">
<span>class <span class="ident">chemicalaffinity</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Parent chemical affinity class</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class chemicalaffinity(foodphysics):
    &#34;&#34;&#34;Parent chemical affinity class&#34;&#34;&#34;
    description = &#34;default chemical affinity&#34;
    name = &#34;undefined&#34;
    level = &#34;root&#34;
    k0 = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.aqueous" href="#food.aqueous">aqueous</a></li>
<li><a title="food.fat" href="#food.fat">fat</a></li>
<li><a title="food.intermediate" href="#food.intermediate">intermediate</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.chemicalaffinity.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.chemicalaffinity.k0"><code class="name">var <span class="ident">k0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.chemicalaffinity.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.chemicalaffinity.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></b></code>:
<ul class="hlist">
<li><code><a title="food.foodphysics.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodphysics.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodphysics.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodphysics.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodphysics.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodphysics.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodphysics.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodphysics.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodphysics.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.chilled"><code class="flex name class">
<span>class <span class="ident">chilled</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>real contact conditions</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class chilled(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;ambient storage conditions&#34;
    name = &#34;ambient&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((30,&#34;days&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((4,&#34;degC&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.realcontact" href="#food.realcontact">realcontact</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.chilled.contacttemperature"><code class="name">var <span class="ident">contacttemperature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.chilled.contacttemperatureUnits"><code class="name">var <span class="ident">contacttemperatureUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.chilled.contacttime"><code class="name">var <span class="ident">contacttime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.chilled.contacttimeUnits"><code class="name">var <span class="ident">contacttimeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.chilled.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.chilled.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.chilled.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.realcontact" href="#food.realcontact">realcontact</a></b></code>:
<ul class="hlist">
<li><code><a title="food.realcontact.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.realcontact.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.realcontact.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.realcontact.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.realcontact.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.realcontact.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.realcontact.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.realcontact.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.realcontact.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.ethanol"><code class="flex name class">
<span>class <span class="ident">ethanol</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ethanol food simulant</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ethanol(simulant, perfectlymixed, fat):
    &#34;&#34;&#34;Ethanol food simulant&#34;&#34;&#34;
    name = &#34;ethanol&#34;
    description = &#34;ethanol = from pure ethanol down to ethanol 95%&#34;
    level = &#34;user&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.simulant" href="#food.simulant">simulant</a></li>
<li><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></li>
<li><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></li>
<li><a title="food.perfectlymixed" href="#food.perfectlymixed">perfectlymixed</a></li>
<li><a title="food.texture" href="#food.texture">texture</a></li>
<li><a title="food.fat" href="#food.fat">fat</a></li>
<li><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.ethanol.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.ethanol.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.ethanol.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.simulant" href="#food.simulant">simulant</a></b></code>:
<ul class="hlist">
<li><code><a title="food.simulant.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.simulant.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.simulant.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.simulant.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.simulant.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.simulant.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.simulant.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.simulant.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.simulant.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.ethanol50"><code class="flex name class">
<span>class <span class="ident">ethanol50</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ethanol 50 food simulant</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ethanol50(simulant, perfectlymixed, intermediate):
    &#34;&#34;&#34;Ethanol 50 food simulant&#34;&#34;&#34;
    name = &#34;ethanol 50&#34;
    description = &#34;ethanol 50, food simulant of dairy products&#34;
    level = &#34;user&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.simulant" href="#food.simulant">simulant</a></li>
<li><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></li>
<li><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></li>
<li><a title="food.perfectlymixed" href="#food.perfectlymixed">perfectlymixed</a></li>
<li><a title="food.texture" href="#food.texture">texture</a></li>
<li><a title="food.intermediate" href="#food.intermediate">intermediate</a></li>
<li><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.yogurt" href="#food.yogurt">yogurt</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.ethanol50.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.ethanol50.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.ethanol50.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.simulant" href="#food.simulant">simulant</a></b></code>:
<ul class="hlist">
<li><code><a title="food.simulant.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.simulant.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.simulant.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.simulant.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.simulant.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.simulant.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.simulant.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.simulant.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.simulant.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.fat"><code class="flex name class">
<span>class <span class="ident">fat</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Fat contact</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class fat(chemicalaffinity):
    &#34;&#34;&#34;Fat contact&#34;&#34;&#34;
    name = &#34;fat contact&#34;
    description = &#34;maximize mass transfer&#34;
    [k0,k0Units] = check_units((1,NoUnits))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.ethanol" href="#food.ethanol">ethanol</a></li>
<li><a title="food.tenax" href="#food.tenax">tenax</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.fat.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.fat.k0"><code class="name">var <span class="ident">k0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.fat.k0Units"><code class="name">var <span class="ident">k0Units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.fat.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></b></code>:
<ul class="hlist">
<li><code><a title="food.chemicalaffinity.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.chemicalaffinity.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.chemicalaffinity.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.chemicalaffinity.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.chemicalaffinity.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.chemicalaffinity.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.chemicalaffinity.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.chemicalaffinity.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.chemicalaffinity.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.foodlayer"><code class="flex name class">
<span>class <span class="ident">foodlayer</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Foodlayer class is a generic class to define food as a 1D layer in a symmetric manner with layer class
applicable to materials in contact.
Since mass transfer are much faster in the food than in the materials in contact, food is represented
as an almost 0D layer. Only a mass transfer resistance is applied at the food-material interface
controlled by the mass transfer coefficient h. A Henri-like coefficient k0 controls the eventual
partitioning of the substance between the food and the layer of the materials.</p>
<p>Food are geometrically defined by their volume and surface area in contact with the material.</p>
<p>Contact time (contacttime) and contact temperature (contacttemperature) are defined via foodlayer.</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class foodlayer(foodphysics):
    &#34;&#34;&#34;
    Foodlayer class is a generic class to define food as a 1D layer in a symmetric manner with layer class
    applicable to materials in contact.
    Since mass transfer are much faster in the food than in the materials in contact, food is represented
    as an almost 0D layer. Only a mass transfer resistance is applied at the food-material interface
    controlled by the mass transfer coefficient h. A Henri-like coefficient k0 controls the eventual
    partitioning of the substance between the food and the layer of the materials.

    Food are geometrically defined by their volume and surface area in contact with the material.

    Contact time (contacttime) and contact temperature (contacttemperature) are defined via foodlayer.

    &#34;&#34;&#34;
    level = &#34;root&#34;
    description = &#34;root food class&#34;  # Remains as class attribute
    name = &#34;generic food layer&#34;
    volume,volumeUnits = check_units((1,&#34;dm**3&#34;))
    surfacearea,surfaceareaUnits = check_units((6,&#34;dm**2&#34;))
    density,densityUnits = check_units((1000,&#34;kg/m**3&#34;))
    CF0,CF0units = check_units((0,NoUnits))  # initial concentration (arbitrary units)
    contacttime, contacttime_units = check_units((10,&#34;days&#34;))
    contactemperature,contactemperatureUnits = check_units((40,&#34;degC&#34;),ExpectedUnits=&#34;degC&#34;) # temperature ALWAYS in °C</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.foodlayer.CF0"><code class="name">var <span class="ident">CF0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.CF0units"><code class="name">var <span class="ident">CF0units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.contactemperature"><code class="name">var <span class="ident">contactemperature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.contactemperatureUnits"><code class="name">var <span class="ident">contactemperatureUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.contacttime"><code class="name">var <span class="ident">contacttime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.contacttime_units"><code class="name">var <span class="ident">contacttime_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.density"><code class="name">var <span class="ident">density</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.densityUnits"><code class="name">var <span class="ident">densityUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.surfacearea"><code class="name">var <span class="ident">surfacearea</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.surfaceareaUnits"><code class="name">var <span class="ident">surfaceareaUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.volume"><code class="name">var <span class="ident">volume</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodlayer.volumeUnits"><code class="name">var <span class="ident">volumeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></b></code>:
<ul class="hlist">
<li><code><a title="food.foodphysics.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodphysics.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodphysics.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodphysics.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodphysics.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodphysics.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodphysics.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodphysics.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodphysics.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.foodphysics"><code class="flex name class">
<span>class <span class="ident">foodphysics</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class that automatically assigns instance attributes from class defaults,
except for the 'description' attribute.
Check the physical meaning of quantities with units.</p>
<p>Implemented methods include:
- refresh() validates all quantities before a simulation
- update(name="new name", description="new description",parameter1=value)
assigns new values to physical parameters and attributes
- getparam() returns physical parameters even if they undefined
Available properties:
PBC returns True in periodic boundary conditions are enforced (setoff)
impervious returns True if impervious boundary condition is appled (no food)</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class foodphysics:
    &#34;&#34;&#34;
    Base class that automatically assigns instance attributes from class defaults,
    except for the &#39;description&#39; attribute.
    Check the physical meaning of quantities with units.

    Implemented methods include:
        - refresh() validates all quantities before a simulation
        - update(name=&#34;new name&#34;, description=&#34;new description&#34;,parameter1=value)
          assigns new values to physical parameters and attributes
        - getparam() returns physical parameters even if they undefined
    Available properties:
        PBC returns True in periodic boundary conditions are enforced (setoff)
        impervious returns True if impervious boundary condition is appled (no food)
    &#34;&#34;&#34;

    # General descriptors
    description = &#34;Root physics class used to implement food and mass transfer physics&#34;  # Remains as class attribute
    name = &#34;food physics&#34;
    level = &#34;base&#34;

    # ------------------------------------------------------
    # Transfer rules for food1 &gt;&gt; food2 and food1 &gt;&gt; result
    # ------------------------------------------------------

    # Mapping of properties to their respective categories
    _list_categories = {
        &#34;contacttemperature&#34;: &#34;contact&#34;,
        &#34;contacttime&#34;: &#34;contact&#34;,
        &#34;surfacearea&#34;: &#34;geometry&#34;,
        &#34;volume&#34;: &#34;geometry&#34;
    }

    # Rules for property transfer based on object type
    _transferable_properties = {
        &#34;contacttemperature&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: True,
                &#34;checkNumPy&#34;: False,
                &#34;as&#34;: &#34;&#34;,
                &#34;prototype&#34;: None,
                &#34;category&#34;: &#34;contact&#34;
            },
            &#34;layer&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;T&#34;,
                &#34;prototype&#34;: None
            }
        },
        &#34;contacttime&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: True,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;&#34;,
                &#34;prototype&#34;: None
            },
            &#34;SensPatankarResult&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;t&#34;,
                &#34;prototype&#34;: None
            }
        },
        &#34;surfacearea&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: False,
                &#34;as&#34;: &#34;surfacearea&#34;,
                &#34;prototype&#34;: None
            }
        },
        &#34;volume&#34;: {
            &#34;foodphysics&#34;: {
                &#34;onlyifinherited&#34;: False,
                &#34;checkNumPy&#34;: True,
                &#34;as&#34;: &#34;&#34;,
                &#34;prototype&#34;: None
            }
        }
    }


    def __init__(self, **kwargs):
        &#34;&#34;&#34;general constructor&#34;&#34;&#34;

        # local import
        from patankar.migration import SensPatankarResult

        # numeric validator
        def numvalidator(key,value):
            if key in parametersWithUnits:          # the parameter is a physical quantity
                if isinstance(value,tuple):         # the supplied value as unit
                    value,_ = check_units(value)    # we convert to SI, we drop the units
                if not isinstance(value,np.ndarray):
                    value = np.array([value])       # we force NumPy class
            return value

        # Iterate through the MRO (excluding foodphysics and object)
        for cls in reversed(self.__class__.__mro__):
            if cls in (foodphysics, object):
                continue
            # For each attribute defined at the class level,
            # if it is not &#39;description&#39;, not callable, and not a dunder, set it as an instance attribute.
            for key, value in cls.__dict__.items(): # we loop on class attributes
                if key in (&#34;description&#34;,&#34;level&#34;) or key.startswith(&#34;__&#34;) or callable(value):
                    continue
                if key not in kwargs:
                    setattr(self, key, numvalidator(key,value))
        # Now update/override with any keyword arguments provided at instantiation.
        for key, value in kwargs.items():
            value = numvalidator(key,value)
            if key not in paramaterNamesWithUnits: # we protect the values of units (they are SI, they cannot be changed)
                setattr(self, key, value)
        # we initialize the acknowlegment process for future property propagation
        self._hasbeeninherited = {}
        # we initialize the _simstate storing the last simulation result available
        self._simstate = None # simulation results
        self._inpstate = None # their inputs
        # For cooperative multiple inheritance, call the next __init__ if it exists.
        super().__init__()
        # Define actual class references to avoid circular dependency issues
        if self.__class__._transferable_properties[&#34;contacttemperature&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] is None:
            self.__class__._transferable_properties[&#34;contacttemperature&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics
            self.__class__._transferable_properties[&#34;contacttemperature&#34;][&#34;layer&#34;][&#34;prototype&#34;] = layer
            self.__class__._transferable_properties[&#34;contacttime&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics
            self.__class__._transferable_properties[&#34;contacttime&#34;][&#34;SensPatankarResult&#34;][&#34;prototype&#34;] = SensPatankarResult
            self.__class__._transferable_properties[&#34;surfacearea&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics
            self.__class__._transferable_properties[&#34;volume&#34;][&#34;foodphysics&#34;][&#34;prototype&#34;] = foodphysics

    # ------- [properties to access/modify simstate] --------
    @property
    def lastinput(self):
        &#34;&#34;&#34;Getter for last layer input.&#34;&#34;&#34;
        return self._inpstate

    @lastinput.setter
    def lastinput(self, value):
        &#34;&#34;&#34;Setter for last layer input.&#34;&#34;&#34;
        self._inpstate = value

    @property
    def lastsimulation(self):
        &#34;&#34;&#34;Getter for last simulation results.&#34;&#34;&#34;
        return self._simstate

    @lastsimulation.setter
    def lastsimulation(self, value):
        &#34;&#34;&#34;Setter for last simulation results.&#34;&#34;&#34;
        self._simstate = value

    @property
    def hassimulation(self):
        &#34;&#34;&#34;Returns True if a simulation exists&#34;&#34;&#34;
        return self.lastsimulation is not None


    # ------- [inheritance registration mechanism] --------
    def acknowledge(self, what=None, category=None):
        &#34;&#34;&#34;
        Register inherited properties under a given category.

        Parameters:
        -----------
        what : str or list of str or a set
            The properties or attributes that have been inherited.
        category : str
            The category under which the properties are grouped.

        Example:
        --------
        &gt;&gt;&gt; b = B()
        &gt;&gt;&gt; b.acknowledge(what=&#34;volume&#34;, category=&#34;geometry&#34;)
        &gt;&gt;&gt; b.acknowledge(what=[&#34;surfacearea&#34;, &#34;diameter&#34;], category=&#34;geometry&#34;)
        &gt;&gt;&gt; print(b._hasbeeninherited)
        {&#39;geometry&#39;: {&#39;volume&#39;, &#39;surfacearea&#39;, &#39;diameter&#39;}}
        &#34;&#34;&#34;
        if category is None or what is None:
            raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
        if isinstance(what, str):
            what = {what}  # Convert string to a set
        elif isinstance(what, list):
            what = set(what)  # Convert list to a set for uniqueness
        elif not isinstance(what,set):
            raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
        if category not in self._hasbeeninherited:
            self._hasbeeninherited[category] = set()
        self._hasbeeninherited[category].update(what)


    def refresh(self):
        &#34;&#34;&#34;refresh all physcal paramaters after instantiation&#34;&#34;&#34;
        for key, value in self.__dict__.items():    # we loop on instance attributes
            if key in parametersWithUnits:          # the parameter is a physical quantity
                if isinstance(value,tuple):         # the supplied value as unit
                    value = check_units(value)[0]   # we convert to SI, we drop the units
                    setattr(self,key,value)
                if not isinstance(value,np.ndarray):
                    value = np.array([value])      # we force NumPy class
                    setattr(self,key,value)

    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update modifiable parameters of the foodphysics object.

        Modifiable Parameters:
            - name (str): New name for the object.
            - description (str): New description.
            - volume (float or tuple): Volume (can be tuple like (1, &#34;L&#34;)).
            - surfacearea (float or tuple): Surface area (can be tuple like (1, &#34;cm^2&#34;)).
            - density (float or tuple): Density (can be tuple like (1000, &#34;kg/m^3&#34;)).
            - CF0 (float or tuple): Initial concentration in the food.
            - contacttime (float or tuple): Contact time (can be tuple like (1, &#34;h&#34;)).
            - contacttemperature (float or tuple): Temperature (can be tuple like (25, &#34;degC&#34;)).
            - h (float or tuple): Mass transfer coefficient (can be tuple like (1e-6,&#34;m/s&#34;)).
            - k0 (float or tuple): Henri-like coefficient for the food (can be tuple like (1,&#34;a.u.&#34;)).

        &#34;&#34;&#34;
        if not kwargs:  # shortcut
            return self # for chaining
        def checkunits(value):
            &#34;&#34;&#34;Helper function to convert physical quantities to SI.&#34;&#34;&#34;
            if isinstance(value, tuple) and len(value) == 2:
                scale = check_units(value)[0]  # Convert to SI, drop unit
                return np.array([scale], dtype=float)  # Ensure NumPy array
            elif isinstance(value, (int, float, np.ndarray)):
                return np.array([value], dtype=float)  # Ensure NumPy array
            else:
                raise ValueError(f&#34;Invalid value for physical quantity: {value}&#34;)
        # Update `name` and `description` if provided
        if &#34;name&#34; in kwargs:
            self.name = str(kwargs[&#34;name&#34;])
        if &#34;description&#34; in kwargs:
            self.description = str(kwargs[&#34;description&#34;])
        # Update physical properties
        for key in parametersWithUnits.keys():
            if key in kwargs:
                value = kwargs[key]
                setattr(self, key, checkunits(value))  # Ensure NumPy array in SI
        return self  # Return self for method chaining if needed

    def get_param(self, key, default=None, acceptNone=True):
        &#34;&#34;&#34;Retrieve instance attribute with a default fallback if enabled.&#34;&#34;&#34;
        paramdefaultvalue = 1
        if isinstance(self,(setoff,nofood)):
            if key in parametersWithUnits_andfallback:
                value =  self.__dict__.get(key, paramdefaultvalue) if default is None else self.__dict__.get(key, default)
                if isinstance(value,np.ndarray):
                    value = value.item()
                if value is None and not acceptNone:
                    value = paramdefaultvalue if default is None else default
                return np.array([value])
            if key in paramaterNamesWithUnits:
                return self.__dict__.get(key, parametersWithUnits[key]) if default is None else self.__dict__.get(key, default)
        if key in parametersWithUnits:
            if hasattr(self, key):
                return getattr(self,key)
            else:
                raise KeyError(
                    f&#34;Missing property: &#39;{key}&#39; in instance of class &#39;{self.__class__.__name__}&#39;.\n&#34;
                    f&#34;To define it, use one of the following methods:\n&#34;
                    f&#34;  - Direct assignment:   object.{key} = value\n&#34;
                    f&#34;  - Using update method: object.update({key}=value)\n&#34;
                    f&#34;Note: The value can also be provided as a tuple (value, &#39;unit&#39;).&#34;
                )
        elif key in paramaterNamesWithUnits:
            return self.__dict__.get(key, paramaterNamesWithUnits[key]) if default is None else self.__dict__.get(key, default)
        raise KeyError(f&#39;Use getattr(&#34;{key}&#34;) to retrieve the value of {key}&#39;)

    def __repr__(self):
        &#34;&#34;&#34;Formatted string representation of the foodphysics object.&#34;&#34;&#34;
        # refresh all definitions
        self.refresh()
        # Header with name and description
        repr_str = f&#39;Food object &#34;{self.name}&#34; ({self.description}) with properties:\n&#39;

        # Helper function to extract a numerical value safely
        def format_value(value):
            &#34;&#34;&#34;Ensure the value is a float or a single-item NumPy array.&#34;&#34;&#34;
            if isinstance(value, np.ndarray):
                return value.item() if value.size == 1 else value[0]  # Ensure scalar representation
            elif value is None:
                return value
            return float(value)
        # Loop through parameters that should be printed
        for key, unit in parametersWithUnits.items():
            if hasattr(self, key):  # Print only defined parameters
                value = format_value(getattr(self, key))
                unit_str = self.get_param(key+&#34;Units&#34;, parametersWithUnits[key])  # Retrieve unit safely
                if value is not None:
                    repr_str += f&#34;{key:15s}: {value:0.8g} [{unit_str}]\n&#34;
        print(repr_str.strip())  # Remove trailing newline
        return str(self)


    def __str__(self):
        &#34;&#34;&#34;Formatted string representation of the property&#34;&#34;&#34;
        simstr = &#39; [simulated]&#39; if self.hassimulation else &#34;&#34;
        return f&#34;&lt;{self.__class__.__name__}: {self.name}&gt;{simstr}&#34;

    def copy(self,**kwargs):
        &#34;&#34;&#34;Creates a deep copy of the current food instance.&#34;&#34;&#34;
        return duplicate(self).update(**kwargs)


    @property
    def PBC(self):
        &#34;&#34;&#34;
        Returns true if h is not defined or None
            This property is used to identified periodic boundary condition also called setoff mass transfer.

        &#34;&#34;&#34;
        if not hasattr(self,&#34;h&#34;):
            return None
        htmp = getattr(self,&#34;h&#34;)
        if isinstance(htmp,np.ndarray):
            htmp = htmp.item()
        return htmp is None


    # --------------------------------------------------------------------
    # For convenience, several operators have been overloaded
    #   medium &gt;&gt; packaging      # sets the volume and the surfacearea
    #   medium &gt;&gt; material       # propgates the contact temperature from the medium to the material
    #   sol = medium &lt;&lt; material # simulate migration from the material to the medium
    # --------------------------------------------------------------------

    # method: medium._to(material) and its associated operator &gt;&gt;
    def _to(self, other = None):
        &#34;&#34;&#34;
        Transfers inherited properties to another object based on predefined rules.

        Parameters:
        -----------
        other : object
            The recipient object that will receive the transferred properties.

        Notes:
        ------
        - Only properties listed in `_transferable_properties` are transferred.
        - A property can only be transferred if `other` matches the expected class.
        - The property may have a different name in `other` as defined in `as`.
        - If `onlyifinherited` is True, the property must have been inherited by `self`.
        - If `checkNumPy` is True, ensures NumPy array compatibility.
        - Updates `other`&#39;s `_hasbeeninherited` tracking.
        &#34;&#34;&#34;
        for prop, classes in self._transferable_properties.items():
            if prop not in self._list_categories:
                continue  # Skip properties not categorized

            category = self._list_categories[prop]

            for class_name, rules in classes.items():

                if not isinstance(other, rules[&#34;prototype&#34;]):
                    continue  # Skip if other is not an instance of the expected prototype class

                if rules[&#34;onlyifinherited&#34;] and category not in self._hasbeeninherited:
                    continue  # Skip if property must be inherited but is not

                if rules[&#34;onlyifinherited&#34;] and prop not in self._hasbeeninherited[category]:
                    continue  # Skip if the specific property has not been inherited

                if not hasattr(self, prop):
                    continue  # Skip if the property does not exist on self

                # Determine the target attribute name in other
                target_attr = rules[&#34;as&#34;] if rules[&#34;as&#34;] else prop

                # Retrieve the property value
                value = getattr(self, prop)

                # Handle NumPy array check
                if rules[&#34;checkNumPy&#34;] and hasattr(other, target_attr):
                    existing_value = getattr(other, target_attr)
                    if isinstance(existing_value, np.ndarray):
                        value = np.full(existing_value.shape, value)

                # Assign the value to other
                setattr(other, target_attr, value)

                # Register the transfer in other’s inheritance tracking
                other.acknowledge(what=target_attr, category=category)

                # to chain &gt;&gt;
                return other

    def __rshift__(self, other):
        &#34;&#34;&#34;Overloads &gt;&gt; to propagate to other.&#34;&#34;&#34;
        return self._to(other)

    # migration method
    def migration(self,material,**kwargs):
        from patankar.migration import senspatankar
        self._to(material) # propagate contact conditions first
        return senspatankar(material,self,**kwargs)

    def contact(self,material,**kwargs):
        return self.migration(self,material,**kwargs)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></li>
<li><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></li>
<li><a title="food.nofood" href="#food.nofood">nofood</a></li>
<li><a title="food.realcontact" href="#food.realcontact">realcontact</a></li>
<li><a title="food.setoff" href="#food.setoff">setoff</a></li>
<li><a title="food.testcontact" href="#food.testcontact">testcontact</a></li>
<li><a title="food.texture" href="#food.texture">texture</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.foodphysics.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodphysics.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.foodphysics.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="food.foodphysics.PBC"><code class="name">var <span class="ident">PBC</span></code></dt>
<dd>
<div class="desc"><p>Returns true if h is not defined or None
This property is used to identified periodic boundary condition also called setoff mass transfer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def PBC(self):
    &#34;&#34;&#34;
    Returns true if h is not defined or None
        This property is used to identified periodic boundary condition also called setoff mass transfer.

    &#34;&#34;&#34;
    if not hasattr(self,&#34;h&#34;):
        return None
    htmp = getattr(self,&#34;h&#34;)
    if isinstance(htmp,np.ndarray):
        htmp = htmp.item()
    return htmp is None</code></pre>
</details>
</dd>
<dt id="food.foodphysics.hassimulation"><code class="name">var <span class="ident">hassimulation</span></code></dt>
<dd>
<div class="desc"><p>Returns True if a simulation exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hassimulation(self):
    &#34;&#34;&#34;Returns True if a simulation exists&#34;&#34;&#34;
    return self.lastsimulation is not None</code></pre>
</details>
</dd>
<dt id="food.foodphysics.lastinput"><code class="name">var <span class="ident">lastinput</span></code></dt>
<dd>
<div class="desc"><p>Getter for last layer input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lastinput(self):
    &#34;&#34;&#34;Getter for last layer input.&#34;&#34;&#34;
    return self._inpstate</code></pre>
</details>
</dd>
<dt id="food.foodphysics.lastsimulation"><code class="name">var <span class="ident">lastsimulation</span></code></dt>
<dd>
<div class="desc"><p>Getter for last simulation results.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lastsimulation(self):
    &#34;&#34;&#34;Getter for last simulation results.&#34;&#34;&#34;
    return self._simstate</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="food.foodphysics.acknowledge"><code class="name flex">
<span>def <span class="ident">acknowledge</span></span>(<span>self, what=None, category=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Register inherited properties under a given category.</p>
<h2 id="parameters">Parameters:</h2>
<p>what : str or list of str or a set
The properties or attributes that have been inherited.
category : str
The category under which the properties are grouped.</p>
<h2 id="example">Example:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; b = B()
&gt;&gt;&gt; b.acknowledge(what=&quot;volume&quot;, category=&quot;geometry&quot;)
&gt;&gt;&gt; b.acknowledge(what=[&quot;surfacearea&quot;, &quot;diameter&quot;], category=&quot;geometry&quot;)
&gt;&gt;&gt; print(b._hasbeeninherited)
{'geometry': {'volume', 'surfacearea', 'diameter'}}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acknowledge(self, what=None, category=None):
    &#34;&#34;&#34;
    Register inherited properties under a given category.

    Parameters:
    -----------
    what : str or list of str or a set
        The properties or attributes that have been inherited.
    category : str
        The category under which the properties are grouped.

    Example:
    --------
    &gt;&gt;&gt; b = B()
    &gt;&gt;&gt; b.acknowledge(what=&#34;volume&#34;, category=&#34;geometry&#34;)
    &gt;&gt;&gt; b.acknowledge(what=[&#34;surfacearea&#34;, &#34;diameter&#34;], category=&#34;geometry&#34;)
    &gt;&gt;&gt; print(b._hasbeeninherited)
    {&#39;geometry&#39;: {&#39;volume&#39;, &#39;surfacearea&#39;, &#39;diameter&#39;}}
    &#34;&#34;&#34;
    if category is None or what is None:
        raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
    if isinstance(what, str):
        what = {what}  # Convert string to a set
    elif isinstance(what, list):
        what = set(what)  # Convert list to a set for uniqueness
    elif not isinstance(what,set):
        raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
    if category not in self._hasbeeninherited:
        self._hasbeeninherited[category] = set()
    self._hasbeeninherited[category].update(what)</code></pre>
</details>
</dd>
<dt id="food.foodphysics.contact"><code class="name flex">
<span>def <span class="ident">contact</span></span>(<span>self, material, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contact(self,material,**kwargs):
    return self.migration(self,material,**kwargs)</code></pre>
</details>
</dd>
<dt id="food.foodphysics.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a deep copy of the current food instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self,**kwargs):
    &#34;&#34;&#34;Creates a deep copy of the current food instance.&#34;&#34;&#34;
    return duplicate(self).update(**kwargs)</code></pre>
</details>
</dd>
<dt id="food.foodphysics.get_param"><code class="name flex">
<span>def <span class="ident">get_param</span></span>(<span>self, key, default=None, acceptNone=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve instance attribute with a default fallback if enabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_param(self, key, default=None, acceptNone=True):
    &#34;&#34;&#34;Retrieve instance attribute with a default fallback if enabled.&#34;&#34;&#34;
    paramdefaultvalue = 1
    if isinstance(self,(setoff,nofood)):
        if key in parametersWithUnits_andfallback:
            value =  self.__dict__.get(key, paramdefaultvalue) if default is None else self.__dict__.get(key, default)
            if isinstance(value,np.ndarray):
                value = value.item()
            if value is None and not acceptNone:
                value = paramdefaultvalue if default is None else default
            return np.array([value])
        if key in paramaterNamesWithUnits:
            return self.__dict__.get(key, parametersWithUnits[key]) if default is None else self.__dict__.get(key, default)
    if key in parametersWithUnits:
        if hasattr(self, key):
            return getattr(self,key)
        else:
            raise KeyError(
                f&#34;Missing property: &#39;{key}&#39; in instance of class &#39;{self.__class__.__name__}&#39;.\n&#34;
                f&#34;To define it, use one of the following methods:\n&#34;
                f&#34;  - Direct assignment:   object.{key} = value\n&#34;
                f&#34;  - Using update method: object.update({key}=value)\n&#34;
                f&#34;Note: The value can also be provided as a tuple (value, &#39;unit&#39;).&#34;
            )
    elif key in paramaterNamesWithUnits:
        return self.__dict__.get(key, paramaterNamesWithUnits[key]) if default is None else self.__dict__.get(key, default)
    raise KeyError(f&#39;Use getattr(&#34;{key}&#34;) to retrieve the value of {key}&#39;)</code></pre>
</details>
</dd>
<dt id="food.foodphysics.migration"><code class="name flex">
<span>def <span class="ident">migration</span></span>(<span>self, material, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def migration(self,material,**kwargs):
    from patankar.migration import senspatankar
    self._to(material) # propagate contact conditions first
    return senspatankar(material,self,**kwargs)</code></pre>
</details>
</dd>
<dt id="food.foodphysics.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>refresh all physcal paramaters after instantiation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;refresh all physcal paramaters after instantiation&#34;&#34;&#34;
    for key, value in self.__dict__.items():    # we loop on instance attributes
        if key in parametersWithUnits:          # the parameter is a physical quantity
            if isinstance(value,tuple):         # the supplied value as unit
                value = check_units(value)[0]   # we convert to SI, we drop the units
                setattr(self,key,value)
            if not isinstance(value,np.ndarray):
                value = np.array([value])      # we force NumPy class
                setattr(self,key,value)</code></pre>
</details>
</dd>
<dt id="food.foodphysics.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update modifiable parameters of the foodphysics object.</p>
<p>Modifiable Parameters:
- name (str): New name for the object.
- description (str): New description.
- volume (float or tuple): Volume (can be tuple like (1, "L")).
- surfacearea (float or tuple): Surface area (can be tuple like (1, "cm^2")).
- density (float or tuple): Density (can be tuple like (1000, "kg/m^3")).
- CF0 (float or tuple): Initial concentration in the food.
- contacttime (float or tuple): Contact time (can be tuple like (1, "h")).
- contacttemperature (float or tuple): Temperature (can be tuple like (25, "degC")).
- h (float or tuple): Mass transfer coefficient (can be tuple like (1e-6,"m/s")).
- k0 (float or tuple): Henri-like coefficient for the food (can be tuple like (1,"a.u.")).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update modifiable parameters of the foodphysics object.

    Modifiable Parameters:
        - name (str): New name for the object.
        - description (str): New description.
        - volume (float or tuple): Volume (can be tuple like (1, &#34;L&#34;)).
        - surfacearea (float or tuple): Surface area (can be tuple like (1, &#34;cm^2&#34;)).
        - density (float or tuple): Density (can be tuple like (1000, &#34;kg/m^3&#34;)).
        - CF0 (float or tuple): Initial concentration in the food.
        - contacttime (float or tuple): Contact time (can be tuple like (1, &#34;h&#34;)).
        - contacttemperature (float or tuple): Temperature (can be tuple like (25, &#34;degC&#34;)).
        - h (float or tuple): Mass transfer coefficient (can be tuple like (1e-6,&#34;m/s&#34;)).
        - k0 (float or tuple): Henri-like coefficient for the food (can be tuple like (1,&#34;a.u.&#34;)).

    &#34;&#34;&#34;
    if not kwargs:  # shortcut
        return self # for chaining
    def checkunits(value):
        &#34;&#34;&#34;Helper function to convert physical quantities to SI.&#34;&#34;&#34;
        if isinstance(value, tuple) and len(value) == 2:
            scale = check_units(value)[0]  # Convert to SI, drop unit
            return np.array([scale], dtype=float)  # Ensure NumPy array
        elif isinstance(value, (int, float, np.ndarray)):
            return np.array([value], dtype=float)  # Ensure NumPy array
        else:
            raise ValueError(f&#34;Invalid value for physical quantity: {value}&#34;)
    # Update `name` and `description` if provided
    if &#34;name&#34; in kwargs:
        self.name = str(kwargs[&#34;name&#34;])
    if &#34;description&#34; in kwargs:
        self.description = str(kwargs[&#34;description&#34;])
    # Update physical properties
    for key in parametersWithUnits.keys():
        if key in kwargs:
            value = kwargs[key]
            setattr(self, key, checkunits(value))  # Ensure NumPy array in SI
    return self  # Return self for method chaining if needed</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="food.foodproperty"><code class="flex name class">
<span>class <span class="ident">foodproperty</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Class wrapper of food properties</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class foodproperty(foodlayer):
    &#34;&#34;&#34;Class wrapper of food properties&#34;&#34;&#34;
    level=&#34;property&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.realfood" href="#food.realfood">realfood</a></li>
<li><a title="food.simulant" href="#food.simulant">simulant</a></li>
<li><a title="food.solid" href="#food.solid">solid</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.foodproperty.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></b></code>:
<ul class="hlist">
<li><code><a title="food.foodlayer.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodlayer.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodlayer.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodlayer.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodlayer.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodlayer.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodlayer.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodlayer.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodlayer.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.frozen"><code class="flex name class">
<span>class <span class="ident">frozen</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>real contact conditions</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class frozen(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;freezing storage conditions&#34;
    name = &#34;frrozen&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((6,&#34;months&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((-20,&#34;degC&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.realcontact" href="#food.realcontact">realcontact</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.frozen.contacttemperature"><code class="name">var <span class="ident">contacttemperature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.frozen.contacttemperatureUnits"><code class="name">var <span class="ident">contacttemperatureUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.frozen.contacttime"><code class="name">var <span class="ident">contacttime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.frozen.contacttimeUnits"><code class="name">var <span class="ident">contacttimeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.frozen.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.frozen.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.frozen.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.realcontact" href="#food.realcontact">realcontact</a></b></code>:
<ul class="hlist">
<li><code><a title="food.realcontact.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.realcontact.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.realcontact.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.realcontact.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.realcontact.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.realcontact.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.realcontact.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.realcontact.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.realcontact.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.hotfilled"><code class="flex name class">
<span>class <span class="ident">hotfilled</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>real contact conditions</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class hotfilled(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;hot-filling conditions&#34;
    name = &#34;hotfilled&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((20,&#34;min&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((80,&#34;degC&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.realcontact" href="#food.realcontact">realcontact</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.hotfilled.contacttemperature"><code class="name">var <span class="ident">contacttemperature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.hotfilled.contacttemperatureUnits"><code class="name">var <span class="ident">contacttemperatureUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.hotfilled.contacttime"><code class="name">var <span class="ident">contacttime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.hotfilled.contacttimeUnits"><code class="name">var <span class="ident">contacttimeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.hotfilled.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.hotfilled.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.hotfilled.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.realcontact" href="#food.realcontact">realcontact</a></b></code>:
<ul class="hlist">
<li><code><a title="food.realcontact.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.realcontact.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.realcontact.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.realcontact.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.realcontact.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.realcontact.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.realcontact.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.realcontact.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.realcontact.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.intermediate"><code class="flex name class">
<span>class <span class="ident">intermediate</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Intermediate chemical affinity</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class intermediate(chemicalaffinity):
    &#34;&#34;&#34;Intermediate chemical affinity&#34;&#34;&#34;
    name = &#34;intermediate&#34;
    description = &#34;intermediate chemical affinity&#34;
    [k0,k0Units] = check_units((10,NoUnits))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.ethanol50" href="#food.ethanol50">ethanol50</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.intermediate.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.intermediate.k0"><code class="name">var <span class="ident">k0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.intermediate.k0Units"><code class="name">var <span class="ident">k0Units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.intermediate.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></b></code>:
<ul class="hlist">
<li><code><a title="food.chemicalaffinity.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.chemicalaffinity.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.chemicalaffinity.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.chemicalaffinity.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.chemicalaffinity.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.chemicalaffinity.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.chemicalaffinity.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.chemicalaffinity.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.chemicalaffinity.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.layer"><code class="flex name class">
<span>class <span class="ident">layer</span></span>
<span>(</span><span>l=None, D=None, k=None, C0=None, rho=None, T=None, lunit=None, Dunit=None, kunit=None, Cunit=None, rhounit=None, Tunit=None, layername=None, layertype=None, layermaterial=None, layercode=None, substance=None, Dmodel=None, kmodel=None, nmesh=None, nmeshmin=None, verbose=None, verbosity=2, **unresolved)</span>
</code></dt>
<dd>
<div class="desc"><p>layer class from patankar package
&hellip;
strings properties: layername, layertype, layermaterial
scalar properties: D,k,l,C0
&hellip;</p>
<h2 id="example">Example</h2>
<p>A = layer(D=1e-14,l=50e-6,layername="layer A",layertype="polymer",layermaterial="PP")</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layername</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Name. The default is "my layer".</dd>
<dt><strong><code>layertype</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Type. The default is "unknown type".</dd>
<dt><strong><code>layermaterial</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Material identification . The default is "unknown material".</dd>
<dt>PHYSICAL QUANTITIES</dt>
<dt><strong><code>l</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Thickness. The default is 50e-6 (m).</dd>
<dt><strong><code>D</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).</dd>
<dt><strong><code>C0</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Initial concentration. The default is 1000 (a.u.).</dd>
<dt>PHYSICAL UNITS</dt>
<dt><strong><code>lunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Length units. The default unit is "m.</dd>
<dt><strong><code>Dunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Diffusivity units. The default unit is 1e-14 "m^2/s".</dd>
<dt><strong><code>kunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default unit is "a.u.".</dd>
<dt><strong><code>Cunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Initial concentration. The default unit is "a.u.".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>a monolayer object which can be assembled into a multilayer structure</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class layer:
    &#34;&#34;&#34;
        layer class from patankar package
        ...
        strings properties: layername, layertype, layermaterial
        scalar properties: D,k,l,C0
        ...
        Example:
            A = layer(D=1e-14,l=50e-6,layername=&#34;layer A&#34;,layertype=&#34;polymer&#34;,layermaterial=&#34;PP&#34;)
    &#34;&#34;&#34;
    # --------------------------------------------------------------------
    # PRIVATE PROPERTIES (cannot be changed by the user)
    # __ read only attributes
    #  _ private attributes (not public)
    # --------------------------------------------------------------------
    __description = &#34;LAYER object&#34;                # description
    __version = 1.0                               # version
    __contact = &#34;olivier.vitrac@agroparistech.fr&#34; # contact person
    _printformat = &#34;%0.4g&#34;   # format to display D, k, l values


    # Synonyms dictionary: Maps alternative names to the actual parameter
    # these synonyms can be used during construction
    _synonyms = {
        &#34;substance&#34;: {&#34;migrant&#34;, &#34;compound&#34;, &#34;chemical&#34;,&#34;molecule&#34;,&#34;solute&#34;},
        &#34;C0&#34;: {&#34;CP0&#34;, &#34;Cp0&#34;},
        &#34;l&#34;: {&#34;lp&#34;, &#34;lP&#34;},
        &#34;D&#34;: {&#34;Dp&#34;, &#34;DP&#34;},
        &#34;k&#34;: {&#34;kp&#34;, &#34;kP&#34;},
        &#34;T&#34;: {&#34;temp&#34;,&#34;Temp&#34;,&#34;temperature&#34;,&#34;Temperature&#34;,
              &#34;contacttemperature&#34;,&#34;ContactTemperature&#34;,&#34;contactTemperature&#34;}
    }
    # Default values for parameters (note that Td cannot be changed by the end-user)
    _defaults = {
        &#34;l&#34;: 5e-5,   # Thickness (m)
        &#34;D&#34;: 1e-14,  # Diffusion coefficient (m^2/s)
        &#34;k&#34;: 1.0,      # Henri-like coefficient (dimensionless)
        &#34;C0&#34;: 1000,  # Initial concentration (arbitrary units)
        &#34;rho&#34;: 1000, # Default density (kg/m³)
        &#34;T&#34;: 40.0,     # Default temperature (°C)
        &#34;Td&#34;: 25.0,    # Reference temperature for densities (°C)
        # Units (do not change)
        &#34;lunit&#34;: &#34;m&#34;,
        &#34;Dunit&#34;: &#34;m**2/s&#34;,
        &#34;kunit&#34;: &#34;a.u.&#34;,  # NoUnits
        &#34;Cunit&#34;: &#34;a.u.&#34;,  # NoUnits
        &#34;rhounit&#34;: &#34;kg/m**3&#34;,
        &#34;Tunit&#34;: &#34;degC&#34;,  # Temperatures are indicated in °C instead of K (to reduce end-user mistakes)
        # Layer properties
        &#34;layername&#34;: &#34;my layer&#34;,
        &#34;layertype&#34;: &#34;unknown type&#34;,
        &#34;layermaterial&#34;: &#34;unknown material&#34;,
        &#34;layercode&#34;: &#34;N/A&#34;,
        # Mesh parameters
        &#34;nmeshmin&#34;: 20,
        &#34;nmesh&#34;: 600,
        # Substance
        &#34;substance&#34;: None,
        # Other parameters
        &#34;verbose&#34;: None,
        &#34;verbosity&#34;: 2
    }

    # List units
    _parametersWithUnits = {
        &#34;l&#34;: &#34;m&#34;,
        &#34;D&#34;: &#34;m**2/s&#34;,
        &#34;k&#34;: &#34;a.u.&#34;,
        &#34;C&#34;: &#34;a.u.&#34;,
        &#34;rhp&#34;: &#34;kg/m**3&#34;,
        &#34;T&#34;: &#34;degC&#34;,
        }

    # Brief descriptions for each parameter
    _descriptionInputs = {
        &#34;l&#34;: &#34;Thickness of the layer (m)&#34;,
        &#34;D&#34;: &#34;Diffusion coefficient (m²/s)&#34;,
        &#34;k&#34;: &#34;Henri-like coefficient (dimensionless)&#34;,
        &#34;C0&#34;: &#34;Initial concentration (arbitrary units)&#34;,
        &#34;rho&#34;: &#34;Density of the material (kg/m³)&#34;,
        &#34;T&#34;: &#34;Layer temperature (°C)&#34;,
        &#34;Td&#34;: &#34;Reference temperature for densities (°C)&#34;,
        &#34;lunit&#34;: &#34;Unit of thickness (default: m)&#34;,
        &#34;Dunit&#34;: &#34;Unit of diffusion coefficient (default: m²/s)&#34;,
        &#34;kunit&#34;: &#34;Unit of Henri-like coefficient (default: a.u.)&#34;,
        &#34;Cunit&#34;: &#34;Unit of initial concentration (default: a.u.)&#34;,
        &#34;rhounit&#34;: &#34;Unit of density (default: kg/m³)&#34;,
        &#34;Tunit&#34;: &#34;Unit of temperature (default: degC)&#34;,
        &#34;layername&#34;: &#34;Name of the layer&#34;,
        &#34;layertype&#34;: &#34;Type of layer (e.g., polymer, ink, air)&#34;,
        &#34;layermaterial&#34;: &#34;Material composition of the layer&#34;,
        &#34;layercode&#34;: &#34;Identification code for the layer&#34;,
        &#34;nmeshmin&#34;: &#34;Minimum number of FV mesh elements for the layer&#34;,
        &#34;nmesh&#34;: &#34;Number of FV mesh elements for numerical computation&#34;,
        &#34;verbose&#34;: &#34;Verbose mode (None or boolean)&#34;,
        &#34;verbosity&#34;: &#34;Level of verbosity for debug messages (integer)&#34;
    }

    # --------------------------------------------------------------------
    # CONSTRUCTOR OF INSTANCE PROPERTIES
    # None = missing numeric value (managed by default)
    # --------------------------------------------------------------------
    def __init__(self,
                 l=None, D=None, k=None, C0=None, rho=None, T=None,
                 lunit=None, Dunit=None, kunit=None, Cunit=None, rhounit=None, Tunit=None,
                 layername=None,layertype=None,layermaterial=None,layercode=None,
                 substance = None, Dmodel = None, kmodel = None,
                 nmesh=None, nmeshmin=None,
                 verbose=None, verbosity=2,**unresolved):
        &#34;&#34;&#34;

        Parameters
        ----------

        layername : TYPE, optional, string
                    DESCRIPTION. Layer Name. The default is &#34;my layer&#34;.
        layertype : TYPE, optional, string
                    DESCRIPTION. Layer Type. The default is &#34;unknown type&#34;.
        layermaterial : TYPE, optional, string
                        DESCRIPTION. Material identification . The default is &#34;unknown material&#34;.
        PHYSICAL QUANTITIES
        l : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Thickness. The default is 50e-6 (m).
        D : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).
        k : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).
        C0 : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Initial concentration. The default is 1000 (a.u.).
        PHYSICAL UNITS
        lunit : TYPE, optional, string
                DESCRIPTION. Length units. The default unit is &#34;m.
        Dunit : TYPE, optional, string
                DESCRIPTION. Diffusivity units. The default unit is 1e-14 &#34;m^2/s&#34;.
        kunit : TYPE, optional, string
                DESCRIPTION. Henry-like coefficient. The default unit is &#34;a.u.&#34;.
        Cunit : TYPE, optional, string
                DESCRIPTION. Initial concentration. The default unit is &#34;a.u.&#34;.
        Returns
        -------
        a monolayer object which can be assembled into a multilayer structure

        &#34;&#34;&#34;
        # resolve alternative names used by end-users
        substance = layer.resolvename(substance,&#34;substance&#34;,**unresolved)
        C0 = layer.resolvename(C0,&#34;C0&#34;,**unresolved)
        l = layer.resolvename(l,&#34;l&#34;,**unresolved)
        D = layer.resolvename(D,&#34;D&#34;,**unresolved)
        k = layer.resolvename(k,&#34;k&#34;,**unresolved)
        T = layer.resolvename(T,&#34;T&#34;,**unresolved)

        # Assign defaults only if values are not provided
        l = l if l is not None else layer._defaults[&#34;l&#34;]
        D = D if D is not None else layer._defaults[&#34;D&#34;]
        k = k if k is not None else layer._defaults[&#34;k&#34;]
        C0 = C0 if C0 is not None else layer._defaults[&#34;C0&#34;]
        rho = rho if rho is not None else layer._defaults[&#34;rho&#34;]
        T = T if T is not None else layer._defaults[&#34;T&#34;]
        lunit = lunit if lunit is not None else layer._defaults[&#34;lunit&#34;]
        Dunit = Dunit if Dunit is not None else layer._defaults[&#34;Dunit&#34;]
        kunit = kunit if kunit is not None else layer._defaults[&#34;kunit&#34;]
        Cunit = Cunit if Cunit is not None else layer._defaults[&#34;Cunit&#34;]
        rhounit = rhounit if rhounit is not None else layer._defaults[&#34;rhounit&#34;]
        Tunit = Tunit if Tunit is not None else layer._defaults[&#34;Tunit&#34;]
        nmesh = nmesh if nmesh is not None else layer._defaults[&#34;nmesh&#34;]
        nmeshmin = nmeshmin if nmeshmin is not None else layer._defaults[&#34;nmeshmin&#34;]
        verbose = verbose if verbose is not None else layer._defaults[&#34;verbose&#34;]
        verbosity = verbosity if verbosity is not None else layer._defaults[&#34;verbosity&#34;]

        # Assign layer id properties
        layername = layername if layername is not None else layer._defaults[&#34;layername&#34;]
        layertype = layertype if layertype is not None else layer._defaults[&#34;layertype&#34;]
        layermaterial = layermaterial if layermaterial is not None else layer._defaults[&#34;layermaterial&#34;]
        layercode = layercode if layercode is not None else layer._defaults[&#34;layercode&#34;]

        # validate all physical paramaters with their units
        l,lunit = check_units(l,lunit,layer._defaults[&#34;lunit&#34;])
        D,Dunit = check_units(D,Dunit,layer._defaults[&#34;Dunit&#34;])
        k,kunit = check_units(k,kunit,layer._defaults[&#34;kunit&#34;])
        C0,Cunit = check_units(C0,Cunit,layer._defaults[&#34;Cunit&#34;])
        rho,rhounit = check_units(rho,rhounit,layer._defaults[&#34;rhounit&#34;])
        T,Tunit = check_units(T,Tunit,layer._defaults[&#34;Tunit&#34;])

        # set attributes: id and physical properties
        self._name = [layername]
        self._type = [layertype]
        self._material = [layermaterial]
        self._code = [layercode]
        self._nlayer = 1
        self._l = l[:1]
        self._D = D[:1]
        self._k = k[:1]
        self._C0 = C0[:1]
        self._rho = rho[:1]
        self._T = T
        self._lunit = lunit
        self._Dunit = Dunit
        self._kunit = kunit
        self._Cunit = Cunit
        self._rhounit = rhounit
        self._Tunit = Tunit
        self._nmesh = nmesh
        self._nmeshmin = nmeshmin

        # set substance and property models
        self._substance = substance

        # set history for all layers merged with +
        self._layerclass_history = []

        # set verbosity attributes
        self.verbosity = 0 if verbosity is None else verbosity
        self.verbose = verbosity&gt;0 if verbose is None else verbose

        # we initialize the acknowlegment process for future property propagation
        self._hasbeeninherited = {}

    # --------------------------------------------------------------------
    # Class method returning help() for the end user
    # --------------------------------------------------------------------
    @classmethod
    def help(cls):
        &#34;&#34;&#34;
        Prints a dynamically formatted summary of all input parameters,
        adjusting column widths based on content and wrapping long descriptions.
        &#34;&#34;&#34;

        # Column Headers
        headers = [&#34;Parameter&#34;, &#34;Default Value&#34;, &#34;Has Synonyms?&#34;, &#34;Description&#34;]
        col_widths = [len(h) for h in headers]  # Start with header widths

        # Collect Data Rows
        rows = []
        for param, default in cls._defaults.items():
            has_synonyms = &#34;✅ Yes&#34; if param in cls._synonyms else &#34;❌ No&#34;
            description = cls._descriptionInputs.get(param, &#34;No description available&#34;)

            # Update column widths dynamically
            col_widths[0] = max(col_widths[0], len(param))
            col_widths[1] = max(col_widths[1], len(str(default)))
            col_widths[2] = max(col_widths[2], len(has_synonyms))
            col_widths[3] = max(col_widths[3], len(description))

            rows.append([param, str(default), has_synonyms, description])

        # Function to wrap text for a given column width
        def wrap_text(text, width):
            return textwrap.fill(text, width)

        # Print Table with Adjusted Column Widths
        separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in col_widths) + &#34;-+&#34;
        print(&#34;\n### **Accepted Parameters and Defaults**\n&#34;)
        print(separator)
        print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(col_widths[i]) for i, h in enumerate(headers)) + &#34; |&#34;)
        print(separator)
        for row in rows:
            # Wrap text in the description column
            row[3] = wrap_text(row[3], col_widths[3])

            # Print row
            print(&#34;| &#34; + &#34; | &#34;.join(row[i].ljust(col_widths[i]) for i in range(3)) + &#34; | &#34; + row[3])
        print(separator)

        # Synonyms Table
        print(&#34;\n### **Parameter Synonyms**\n&#34;)
        syn_headers = [&#34;Parameter&#34;, &#34;Synonyms&#34;]
        syn_col_widths = [
            max(len(&#34;Parameter&#34;), max(len(k) for k in cls._synonyms.keys())),  # Ensure it fits &#34;Parameter&#34;
            max(len(&#34;Synonyms&#34;), max(len(&#34;, &#34;.join(v)) for v in cls._synonyms.values()))  # Ensure it fits &#34;Synonyms&#34;
        ]
        syn_separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in syn_col_widths) + &#34;-+&#34;
        print(syn_separator)
        print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(syn_col_widths[i]) for i, h in enumerate(syn_headers)) + &#34; |&#34;)
        print(syn_separator)
        for param, synonyms in cls._synonyms.items():
            print(f&#34;| {param.ljust(syn_col_widths[0])} | {&#39;, &#39;.join(synonyms).ljust(syn_col_widths[1])} |&#34;)
        print(syn_separator)


    # --------------------------------------------------------------------
    # Class method to handle ambiguous definition from end-user
    # --------------------------------------------------------------------
    @classmethod
    def resolvename(cls, param_value, param_key, **unresolved):
        &#34;&#34;&#34;
        Resolves the correct parameter value using known synonyms.

        - If param_value is already set (not None), return it.
        - If a synonym exists in **unresolved, assign its value.
        - If multiple synonyms of the same parameter appear in **unresolved, raise an error.
        - Otherwise, return None.

        Parameters:
        - `param_name` (any): The original value (if provided).
        - `param_key` (str): The legitimate parameter name we are resolving.
        - `unresolved` (dict): The dictionary of unrecognized keyword arguments.

        Returns:
        - The resolved value or None if not found.
        &#34;&#34;&#34;
        if param_value is not None:
            return param_value  # The parameter is explicitly defined, do not override
        if not unresolved:      # shortcut
            return None
        resolved_value = None
        found_keys = []
        # Check if param_key itself is present in unresolved
        if param_key in unresolved:
            found_keys.append(param_key)
            resolved_value = unresolved[param_key]
        # Check if any of its synonyms are in unresolved
        if param_key in cls._synonyms:
            for synonym in cls._synonyms[param_key]:
                if synonym in unresolved:
                    found_keys.append(synonym)
                    resolved_value = unresolved[synonym]
        # Raise error if multiple synonyms were found
        if len(found_keys) &gt; 1:
            raise ValueError(
                f&#34;Conflicting definitions: Multiple synonyms {found_keys} were provided for &#39;{param_key}&#39;.&#34;
            )
        return resolved_value


    # --------------------------------------------------------------------
    # overloading binary addition (note that the output is of type layer)
    # --------------------------------------------------------------------
    def __add__(self,other):
        &#34;&#34;&#34; C=A+B | overload + operator &#34;&#34;&#34;
        if isinstance(other, layer):
            res = duplicate(self)
            res._nmeshmin = min(self._nmeshmin,other._nmeshmin)
            # propage substance
            if self._substance is None:
                res._substance = other._substance
            else:
                if isinstance(self._substance,migrant) and isinstance(other._substance,migrant):
                    if self._substance.M != other._substance.M:
                        print(&#34;Warning: the smallest subtance is propagated everywhere&#34;)
                    res._substance = self._substance if self._substance.M&lt;=other._substance.M else other._substance
                else:
                    res._substance = None
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_code&#34;,&#34;_nlayer&#34;]:
                setattr(res,p,getattr(self,p)+getattr(other,p))
            for p in [&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;,&#34;_rho&#34;,&#34;_T&#34;]:
                setattr(res,p,np.concatenate((getattr(self,p),getattr(other,p))))
            # we add the history of all layers
            res._layerclass_history = self.layerclass_history + other.layerclass_history
            return res
        else: raise ValueError(&#34;invalid layer object&#34;)


    # --------------------------------------------------------------------
    # overloading binary multiplication (note that the output is of type layer)
    # --------------------------------------------------------------------
    def __mul__(self,ntimes):
        &#34;&#34;&#34; nA = A*n | overload * operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
            res = duplicate(self)
            if ntimes&gt;1:
                for n in range(1,ntimes): res += self
            return res
        else: raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)


    # --------------------------------------------------------------------
    # len method
    # --------------------------------------------------------------------
    def __len__(self):
        &#34;&#34;&#34; length method &#34;&#34;&#34;
        return self._nlayer

    # --------------------------------------------------------------------
    # object indexing (get,set) method
    # --------------------------------------------------------------------
    def __getitem__(self,i):
        &#34;&#34;&#34; get indexing method &#34;&#34;&#34;
        res = duplicate(self)
        # check indices
        isscalar = isinstance(i,int)
        if isinstance(i,slice):
            if i.step==None: j = list(range(i.start,i.stop))
            else: j = list(range(i.start,i.stop,i.step))
            res._nlayer = len(j)
        if isinstance(i,int): res._nlayer = 1
        # pick indices for each property
        for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
            content = getattr(self,p)
            try:
                if isscalar: setattr(res,p,content[i:i+1])
                else: setattr(res,p,content[i])
            except IndexError as err:
                if self.verbosity&gt;0 and self.verbose:
                    print(&#34;bad layer object indexing: &#34;,err)
        return res

    def __setitem__(self,i,other):
        &#34;&#34;&#34; set indexing method &#34;&#34;&#34;
        # check indices
        if isinstance(i,slice):
            if i.step==None: j = list(range(i.start,i.stop))
            else: j = list(range(i.start,i.stop,i.step))
        elif isinstance(i,int): j = [i]
        else:raise IndexError(&#34;invalid index&#34;)
        islayer = isinstance(other,layer)
        isempty = not islayer and isinstance(other,list) and len(other)&lt;1
        if isempty:         # empty right hand side
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
                content = getattr(self,p)
                try:
                    newcontent = [content[k] for k in range(self._nlayer) if k not in j]
                except IndexError as err:
                    if self.verbosity&gt;0 and self.verbose:
                        print(&#34;bad layer object indexing: &#34;,err)
                if isinstance(content,np.ndarray) and not isinstance(newcontent,np.ndarray):
                    newcontent = np.array(newcontent)
                setattr(self,p,newcontent)
            self._nlayer = len(newcontent)
        elif islayer:        # islayer right hand side
            nk1 = len(j)
            nk2 = other._nlayer
            if nk1 != nk2:
                raise IndexError(&#34;the number of elements does not match the number of indices&#34;)
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
                content1 = getattr(self,p)
                content2 = getattr(other,p)
                for k in range(nk1):
                    try:
                        content1[j[k]] = content2[k]
                    except IndexError as err:
                        if self.verbosity&gt;0 and self.verbose:
                            print(&#34;bad layer object indexing: &#34;,err)
                setattr(self,p,content1)
        else:
            raise ValueError(&#34;only [] or layer object are accepted&#34;)


    # --------------------------------------------------------------------
    # Getter methods (show private/hidden properties and meta-properties)
    # --------------------------------------------------------------------
    @property
    def layerclass_history(self):
        return self._layerclass_history if self._layerclass_history != [] else [self.layerclass]
    @property
    def layerclass(self): return type(self).__name__
    @property
    def name(self): return self._name
    @property
    def type(self): return self._type
    @property
    def material(self): return self._material
    @property
    def code(self): return self._code
    @property
    def l(self): return self._l
    @property
    def D(self):
        Dtmp = self.Dmodel()
        if Dtmp is not None:
            return np.full_like(self._D, Dtmp)
        else:
            return self._D
    @property
    def k(self):
        ktmp = self.kmodel()
        if ktmp:
            return np.full_like(self._D, ktmp)
        else:
            return self._k
    @property
    def C0(self): return self._C0
    @property
    def rho(self): return self._rho
    @property
    def T(self): return self._T
    @property
    def TK(self): return self._T+T0K
    @property
    def lunit(self): return self._lunit
    @property
    def Dunit(self): return self._Dunit
    @property
    def kunit(self): return self._kunit
    @property
    def Cunit(self): return self._Cunit
    @property
    def rhounit(self): return self._rhounit
    @property
    def Tunit(self): return self._Tunit
    @property
    def TKunit(self): return &#34;K&#34;
    @property
    def n(self): return self._nlayer
    @property
    def nmesh(self): return self._nmesh
    @property
    def nmeshmin(self): return self._nmeshmin
    @property
    def resistance(self): return self.l*self.k/self.D
    @property
    def permeability(self): return self.D/(self.l*self.k)
    @property
    def lag(self): return self.l**2/(6*self.D)
    @property
    def pressure(self): return self.k*self.C0
    @property
    def thickness(self): return sum(self.l)
    @property
    def concentration(self): return sum(self.l*self.C0)/self.thickness
    @property
    def relative_thickness(self): return self.l/self.thickness
    @property
    def relative_resistance(self): return self.resistance/sum(self.resistance)
    @property
    def rank(self): return np.flip(np.argsort(np.array(self.resistance))+1).tolist()
    @property
    def referencelayer(self): return np.argmax(self.resistance)
    @property
    def lreferencelayer(self): return self.l[self.referencelayer]
    @property
    def Foscale(self): return self.D[self.referencelayer]/self.lreferencelayer**2

    # layer substance (of class migrant or None)
    @property
    def substance(self): return self._substance

    # Dmodel and kmodel returned as properties (they are lambda functions)
    # polymer and mass are udpdated on the fly (the code loops over all layers)
    @property
    def Dmodel(self):
        &#34;&#34;&#34;Return a callable function that evaluates D with updated parameters.&#34;&#34;&#34;
        if not isinstance(self._substance,migrant) or self._substance.Deval() is None:
            return lambda **kwargs: None  # Return a function that always returns None
        template = self._substance.Dtemplate.copy()
        template.update()
        def func(**kwargs):
            D = np.empty_like(self._D)
            for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
                template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
                # inherit eventual user parameters
                D[i] = self._substance.D.evaluate(**dict(template, **kwargs))
            return D
        return func

    @property
    def kmodel(self):
        &#34;&#34;&#34;Return a callable function that evaluates k with updated parameters.&#34;&#34;&#34;
        if not isinstance(self._substance,migrant) or self._substance.keval() is None:
            return lambda **kwargs: None  # Return a function that always returns None
        template = self._substance.ktemplate.copy()
        template.update()
        def func(**kwargs):
            k = np.empty_like(self._k)
            for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
                template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
                # inherit eventual user parameters
                k[i] = self._substance.k.evaluate(**dict(template, **kwargs))
            return k
        return func


    # --------------------------------------------------------------------
    # comparators based resistance
    # --------------------------------------------------------------------
    def __eq__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1==value2

    def __ne__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1!=value2

    def __lt__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&lt;value2

    def __gt__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&gt;value2

    def __le__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&lt;=value2

    def __ge__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&gt;=value2


    # --------------------------------------------------------------------
    # Generates mesh
    # --------------------------------------------------------------------
    def mesh(self,nmesh=None,nmeshmin=None):
        &#34;&#34;&#34; nmesh() generates mesh based on nmesh and nmeshmin, nmesh(nmesh=value,nmeshmin=value) &#34;&#34;&#34;
        if nmesh==None: nmesh = self.nmesh
        if nmeshmin==None: nmeshmin = self.nmeshmin
        if nmeshmin&gt;nmesh: nmeshmin,nmesh = nmesh, nmeshmin
        # X = mesh distribution (number of nodes per layer)
        X = np.ones(self._nlayer)
        for i in range(1,self._nlayer):
           X[i] = X[i-1]*(self.permeability[i-1]*self.l[i])/(self.permeability[i]*self.l[i-1])
        X = np.maximum(nmeshmin,np.ceil(nmesh*X/sum(X)))
        X = np.round((X/sum(X))*nmesh).astype(int)
        # do the mesh
        x0 = 0
        mymesh = []
        for i in range(self._nlayer):
            mymesh.append(mesh(self.l[i]/self.l[self.referencelayer],X[i],x0=x0,index=i))
            x0 += self.l[i]
        return mymesh

    # --------------------------------------------------------------------
    # Getter methods and tools to validate inputs checknumvalue and checktextvalue
    # --------------------------------------------------------------------
    def checknumvalue(self,value,ExpectedUnits=None):
        &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
        if isinstance(value,tuple):
            value = check_units(value,ExpectedUnits=ExpectedUnits)
        if isinstance(value,int): value = float(value)
        if isinstance(value,float): value = np.array([value])
        if isinstance(value,list): value = np.array(value)
        if len(value)&gt;self._nlayer:
            value = value[:self._nlayer]
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the extra value(s) has been removed&#39;)
        elif len(value)&lt;self._nlayer:
            value = np.concatenate((value,value[-1:]*np.ones(self._nlayer-len(value))))
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the last value has been repeated&#39;)
        return value

    def checktextvalue(self,value):
        &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
        if not isinstance(value,list): value = [value]
        if len(value)&gt;self._nlayer:
            value = value[:self._nlayer]
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the extra entry(ies) has been removed&#39;)
        elif len(value)&lt;self._nlayer:
            value = value + value[-1:]*(self._nlayer-len(value))
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the last entry has been repeated&#39;)
        return value

    @l.setter
    def l(self,value): self._l =self.checknumvalue(value,layer._defaults[&#34;lunit&#34;])
    @D.setter
    def D(self,value): self._D=self.checknumvalue(value,layer._defaults[&#34;Dunit&#34;])
    @k.setter
    def k(self,value): self._k =self.checknumvalue(value,layer._defaults[&#34;kunit&#34;])
    @C0.setter
    def C0(self,value): self._C0 =self.checknumvalue(value,layer._defaults[&#34;Cunit&#34;])
    @rho.setter
    def rho(self,value): self._rho =self.checknumvalue(value,layer._defaults[&#34;rhounit&#34;])
    @T.setter
    def T(self,value): self._T =self.checknumvalue(value,layer._defaults[&#34;Tunit&#34;])
    @name.setter
    def name(self,value): self._name =self.checktextvalue(value)
    @type.setter
    def type(self,value): self._type =self.checktextvalue(value)
    @material.setter
    def material(self,value): self._material =self.checktextvalue(value)
    @nmesh.setter
    def nmesh(self,value): self._nmesh = max(value,self._nlayer*self._nmeshmin)
    @nmeshmin.setter
    def nmeshmin(self,value): self._nmeshmin = max(value,round(self._nmesh/(2*self._nlayer)))
    @substance.setter
    def substance(self,value):
        if not isinstance(value,migrant):
            raise TypeError(f&#34;value must be a migrant class not a {type(value).__name__}&#34;)
        self._substance = value


    # --------------------------------------------------------------------
    # hash methods (assembly and layer-by-layer)
    # note that list needs to be converted into tuples to be hashed
    # --------------------------------------------------------------------
    def __hash__(self):
        &#34;&#34;&#34; hash layer-object (assembly) method &#34;&#34;&#34;
        return hash((tuple(self._name),
                     tuple(self._type),
                     tuple(self._material),
                     tuple(self._l),
                     tuple(self._D),
                     tuple(self.k),
                     tuple(self._C0),
                     tuple(self._rho)))

    # layer-by-layer @property = decoration to consider it
    # as a property instead of a method/attribute
    # comprehension for n in range(self._nlayer) applies it to all layers
    @property
    def hashlayer(self):
        &#34;&#34;&#34; hash layer (layer-by-layer) method &#34;&#34;&#34;
        return [hash((self._name[n],
                      self._type[n],
                      self._material[n],
                      self._l[n],
                      self._D[n],
                      self.k[n],
                      self._C0[n],
                      self._rho[n]))
                for n in range(self._nlayer)
                ]


    # --------------------------------------------------------------------
    # repr method (since the getter are defined, the &#39;_&#39; is dropped)
    # --------------------------------------------------------------------
    # density and temperature are not shown
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        print(&#34;\n[%s version=%0.4g, contact=%s]&#34; % (self.__description,self.__version,self.__contact))
        if self._nlayer==0:
            print(&#34;empty %s&#34; % (self.__description))
        else:
            hasDmodel = self.Dmodel() is not None
            haskmodel = self.kmodel() is not None
            properties_ = {&#34;l&#34;:False,&#34;D&#34;:hasDmodel,&#34;k&#34;:haskmodel,&#34;C0&#34;:False}
            if hasDmodel or haskmodel:
                properties_[&#34;T&#34;] = False
            fmtval = &#39;%10s: &#39;+self._printformat+&#34; [%s]&#34;
            fmtstr = &#39;%10s= %s&#39;
            if self._nlayer==1:
                print(f&#39;monolayer of {self.__description}:&#39;)
            else:
                print(f&#39;{self._nlayer}-multilayer of {self.__description}:&#39;)
            for n in range(1,self._nlayer+1):
                modelinfo = {
                    &#34;D&#34;: f&#34;{self._substance.D.__name__}({self.layerclass_history[n-1]},{self._substance},T={float(self.T[0])} {self.Tunit})&#34; if hasDmodel else &#34;&#34;,
                    &#34;k&#34;: f&#34;{self._substance.k.__name__}({self.layerclass_history[n-1]},{self._substance} g/mol,T={float(self.T[0])} {self.Tunit})&#34; if haskmodel else &#34;&#34;,
                    }
                print(&#39;-- [ layer %d of %d ] ---------- barrier rank=%d --------------&#39;
                      % (n,self._nlayer,self.rank[n-1]))
                for p in [&#34;name&#34;,&#34;type&#34;,&#34;material&#34;,&#34;code&#34;]:
                    v = getattr(self,p)
                    print(&#39;%10s: &#34;%s&#34;&#39; % (p,v[n-1]),flush=True)
                for p in properties_.keys():
                    v = getattr(self,p)                 # value
                    vunit = getattr(self,p[0]+&#34;unit&#34;)   # value unit
                    print(fmtval % (p,v[n-1],vunit),flush=True)
                    if properties_[p]:
                        print(fmtstr % (&#34;&#34;,modelinfo[p]),flush=True)
        return str(self)

    def __str__(self):
        &#34;&#34;&#34;Formatted string representation of layer&#34;&#34;&#34;
        all_identical = len(set(self.layerclass_history)) == 1
        cls = self.__class__.__name__ if all_identical else &#34;multilayer&#34;
        return f&#34;&lt;{cls} with {self.n} layer{&#39;s&#39; if self.n&gt;1 else &#39;&#39;}: {self.name}&gt;&#34;

    # --------------------------------------------------------------------
    # Returns the equivalent dictionary from an object for debugging
    # --------------------------------------------------------------------
    def _todict(self):
        &#34;&#34;&#34; returns the equivalent dictionary from an object &#34;&#34;&#34;
        return dict((key, getattr(self, key)) for key in dir(self) if key not in dir(self.__class__))
    # --------------------------------------------------------------------

    # --------------------------------------------------------------------
    # Simplify layers by collecting similar ones
    # --------------------------------------------------------------------
    def simplify(self):
        &#34;&#34;&#34; merge continuous layers of the same type &#34;&#34;&#34;
        nlayer = self._nlayer
        if nlayer&gt;1:
           res = self[0]
           ires = 0
           ireshash = res.hashlayer[0]
           for i in range(1,nlayer):
               if self.hashlayer[i]==ireshash:
                   res.l[ires] = res.l[ires]+self.l[i]
               else:
                   res = res + self[i]
                   ires = ires+1
                   ireshash = self.hashlayer[i]
        else:
             res = self.copy()
        return res

    # --------------------------------------------------------------------
    # Split layers into a tuple
    # --------------------------------------------------------------------
    def split(self):
        &#34;&#34;&#34; split layers &#34;&#34;&#34;
        out = ()
        if self._nlayer&gt;0:
            for i in range(self._nlayer):
                out = out + (self[i],) # (,) special syntax for tuple singleton
        return out

    # --------------------------------------------------------------------
    # deepcopy
    # --------------------------------------------------------------------
    def copy(self,**kwargs):
        &#34;&#34;&#34;
        Creates a deep copy of the current layer instance.

        Returns:
        - layer: A new layer instance identical to the original.
        &#34;&#34;&#34;
        return duplicate(self).update(**kwargs)

    # --------------------------------------------------------------------
    # update contact conditions from a foodphysics instance (or do the reverse)
    # material &lt;&lt; medium
    # --------------------------------------------------------------------
    def _from(self,medium=None):
        &#34;&#34;&#34;Propagates contact conditions from food instance&#34;&#34;&#34;
        from patankar.food import foodphysics
        if not isinstance(medium,foodphysics):
            raise TypeError(f&#34;medium must be a foodphysics, foodlayer not a {type(medium).__name__}&#34;)
        if not hasattr(medium, &#34;contacttemperature&#34;):
            medium.contacttemperature = self.T[0]
        T = self.get_param(&#34;contacttemperature&#34;,40,acceptNone=False)
        self.T = np.full_like(self.T,T)

    # overloading operation
    def __lshift__(self, medium):
        &#34;&#34;&#34;Overloads &lt;&lt; to propagate contact conditions from food.&#34;&#34;&#34;
        self._from(medium)

    # --------------------------------------------------------------------
    # Inheritance registration mechanism associated with food &gt;&gt; layer
    # It is used by food, not by layer (please refer to food.py).
    # Note that layer &gt;&gt; food means mass transfer simulation
    # --------------------------------------------------------------------
    def acknowledge(self, what=None, category=None):
        &#34;&#34;&#34;
        Register inherited properties under a given category.

        Parameters:
        -----------
        what : str or list of str or a set
            The properties or attributes that have been inherited.
        category : str
            The category under which the properties are grouped.
        &#34;&#34;&#34;
        if category is None or what is None:
            raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
        if isinstance(what, str):
            what = {what}  # Convert string to a set
        elif isinstance(what, list):
            what = set(what)  # Convert list to a set for uniqueness
        elif not isinstance(what,set):
            raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
        if category not in self._hasbeeninherited:
            self._hasbeeninherited[category] = set()
        self._hasbeeninherited[category].update(what)

    # --------------------------------------------------------------------
    # migration simulation overloaded as sim = layer &gt;&gt; food
    # using layer &gt;&gt; food without output works also.
    # The result is stored in food.lastsimulation
    # --------------------------------------------------------------------
    def contact(self,medium,**kwargs):
        return self.migration(medium,**kwargs)

    def migration(self,medium,**kwargs):
        from patankar.migration import senspatankar
        sim = senspatankar(self,medium,**kwargs)
        medium.lastsimulation = sim # store the last simulation result in medium
        medium.lastinput = self # store the last input (self)
        sim.savestate(self,medium) # store store the inputs in sim for chaining
        return sim

    # overloading operation
    def __rshift__(self, medium):
        &#34;&#34;&#34;Overloads &gt;&gt; to propagate migration to food.&#34;&#34;&#34;
        from patankar.food import foodphysics
        if not isinstance(medium,foodphysics):
            raise TypeError(f&#34;medium must be a foodphysics object not a {type(medium).__name__}&#34;)
        return self.contact(medium)

    # --------------------------------------------------------------------
    # Safe update method
    # --------------------------------------------------------------------
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update layer parameters following strict validation rules.

        Rules:
        1) key should be listed in self._defaults
        2) for some keys, synonyms are acceptable as reported in self._synonyms
        3) values cannot be None if they were not None in _defaults
        4) values should be str if they were initially str, idem with bool
        5) values which were numeric (int, float, np.ndarray) should remain numeric.
        6) lists are acceptable as numeric arrays
        7) all numerical (float, np.ndarray, list) except int must be converted into numpy arrays.
           Values which were int in _defaults must remain int and an error should be raised
           if a float value is proposed.
        8) keys listed in _parametersWithUnits can be assigned with tuples (value, &#34;unit&#34;).
           They will be converted automatically with check_units(value).
        9) for parameters with a default value None, any value is acceptable
        10) A clear error message should be displayed for any bad value showing the
            current value of the parameter and its default value.
        &#34;&#34;&#34;

        if not kwargs:  # shortcut
            return self # for chaining

        param_counts = {key: 0 for key in self._defaults}  # Track how many times each param is set

        def resolve_key(key):
            &#34;&#34;&#34;Resolve key considering synonyms and check for duplicates.&#34;&#34;&#34;
            for main_key, synonyms in self._synonyms.items():
                if key == main_key or key in synonyms:
                    param_counts[main_key] += 1
                    return main_key
            param_counts[key] += 1
            return key

        def validate_value(key, value):
            &#34;&#34;&#34;Validate and process the value according to the rules.&#34;&#34;&#34;
            default_value = self._defaults[key]

            # Rule 3: values cannot be None if they were not None in _defaults
            if value is None and default_value is not None:
                raise ValueError(f&#34;Invalid value for &#39;{key}&#39;: None is not allowed. &#34;
                                 f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 9: If default is None, any value is acceptable
            if default_value is None:
                return value

            # Rule 4 &amp; 5: Ensure type consistency (str, bool, or numeric types)
            if isinstance(default_value, str) and not isinstance(value, str):
                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected str, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
            if isinstance(default_value, bool) and not isinstance(value, bool):
                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected bool, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 6 &amp; 7: Convert numeric types properly
            if isinstance(default_value, (int, float, np.ndarray)):
                if isinstance(value, list):
                    value = np.array(value)

                if isinstance(default_value, int):
                    if isinstance(value, float) or (isinstance(value, np.ndarray) and np.issubdtype(value.dtype, np.floating)):
                        raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got float. &#34;
                                        f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
                    if isinstance(value, (int, np.integer)):
                        return int(value)  # Ensure it remains an int
                    raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got {type(value).__name__}. &#34;
                                    f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

                if isinstance(value, (int, float, list, np.ndarray)):
                    return np.array(value, dtype=float)  # Convert everything to np.array for floats

                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected numeric, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 8: Convert units if applicable
            if key in self._parametersWithUnits and isinstance(value, tuple):
                value, unit = value
                converted_value, _ = check_units((value, unit), ExpectedUnits=self._parametersWithUnits[key])
                return converted_value

            return value

        # Apply updates while tracking parameter occurrences
        for key, value in kwargs.items():
            resolved_key = resolve_key(key)

            if resolved_key not in self._defaults:
                raise KeyError(f&#34;Invalid key &#39;{key}&#39;. Allowed keys: {list(self._defaults.keys())}.&#34;)

            try:
                validated_value = validate_value(resolved_key, value)
                setattr(self, resolved_key, validated_value)
            except (TypeError, ValueError) as e:
                raise ValueError(f&#34;Error updating &#39;{key}&#39;: {e}&#34;)

        # Ensure that no parameter was set multiple times due to synonyms
        duplicate_keys = [k for k, v in param_counts.items() if v &gt; 1]
        if duplicate_keys:
            raise ValueError(f&#34;Duplicate assignment detected for parameters: {duplicate_keys}. &#34;
                             &#34;Use only one synonym per parameter.&#34;)

        return self # to enable chaining</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>patankar.layer.AdhesiveAcrylate</li>
<li>patankar.layer.AdhesiveEVA</li>
<li>patankar.layer.AdhesiveNaturalRubber</li>
<li>patankar.layer.AdhesivePU</li>
<li>patankar.layer.AdhesivePVAC</li>
<li>patankar.layer.AdhesiveSyntheticRubber</li>
<li>patankar.layer.AdhesiveVAE</li>
<li>patankar.layer.Cardboard</li>
<li>patankar.layer.HDPE</li>
<li>patankar.layer.HIPS</li>
<li>patankar.layer.LDPE</li>
<li>patankar.layer.LLDPE</li>
<li>patankar.layer.PA6</li>
<li>patankar.layer.PA66</li>
<li>patankar.layer.PBT</li>
<li>patankar.layer.PEN</li>
<li>patankar.layer.PP</li>
<li>patankar.layer.PPrubber</li>
<li>patankar.layer.PS</li>
<li>patankar.layer.Paper</li>
<li>patankar.layer.SBS</li>
<li>patankar.layer.air</li>
<li>patankar.layer.gPET</li>
<li>patankar.layer.oPP</li>
<li>patankar.layer.plasticizedPVC</li>
<li>patankar.layer.rPET</li>
<li>patankar.layer.rigidPVC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="food.layer.help"><code class="name flex">
<span>def <span class="ident">help</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a dynamically formatted summary of all input parameters,
adjusting column widths based on content and wrapping long descriptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def help(cls):
    &#34;&#34;&#34;
    Prints a dynamically formatted summary of all input parameters,
    adjusting column widths based on content and wrapping long descriptions.
    &#34;&#34;&#34;

    # Column Headers
    headers = [&#34;Parameter&#34;, &#34;Default Value&#34;, &#34;Has Synonyms?&#34;, &#34;Description&#34;]
    col_widths = [len(h) for h in headers]  # Start with header widths

    # Collect Data Rows
    rows = []
    for param, default in cls._defaults.items():
        has_synonyms = &#34;✅ Yes&#34; if param in cls._synonyms else &#34;❌ No&#34;
        description = cls._descriptionInputs.get(param, &#34;No description available&#34;)

        # Update column widths dynamically
        col_widths[0] = max(col_widths[0], len(param))
        col_widths[1] = max(col_widths[1], len(str(default)))
        col_widths[2] = max(col_widths[2], len(has_synonyms))
        col_widths[3] = max(col_widths[3], len(description))

        rows.append([param, str(default), has_synonyms, description])

    # Function to wrap text for a given column width
    def wrap_text(text, width):
        return textwrap.fill(text, width)

    # Print Table with Adjusted Column Widths
    separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in col_widths) + &#34;-+&#34;
    print(&#34;\n### **Accepted Parameters and Defaults**\n&#34;)
    print(separator)
    print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(col_widths[i]) for i, h in enumerate(headers)) + &#34; |&#34;)
    print(separator)
    for row in rows:
        # Wrap text in the description column
        row[3] = wrap_text(row[3], col_widths[3])

        # Print row
        print(&#34;| &#34; + &#34; | &#34;.join(row[i].ljust(col_widths[i]) for i in range(3)) + &#34; | &#34; + row[3])
    print(separator)

    # Synonyms Table
    print(&#34;\n### **Parameter Synonyms**\n&#34;)
    syn_headers = [&#34;Parameter&#34;, &#34;Synonyms&#34;]
    syn_col_widths = [
        max(len(&#34;Parameter&#34;), max(len(k) for k in cls._synonyms.keys())),  # Ensure it fits &#34;Parameter&#34;
        max(len(&#34;Synonyms&#34;), max(len(&#34;, &#34;.join(v)) for v in cls._synonyms.values()))  # Ensure it fits &#34;Synonyms&#34;
    ]
    syn_separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in syn_col_widths) + &#34;-+&#34;
    print(syn_separator)
    print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(syn_col_widths[i]) for i, h in enumerate(syn_headers)) + &#34; |&#34;)
    print(syn_separator)
    for param, synonyms in cls._synonyms.items():
        print(f&#34;| {param.ljust(syn_col_widths[0])} | {&#39;, &#39;.join(synonyms).ljust(syn_col_widths[1])} |&#34;)
    print(syn_separator)</code></pre>
</details>
</dd>
<dt id="food.layer.resolvename"><code class="name flex">
<span>def <span class="ident">resolvename</span></span>(<span>param_value, param_key, **unresolved)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolves the correct parameter value using known synonyms.</p>
<ul>
<li>If param_value is already set (not None), return it.</li>
<li>If a synonym exists in **unresolved, assign its value.</li>
<li>If multiple synonyms of the same parameter appear in **unresolved, raise an error.</li>
<li>Otherwise, return None.</li>
</ul>
<p>Parameters:
- <code>param_name</code> (any): The original value (if provided).
- <code>param_key</code> (str): The legitimate parameter name we are resolving.
- <code>unresolved</code> (dict): The dictionary of unrecognized keyword arguments.</p>
<p>Returns:
- The resolved value or None if not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def resolvename(cls, param_value, param_key, **unresolved):
    &#34;&#34;&#34;
    Resolves the correct parameter value using known synonyms.

    - If param_value is already set (not None), return it.
    - If a synonym exists in **unresolved, assign its value.
    - If multiple synonyms of the same parameter appear in **unresolved, raise an error.
    - Otherwise, return None.

    Parameters:
    - `param_name` (any): The original value (if provided).
    - `param_key` (str): The legitimate parameter name we are resolving.
    - `unresolved` (dict): The dictionary of unrecognized keyword arguments.

    Returns:
    - The resolved value or None if not found.
    &#34;&#34;&#34;
    if param_value is not None:
        return param_value  # The parameter is explicitly defined, do not override
    if not unresolved:      # shortcut
        return None
    resolved_value = None
    found_keys = []
    # Check if param_key itself is present in unresolved
    if param_key in unresolved:
        found_keys.append(param_key)
        resolved_value = unresolved[param_key]
    # Check if any of its synonyms are in unresolved
    if param_key in cls._synonyms:
        for synonym in cls._synonyms[param_key]:
            if synonym in unresolved:
                found_keys.append(synonym)
                resolved_value = unresolved[synonym]
    # Raise error if multiple synonyms were found
    if len(found_keys) &gt; 1:
        raise ValueError(
            f&#34;Conflicting definitions: Multiple synonyms {found_keys} were provided for &#39;{param_key}&#39;.&#34;
        )
    return resolved_value</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="food.layer.C0"><code class="name">var <span class="ident">C0</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def C0(self): return self._C0</code></pre>
</details>
</dd>
<dt id="food.layer.Cunit"><code class="name">var <span class="ident">Cunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Cunit(self): return self._Cunit</code></pre>
</details>
</dd>
<dt id="food.layer.D"><code class="name">var <span class="ident">D</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def D(self):
    Dtmp = self.Dmodel()
    if Dtmp is not None:
        return np.full_like(self._D, Dtmp)
    else:
        return self._D</code></pre>
</details>
</dd>
<dt id="food.layer.Dmodel"><code class="name">var <span class="ident">Dmodel</span></code></dt>
<dd>
<div class="desc"><p>Return a callable function that evaluates D with updated parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Dmodel(self):
    &#34;&#34;&#34;Return a callable function that evaluates D with updated parameters.&#34;&#34;&#34;
    if not isinstance(self._substance,migrant) or self._substance.Deval() is None:
        return lambda **kwargs: None  # Return a function that always returns None
    template = self._substance.Dtemplate.copy()
    template.update()
    def func(**kwargs):
        D = np.empty_like(self._D)
        for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
            template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
            # inherit eventual user parameters
            D[i] = self._substance.D.evaluate(**dict(template, **kwargs))
        return D
    return func</code></pre>
</details>
</dd>
<dt id="food.layer.Dunit"><code class="name">var <span class="ident">Dunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Dunit(self): return self._Dunit</code></pre>
</details>
</dd>
<dt id="food.layer.Foscale"><code class="name">var <span class="ident">Foscale</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Foscale(self): return self.D[self.referencelayer]/self.lreferencelayer**2</code></pre>
</details>
</dd>
<dt id="food.layer.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def T(self): return self._T</code></pre>
</details>
</dd>
<dt id="food.layer.TK"><code class="name">var <span class="ident">TK</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def TK(self): return self._T+T0K</code></pre>
</details>
</dd>
<dt id="food.layer.TKunit"><code class="name">var <span class="ident">TKunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def TKunit(self): return &#34;K&#34;</code></pre>
</details>
</dd>
<dt id="food.layer.Tunit"><code class="name">var <span class="ident">Tunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tunit(self): return self._Tunit</code></pre>
</details>
</dd>
<dt id="food.layer.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def code(self): return self._code</code></pre>
</details>
</dd>
<dt id="food.layer.concentration"><code class="name">var <span class="ident">concentration</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def concentration(self): return sum(self.l*self.C0)/self.thickness</code></pre>
</details>
</dd>
<dt id="food.layer.hashlayer"><code class="name">var <span class="ident">hashlayer</span></code></dt>
<dd>
<div class="desc"><p>hash layer (layer-by-layer) method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hashlayer(self):
    &#34;&#34;&#34; hash layer (layer-by-layer) method &#34;&#34;&#34;
    return [hash((self._name[n],
                  self._type[n],
                  self._material[n],
                  self._l[n],
                  self._D[n],
                  self.k[n],
                  self._C0[n],
                  self._rho[n]))
            for n in range(self._nlayer)
            ]</code></pre>
</details>
</dd>
<dt id="food.layer.k"><code class="name">var <span class="ident">k</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def k(self):
    ktmp = self.kmodel()
    if ktmp:
        return np.full_like(self._D, ktmp)
    else:
        return self._k</code></pre>
</details>
</dd>
<dt id="food.layer.kmodel"><code class="name">var <span class="ident">kmodel</span></code></dt>
<dd>
<div class="desc"><p>Return a callable function that evaluates k with updated parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kmodel(self):
    &#34;&#34;&#34;Return a callable function that evaluates k with updated parameters.&#34;&#34;&#34;
    if not isinstance(self._substance,migrant) or self._substance.keval() is None:
        return lambda **kwargs: None  # Return a function that always returns None
    template = self._substance.ktemplate.copy()
    template.update()
    def func(**kwargs):
        k = np.empty_like(self._k)
        for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
            template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
            # inherit eventual user parameters
            k[i] = self._substance.k.evaluate(**dict(template, **kwargs))
        return k
    return func</code></pre>
</details>
</dd>
<dt id="food.layer.kunit"><code class="name">var <span class="ident">kunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kunit(self): return self._kunit</code></pre>
</details>
</dd>
<dt id="food.layer.l"><code class="name">var <span class="ident">l</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def l(self): return self._l</code></pre>
</details>
</dd>
<dt id="food.layer.lag"><code class="name">var <span class="ident">lag</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lag(self): return self.l**2/(6*self.D)</code></pre>
</details>
</dd>
<dt id="food.layer.layerclass"><code class="name">var <span class="ident">layerclass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def layerclass(self): return type(self).__name__</code></pre>
</details>
</dd>
<dt id="food.layer.layerclass_history"><code class="name">var <span class="ident">layerclass_history</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def layerclass_history(self):
    return self._layerclass_history if self._layerclass_history != [] else [self.layerclass]</code></pre>
</details>
</dd>
<dt id="food.layer.lreferencelayer"><code class="name">var <span class="ident">lreferencelayer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lreferencelayer(self): return self.l[self.referencelayer]</code></pre>
</details>
</dd>
<dt id="food.layer.lunit"><code class="name">var <span class="ident">lunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lunit(self): return self._lunit</code></pre>
</details>
</dd>
<dt id="food.layer.material"><code class="name">var <span class="ident">material</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def material(self): return self._material</code></pre>
</details>
</dd>
<dt id="food.layer.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self): return self._nlayer</code></pre>
</details>
</dd>
<dt id="food.layer.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self): return self._name</code></pre>
</details>
</dd>
<dt id="food.layer.nmesh"><code class="name">var <span class="ident">nmesh</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nmesh(self): return self._nmesh</code></pre>
</details>
</dd>
<dt id="food.layer.nmeshmin"><code class="name">var <span class="ident">nmeshmin</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nmeshmin(self): return self._nmeshmin</code></pre>
</details>
</dd>
<dt id="food.layer.permeability"><code class="name">var <span class="ident">permeability</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def permeability(self): return self.D/(self.l*self.k)</code></pre>
</details>
</dd>
<dt id="food.layer.pressure"><code class="name">var <span class="ident">pressure</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pressure(self): return self.k*self.C0</code></pre>
</details>
</dd>
<dt id="food.layer.rank"><code class="name">var <span class="ident">rank</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rank(self): return np.flip(np.argsort(np.array(self.resistance))+1).tolist()</code></pre>
</details>
</dd>
<dt id="food.layer.referencelayer"><code class="name">var <span class="ident">referencelayer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def referencelayer(self): return np.argmax(self.resistance)</code></pre>
</details>
</dd>
<dt id="food.layer.relative_resistance"><code class="name">var <span class="ident">relative_resistance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relative_resistance(self): return self.resistance/sum(self.resistance)</code></pre>
</details>
</dd>
<dt id="food.layer.relative_thickness"><code class="name">var <span class="ident">relative_thickness</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relative_thickness(self): return self.l/self.thickness</code></pre>
</details>
</dd>
<dt id="food.layer.resistance"><code class="name">var <span class="ident">resistance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resistance(self): return self.l*self.k/self.D</code></pre>
</details>
</dd>
<dt id="food.layer.rho"><code class="name">var <span class="ident">rho</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rho(self): return self._rho</code></pre>
</details>
</dd>
<dt id="food.layer.rhounit"><code class="name">var <span class="ident">rhounit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rhounit(self): return self._rhounit</code></pre>
</details>
</dd>
<dt id="food.layer.substance"><code class="name">var <span class="ident">substance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def substance(self): return self._substance</code></pre>
</details>
</dd>
<dt id="food.layer.thickness"><code class="name">var <span class="ident">thickness</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def thickness(self): return sum(self.l)</code></pre>
</details>
</dd>
<dt id="food.layer.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self): return self._type</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="food.layer.acknowledge"><code class="name flex">
<span>def <span class="ident">acknowledge</span></span>(<span>self, what=None, category=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Register inherited properties under a given category.</p>
<h2 id="parameters">Parameters:</h2>
<p>what : str or list of str or a set
The properties or attributes that have been inherited.
category : str
The category under which the properties are grouped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acknowledge(self, what=None, category=None):
    &#34;&#34;&#34;
    Register inherited properties under a given category.

    Parameters:
    -----------
    what : str or list of str or a set
        The properties or attributes that have been inherited.
    category : str
        The category under which the properties are grouped.
    &#34;&#34;&#34;
    if category is None or what is None:
        raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
    if isinstance(what, str):
        what = {what}  # Convert string to a set
    elif isinstance(what, list):
        what = set(what)  # Convert list to a set for uniqueness
    elif not isinstance(what,set):
        raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
    if category not in self._hasbeeninherited:
        self._hasbeeninherited[category] = set()
    self._hasbeeninherited[category].update(what)</code></pre>
</details>
</dd>
<dt id="food.layer.checknumvalue"><code class="name flex">
<span>def <span class="ident">checknumvalue</span></span>(<span>self, value, ExpectedUnits=None)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a validate value to set properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checknumvalue(self,value,ExpectedUnits=None):
    &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
    if isinstance(value,tuple):
        value = check_units(value,ExpectedUnits=ExpectedUnits)
    if isinstance(value,int): value = float(value)
    if isinstance(value,float): value = np.array([value])
    if isinstance(value,list): value = np.array(value)
    if len(value)&gt;self._nlayer:
        value = value[:self._nlayer]
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the extra value(s) has been removed&#39;)
    elif len(value)&lt;self._nlayer:
        value = np.concatenate((value,value[-1:]*np.ones(self._nlayer-len(value))))
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the last value has been repeated&#39;)
    return value</code></pre>
</details>
</dd>
<dt id="food.layer.checktextvalue"><code class="name flex">
<span>def <span class="ident">checktextvalue</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a validate value to set properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checktextvalue(self,value):
    &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
    if not isinstance(value,list): value = [value]
    if len(value)&gt;self._nlayer:
        value = value[:self._nlayer]
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the extra entry(ies) has been removed&#39;)
    elif len(value)&lt;self._nlayer:
        value = value + value[-1:]*(self._nlayer-len(value))
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the last entry has been repeated&#39;)
    return value</code></pre>
</details>
</dd>
<dt id="food.layer.contact"><code class="name flex">
<span>def <span class="ident">contact</span></span>(<span>self, medium, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contact(self,medium,**kwargs):
    return self.migration(medium,**kwargs)</code></pre>
</details>
</dd>
<dt id="food.layer.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a deep copy of the current layer instance.</p>
<p>Returns:
- layer: A new layer instance identical to the original.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self,**kwargs):
    &#34;&#34;&#34;
    Creates a deep copy of the current layer instance.

    Returns:
    - layer: A new layer instance identical to the original.
    &#34;&#34;&#34;
    return duplicate(self).update(**kwargs)</code></pre>
</details>
</dd>
<dt id="food.layer.mesh"><code class="name flex">
<span>def <span class="ident">mesh</span></span>(<span>self, nmesh=None, nmeshmin=None)</span>
</code></dt>
<dd>
<div class="desc"><p>nmesh() generates mesh based on nmesh and nmeshmin, nmesh(nmesh=value,nmeshmin=value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mesh(self,nmesh=None,nmeshmin=None):
    &#34;&#34;&#34; nmesh() generates mesh based on nmesh and nmeshmin, nmesh(nmesh=value,nmeshmin=value) &#34;&#34;&#34;
    if nmesh==None: nmesh = self.nmesh
    if nmeshmin==None: nmeshmin = self.nmeshmin
    if nmeshmin&gt;nmesh: nmeshmin,nmesh = nmesh, nmeshmin
    # X = mesh distribution (number of nodes per layer)
    X = np.ones(self._nlayer)
    for i in range(1,self._nlayer):
       X[i] = X[i-1]*(self.permeability[i-1]*self.l[i])/(self.permeability[i]*self.l[i-1])
    X = np.maximum(nmeshmin,np.ceil(nmesh*X/sum(X)))
    X = np.round((X/sum(X))*nmesh).astype(int)
    # do the mesh
    x0 = 0
    mymesh = []
    for i in range(self._nlayer):
        mymesh.append(mesh(self.l[i]/self.l[self.referencelayer],X[i],x0=x0,index=i))
        x0 += self.l[i]
    return mymesh</code></pre>
</details>
</dd>
<dt id="food.layer.migration"><code class="name flex">
<span>def <span class="ident">migration</span></span>(<span>self, medium, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def migration(self,medium,**kwargs):
    from patankar.migration import senspatankar
    sim = senspatankar(self,medium,**kwargs)
    medium.lastsimulation = sim # store the last simulation result in medium
    medium.lastinput = self # store the last input (self)
    sim.savestate(self,medium) # store store the inputs in sim for chaining
    return sim</code></pre>
</details>
</dd>
<dt id="food.layer.simplify"><code class="name flex">
<span>def <span class="ident">simplify</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>merge continuous layers of the same type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify(self):
    &#34;&#34;&#34; merge continuous layers of the same type &#34;&#34;&#34;
    nlayer = self._nlayer
    if nlayer&gt;1:
       res = self[0]
       ires = 0
       ireshash = res.hashlayer[0]
       for i in range(1,nlayer):
           if self.hashlayer[i]==ireshash:
               res.l[ires] = res.l[ires]+self.l[i]
           else:
               res = res + self[i]
               ires = ires+1
               ireshash = self.hashlayer[i]
    else:
         res = self.copy()
    return res</code></pre>
</details>
</dd>
<dt id="food.layer.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>split layers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self):
    &#34;&#34;&#34; split layers &#34;&#34;&#34;
    out = ()
    if self._nlayer&gt;0:
        for i in range(self._nlayer):
            out = out + (self[i],) # (,) special syntax for tuple singleton
    return out</code></pre>
</details>
</dd>
<dt id="food.layer.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update layer parameters following strict validation rules.</p>
<p>Rules:
1) key should be listed in self._defaults
2) for some keys, synonyms are acceptable as reported in self._synonyms
3) values cannot be None if they were not None in _defaults
4) values should be str if they were initially str, idem with bool
5) values which were numeric (int, float, np.ndarray) should remain numeric.
6) lists are acceptable as numeric arrays
7) all numerical (float, np.ndarray, list) except int must be converted into numpy arrays.
Values which were int in _defaults must remain int and an error should be raised
if a float value is proposed.
8) keys listed in _parametersWithUnits can be assigned with tuples (value, "unit").
They will be converted automatically with check_units(value).
9) for parameters with a default value None, any value is acceptable
10) A clear error message should be displayed for any bad value showing the
current value of the parameter and its default value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update layer parameters following strict validation rules.

    Rules:
    1) key should be listed in self._defaults
    2) for some keys, synonyms are acceptable as reported in self._synonyms
    3) values cannot be None if they were not None in _defaults
    4) values should be str if they were initially str, idem with bool
    5) values which were numeric (int, float, np.ndarray) should remain numeric.
    6) lists are acceptable as numeric arrays
    7) all numerical (float, np.ndarray, list) except int must be converted into numpy arrays.
       Values which were int in _defaults must remain int and an error should be raised
       if a float value is proposed.
    8) keys listed in _parametersWithUnits can be assigned with tuples (value, &#34;unit&#34;).
       They will be converted automatically with check_units(value).
    9) for parameters with a default value None, any value is acceptable
    10) A clear error message should be displayed for any bad value showing the
        current value of the parameter and its default value.
    &#34;&#34;&#34;

    if not kwargs:  # shortcut
        return self # for chaining

    param_counts = {key: 0 for key in self._defaults}  # Track how many times each param is set

    def resolve_key(key):
        &#34;&#34;&#34;Resolve key considering synonyms and check for duplicates.&#34;&#34;&#34;
        for main_key, synonyms in self._synonyms.items():
            if key == main_key or key in synonyms:
                param_counts[main_key] += 1
                return main_key
        param_counts[key] += 1
        return key

    def validate_value(key, value):
        &#34;&#34;&#34;Validate and process the value according to the rules.&#34;&#34;&#34;
        default_value = self._defaults[key]

        # Rule 3: values cannot be None if they were not None in _defaults
        if value is None and default_value is not None:
            raise ValueError(f&#34;Invalid value for &#39;{key}&#39;: None is not allowed. &#34;
                             f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

        # Rule 9: If default is None, any value is acceptable
        if default_value is None:
            return value

        # Rule 4 &amp; 5: Ensure type consistency (str, bool, or numeric types)
        if isinstance(default_value, str) and not isinstance(value, str):
            raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected str, got {type(value).__name__}. &#34;
                            f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
        if isinstance(default_value, bool) and not isinstance(value, bool):
            raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected bool, got {type(value).__name__}. &#34;
                            f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

        # Rule 6 &amp; 7: Convert numeric types properly
        if isinstance(default_value, (int, float, np.ndarray)):
            if isinstance(value, list):
                value = np.array(value)

            if isinstance(default_value, int):
                if isinstance(value, float) or (isinstance(value, np.ndarray) and np.issubdtype(value.dtype, np.floating)):
                    raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got float. &#34;
                                    f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
                if isinstance(value, (int, np.integer)):
                    return int(value)  # Ensure it remains an int
                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            if isinstance(value, (int, float, list, np.ndarray)):
                return np.array(value, dtype=float)  # Convert everything to np.array for floats

            raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected numeric, got {type(value).__name__}. &#34;
                            f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

        # Rule 8: Convert units if applicable
        if key in self._parametersWithUnits and isinstance(value, tuple):
            value, unit = value
            converted_value, _ = check_units((value, unit), ExpectedUnits=self._parametersWithUnits[key])
            return converted_value

        return value

    # Apply updates while tracking parameter occurrences
    for key, value in kwargs.items():
        resolved_key = resolve_key(key)

        if resolved_key not in self._defaults:
            raise KeyError(f&#34;Invalid key &#39;{key}&#39;. Allowed keys: {list(self._defaults.keys())}.&#34;)

        try:
            validated_value = validate_value(resolved_key, value)
            setattr(self, resolved_key, validated_value)
        except (TypeError, ValueError) as e:
            raise ValueError(f&#34;Error updating &#39;{key}&#39;: {e}&#34;)

    # Ensure that no parameter was set multiple times due to synonyms
    duplicate_keys = [k for k, v in param_counts.items() if v &gt; 1]
    if duplicate_keys:
        raise ValueError(f&#34;Duplicate assignment detected for parameters: {duplicate_keys}. &#34;
                         &#34;Use only one synonym per parameter.&#34;)

    return self # to enable chaining</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="food.liquid"><code class="flex name class">
<span>class <span class="ident">liquid</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Liquid food texture</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class liquid(texture):
    &#34;&#34;&#34;Liquid food texture&#34;&#34;&#34;
    name = &#34;liquid food&#34;
    description = &#34;liquid food products&#34;
    [h,hUnits] = check_units((1e-6,&#34;m/s&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.texture" href="#food.texture">texture</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.liquid.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.liquid.h"><code class="name">var <span class="ident">h</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.liquid.hUnits"><code class="name">var <span class="ident">hUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.liquid.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.texture" href="#food.texture">texture</a></b></code>:
<ul class="hlist">
<li><code><a title="food.texture.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.texture.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.texture.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.texture.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.texture.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.texture.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.texture.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.texture.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.texture.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.nofood"><code class="flex name class">
<span>class <span class="ident">nofood</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Impervious boundary condition</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class nofood(foodphysics):
    &#34;&#34;&#34;Impervious boundary condition&#34;&#34;&#34;
    description = &#34;impervious boundary condition&#34;
    name = &#34;undefined&#34;
    level = &#34;root&#34;
    h = 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.nofood.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.nofood.h"><code class="name">var <span class="ident">h</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.nofood.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.nofood.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></b></code>:
<ul class="hlist">
<li><code><a title="food.foodphysics.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodphysics.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodphysics.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodphysics.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodphysics.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodphysics.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodphysics.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodphysics.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodphysics.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.oven"><code class="flex name class">
<span>class <span class="ident">oven</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>real contact conditions</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class oven(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;oven conditions&#34;
    name = &#34;oven&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((1,&#34;hour&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((180,&#34;degC&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.realcontact" href="#food.realcontact">realcontact</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.oven.contacttemperature"><code class="name">var <span class="ident">contacttemperature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.oven.contacttemperatureUnits"><code class="name">var <span class="ident">contacttemperatureUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.oven.contacttime"><code class="name">var <span class="ident">contacttime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.oven.contacttimeUnits"><code class="name">var <span class="ident">contacttimeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.oven.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.oven.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.oven.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.realcontact" href="#food.realcontact">realcontact</a></b></code>:
<ul class="hlist">
<li><code><a title="food.realcontact.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.realcontact.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.realcontact.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.realcontact.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.realcontact.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.realcontact.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.realcontact.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.realcontact.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.realcontact.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.pasteurization"><code class="flex name class">
<span>class <span class="ident">pasteurization</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>real contact conditions</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pasteurization(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;pasteurization conditions&#34;
    name = &#34;pasteurization&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((20,&#34;min&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((100,&#34;degC&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.realcontact" href="#food.realcontact">realcontact</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.pasteurization.contacttemperature"><code class="name">var <span class="ident">contacttemperature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.pasteurization.contacttemperatureUnits"><code class="name">var <span class="ident">contacttemperatureUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.pasteurization.contacttime"><code class="name">var <span class="ident">contacttime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.pasteurization.contacttimeUnits"><code class="name">var <span class="ident">contacttimeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.pasteurization.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.pasteurization.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.pasteurization.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.realcontact" href="#food.realcontact">realcontact</a></b></code>:
<ul class="hlist">
<li><code><a title="food.realcontact.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.realcontact.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.realcontact.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.realcontact.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.realcontact.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.realcontact.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.realcontact.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.realcontact.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.realcontact.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.perfectlymixed"><code class="flex name class">
<span>class <span class="ident">perfectlymixed</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Perfectly mixed liquid (texture)</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class perfectlymixed(texture):
    &#34;&#34;&#34;Perfectly mixed liquid (texture)&#34;&#34;&#34;
    name = &#34;perfectly mixed liquid&#34;
    description = &#34;maximize mixing, minimize the mass transfer boundary layer&#34;
    [h,hUnits] = check_units((1e-4,&#34;m/s&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.texture" href="#food.texture">texture</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.ethanol" href="#food.ethanol">ethanol</a></li>
<li><a title="food.ethanol50" href="#food.ethanol50">ethanol50</a></li>
<li><a title="food.water" href="#food.water">water</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.perfectlymixed.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.perfectlymixed.h"><code class="name">var <span class="ident">h</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.perfectlymixed.hUnits"><code class="name">var <span class="ident">hUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.perfectlymixed.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.texture" href="#food.texture">texture</a></b></code>:
<ul class="hlist">
<li><code><a title="food.texture.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.texture.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.texture.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.texture.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.texture.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.texture.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.texture.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.texture.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.texture.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.realcontact"><code class="flex name class">
<span>class <span class="ident">realcontact</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>real contact conditions</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class realcontact(foodphysics):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;real storage conditions&#34;
    name = &#34;contact conditions&#34;
    level = &#34;root&#34;
    [contacttime,contacttimeUnits] = check_units((200,&#34;days&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((25,&#34;degC&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.ambient" href="#food.ambient">ambient</a></li>
<li><a title="food.boiling" href="#food.boiling">boiling</a></li>
<li><a title="food.chilled" href="#food.chilled">chilled</a></li>
<li><a title="food.frozen" href="#food.frozen">frozen</a></li>
<li><a title="food.hotfilled" href="#food.hotfilled">hotfilled</a></li>
<li><a title="food.oven" href="#food.oven">oven</a></li>
<li><a title="food.pasteurization" href="#food.pasteurization">pasteurization</a></li>
<li><a title="food.sterilization" href="#food.sterilization">sterilization</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.realcontact.contacttemperature"><code class="name">var <span class="ident">contacttemperature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.realcontact.contacttemperatureUnits"><code class="name">var <span class="ident">contacttemperatureUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.realcontact.contacttime"><code class="name">var <span class="ident">contacttime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.realcontact.contacttimeUnits"><code class="name">var <span class="ident">contacttimeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.realcontact.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.realcontact.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.realcontact.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></b></code>:
<ul class="hlist">
<li><code><a title="food.foodphysics.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodphysics.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodphysics.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodphysics.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodphysics.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodphysics.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodphysics.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodphysics.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodphysics.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.realfood"><code class="flex name class">
<span>class <span class="ident">realfood</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Core real food class (second level)</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class realfood(foodproperty):
    &#34;&#34;&#34;Core real food class (second level)&#34;&#34;&#34;
    description = &#34;real food class&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></li>
<li><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.yogurt" href="#food.yogurt">yogurt</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.realfood.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></b></code>:
<ul class="hlist">
<li><code><a title="food.foodproperty.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodproperty.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodproperty.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodproperty.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodproperty.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodproperty.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodproperty.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodproperty.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodproperty.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.rolled"><code class="flex name class">
<span>class <span class="ident">rolled</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>rolled storage</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class rolled(setoff):
    &#34;&#34;&#34;rolled storage&#34;&#34;&#34;
    name = &#34;rolled&#34;
    description = &#34;storage in rolls&#34;
    level = &#34;user&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.setoff" href="#food.setoff">setoff</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.rolled.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.rolled.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.rolled.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.setoff" href="#food.setoff">setoff</a></b></code>:
<ul class="hlist">
<li><code><a title="food.setoff.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.setoff.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.setoff.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.setoff.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.setoff.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.setoff.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.setoff.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.setoff.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.setoff.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.semisolid"><code class="flex name class">
<span>class <span class="ident">semisolid</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Semi-solid food texture</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class semisolid(texture):
    &#34;&#34;&#34;Semi-solid food texture&#34;&#34;&#34;
    name = &#34;solid food&#34;
    description = &#34;solid food products&#34;
    [h,hUnits] = check_units((1e-7,&#34;m/s&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.texture" href="#food.texture">texture</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.yogurt" href="#food.yogurt">yogurt</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.semisolid.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.semisolid.h"><code class="name">var <span class="ident">h</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.semisolid.hUnits"><code class="name">var <span class="ident">hUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.semisolid.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.texture" href="#food.texture">texture</a></b></code>:
<ul class="hlist">
<li><code><a title="food.texture.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.texture.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.texture.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.texture.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.texture.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.texture.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.texture.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.texture.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.texture.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.setoff"><code class="flex name class">
<span>class <span class="ident">setoff</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>periodic boundary conditions</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class setoff(foodphysics):
    &#34;&#34;&#34;periodic boundary conditions&#34;&#34;&#34;
    description = &#34;periodic boundary conditions&#34;
    name = &#34;setoff&#34;
    level = &#34;root&#34;
    h = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.rolled" href="#food.rolled">rolled</a></li>
<li><a title="food.stacked" href="#food.stacked">stacked</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.setoff.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.setoff.h"><code class="name">var <span class="ident">h</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.setoff.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.setoff.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></b></code>:
<ul class="hlist">
<li><code><a title="food.foodphysics.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodphysics.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodphysics.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodphysics.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodphysics.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodphysics.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodphysics.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodphysics.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodphysics.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.simulant"><code class="flex name class">
<span>class <span class="ident">simulant</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Core food simulant class (second level)</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class simulant(foodproperty):
    &#34;&#34;&#34;Core food simulant class (second level)&#34;&#34;&#34;
    name = &#34;generic food simulant&#34;
    description = &#34;food simulant&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></li>
<li><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.ethanol" href="#food.ethanol">ethanol</a></li>
<li><a title="food.ethanol50" href="#food.ethanol50">ethanol50</a></li>
<li><a title="food.tenax" href="#food.tenax">tenax</a></li>
<li><a title="food.water" href="#food.water">water</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.simulant.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.simulant.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></b></code>:
<ul class="hlist">
<li><code><a title="food.foodproperty.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodproperty.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodproperty.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodproperty.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodproperty.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodproperty.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodproperty.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodproperty.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodproperty.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.solid"><code class="flex name class">
<span>class <span class="ident">solid</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Solid food texture</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class solid(foodproperty):
    &#34;&#34;&#34;Solid food texture&#34;&#34;&#34;
    name = &#34;solid food&#34;
    description = &#34;solid food products&#34;
    [h,hUnits] = check_units((1e-8,&#34;m/s&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></li>
<li><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.tenax" href="#food.tenax">tenax</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.solid.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.solid.h"><code class="name">var <span class="ident">h</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.solid.hUnits"><code class="name">var <span class="ident">hUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.solid.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></b></code>:
<ul class="hlist">
<li><code><a title="food.foodproperty.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodproperty.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodproperty.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodproperty.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodproperty.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodproperty.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodproperty.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodproperty.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodproperty.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.stacked"><code class="flex name class">
<span>class <span class="ident">stacked</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>stacked storage</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class stacked(setoff):
    &#34;&#34;&#34;stacked storage&#34;&#34;&#34;
    name = &#34;stacked&#34;
    description = &#34;storage in stacks&#34;
    level = &#34;user&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.setoff" href="#food.setoff">setoff</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.stacked.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.stacked.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.stacked.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.setoff" href="#food.setoff">setoff</a></b></code>:
<ul class="hlist">
<li><code><a title="food.setoff.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.setoff.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.setoff.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.setoff.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.setoff.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.setoff.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.setoff.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.setoff.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.setoff.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.sterilization"><code class="flex name class">
<span>class <span class="ident">sterilization</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>real contact conditions</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sterilization(realcontact):
    &#34;&#34;&#34;real contact conditions&#34;&#34;&#34;
    description = &#34;sterilization conditions&#34;
    name = &#34;sterilization&#34;
    level = &#34;contact&#34;
    [contacttime,contacttimeUnits] = check_units((20,&#34;min&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((121,&#34;degC&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.realcontact" href="#food.realcontact">realcontact</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.sterilization.contacttemperature"><code class="name">var <span class="ident">contacttemperature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.sterilization.contacttemperatureUnits"><code class="name">var <span class="ident">contacttemperatureUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.sterilization.contacttime"><code class="name">var <span class="ident">contacttime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.sterilization.contacttimeUnits"><code class="name">var <span class="ident">contacttimeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.sterilization.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.sterilization.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.sterilization.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.realcontact" href="#food.realcontact">realcontact</a></b></code>:
<ul class="hlist">
<li><code><a title="food.realcontact.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.realcontact.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.realcontact.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.realcontact.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.realcontact.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.realcontact.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.realcontact.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.realcontact.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.realcontact.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.tenax"><code class="flex name class">
<span>class <span class="ident">tenax</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Tenax(r) food simulant</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class tenax(simulant, solid, fat):
    &#34;&#34;&#34;Tenax(r) food simulant&#34;&#34;&#34;
    name = &#34;Tenax&#34;
    description = &#34;simulant of dry food products&#34;
    level = &#34;user&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.simulant" href="#food.simulant">simulant</a></li>
<li><a title="food.solid" href="#food.solid">solid</a></li>
<li><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></li>
<li><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></li>
<li><a title="food.fat" href="#food.fat">fat</a></li>
<li><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.tenax.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.tenax.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.tenax.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.simulant" href="#food.simulant">simulant</a></b></code>:
<ul class="hlist">
<li><code><a title="food.simulant.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.simulant.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.simulant.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.simulant.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.simulant.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.simulant.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.simulant.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.simulant.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.simulant.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.testcontact"><code class="flex name class">
<span>class <span class="ident">testcontact</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>conditions of migration testing</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class testcontact(foodphysics):
    &#34;&#34;&#34;conditions of migration testing&#34;&#34;&#34;
    description = &#34;migration testing conditions&#34;
    name = &#34;migration testing&#34;
    level = &#34;root&#34;
    [contacttime,contacttimeUnits] = check_units((10,&#34;days&#34;))
    [contacttemperature,contacttemperatureUnits] = check_units((40,&#34;degC&#34;))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.testcontact.contacttemperature"><code class="name">var <span class="ident">contacttemperature</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.testcontact.contacttemperatureUnits"><code class="name">var <span class="ident">contacttemperatureUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.testcontact.contacttime"><code class="name">var <span class="ident">contacttime</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.testcontact.contacttimeUnits"><code class="name">var <span class="ident">contacttimeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.testcontact.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.testcontact.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.testcontact.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></b></code>:
<ul class="hlist">
<li><code><a title="food.foodphysics.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodphysics.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodphysics.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodphysics.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodphysics.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodphysics.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodphysics.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodphysics.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodphysics.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.texture"><code class="flex name class">
<span>class <span class="ident">texture</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Parent food texture class</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class texture(foodphysics):
    &#34;&#34;&#34;Parent food texture class&#34;&#34;&#34;
    description = &#34;default class texture&#34;
    name = &#34;undefined&#34;
    level = &#34;root&#34;
    h = 1e-3</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="food.liquid" href="#food.liquid">liquid</a></li>
<li><a title="food.perfectlymixed" href="#food.perfectlymixed">perfectlymixed</a></li>
<li><a title="food.semisolid" href="#food.semisolid">semisolid</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.texture.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.texture.h"><code class="name">var <span class="ident">h</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.texture.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.texture.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></b></code>:
<ul class="hlist">
<li><code><a title="food.foodphysics.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodphysics.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodphysics.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodphysics.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodphysics.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodphysics.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodphysics.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodphysics.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodphysics.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.water"><code class="flex name class">
<span>class <span class="ident">water</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Water food simulant</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class water(simulant, perfectlymixed, aqueous):
    &#34;&#34;&#34;Water food simulant&#34;&#34;&#34;
    name = &#34;water&#34;
    description = &#34;water food simulant&#34;
    level = &#34;user&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.simulant" href="#food.simulant">simulant</a></li>
<li><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></li>
<li><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></li>
<li><a title="food.perfectlymixed" href="#food.perfectlymixed">perfectlymixed</a></li>
<li><a title="food.texture" href="#food.texture">texture</a></li>
<li><a title="food.aqueous" href="#food.aqueous">aqueous</a></li>
<li><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.water.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.water.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.water.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.simulant" href="#food.simulant">simulant</a></b></code>:
<ul class="hlist">
<li><code><a title="food.simulant.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.simulant.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.simulant.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.simulant.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.simulant.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.simulant.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.simulant.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.simulant.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.simulant.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="food.yogurt"><code class="flex name class">
<span>class <span class="ident">yogurt</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Yogurt as an example of real food</p>
<p>general constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class yogurt(realfood, semisolid, ethanol50):
    &#34;&#34;&#34;Yogurt as an example of real food&#34;&#34;&#34;
    description = &#34;yogurt&#34;
    level = &#34;user&#34;
    [k0,k0Units] = check_units((1,NoUnits))
    volume,volumeUnits = check_units((125,&#34;mL&#34;))

    # def __init__(self, name=&#34;no brand&#34;, volume=None, **kwargs):
    #     # Prepare a parameters dict: if a value is provided (e.g. volume), use it;
    #     # otherwise, the default (from class) is used.
    #     params = {}
    #     if volume is not None:
    #         params[&#39;volume&#39;] = volume
    #     params[&#39;name&#39;] = name
    #     params.update(kwargs)
    #     super().__init__(**params)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="food.realfood" href="#food.realfood">realfood</a></li>
<li><a title="food.semisolid" href="#food.semisolid">semisolid</a></li>
<li><a title="food.ethanol50" href="#food.ethanol50">ethanol50</a></li>
<li><a title="food.simulant" href="#food.simulant">simulant</a></li>
<li><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></li>
<li><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></li>
<li><a title="food.perfectlymixed" href="#food.perfectlymixed">perfectlymixed</a></li>
<li><a title="food.texture" href="#food.texture">texture</a></li>
<li><a title="food.intermediate" href="#food.intermediate">intermediate</a></li>
<li><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></li>
<li><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="food.yogurt.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.yogurt.k0"><code class="name">var <span class="ident">k0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.yogurt.k0Units"><code class="name">var <span class="ident">k0Units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.yogurt.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.yogurt.volume"><code class="name">var <span class="ident">volume</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="food.yogurt.volumeUnits"><code class="name">var <span class="ident">volumeUnits</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="food.realfood" href="#food.realfood">realfood</a></b></code>:
<ul class="hlist">
<li><code><a title="food.realfood.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.realfood.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.realfood.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.realfood.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.realfood.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.realfood.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.realfood.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.realfood.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.realfood.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="food.check_units" href="#food.check_units">check_units</a></code></li>
<li><code><a title="food.get_defined_init_params" href="#food.get_defined_init_params">get_defined_init_params</a></code></li>
<li><code><a title="food.help_food" href="#food.help_food">help_food</a></code></li>
<li><code><a title="food.is_valid_classname" href="#food.is_valid_classname">is_valid_classname</a></code></li>
<li><code><a title="food.list_food_classes" href="#food.list_food_classes">list_food_classes</a></code></li>
<li><code><a title="food.wrap_text" href="#food.wrap_text">wrap_text</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="food.ambient" href="#food.ambient">ambient</a></code></h4>
<ul class="">
<li><code><a title="food.ambient.description" href="#food.ambient.description">description</a></code></li>
<li><code><a title="food.ambient.level" href="#food.ambient.level">level</a></code></li>
<li><code><a title="food.ambient.name" href="#food.ambient.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.aqueous" href="#food.aqueous">aqueous</a></code></h4>
<ul class="">
<li><code><a title="food.aqueous.description" href="#food.aqueous.description">description</a></code></li>
<li><code><a title="food.aqueous.k0" href="#food.aqueous.k0">k0</a></code></li>
<li><code><a title="food.aqueous.k0Units" href="#food.aqueous.k0Units">k0Units</a></code></li>
<li><code><a title="food.aqueous.name" href="#food.aqueous.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.boiling" href="#food.boiling">boiling</a></code></h4>
<ul class="">
<li><code><a title="food.boiling.contacttemperature" href="#food.boiling.contacttemperature">contacttemperature</a></code></li>
<li><code><a title="food.boiling.contacttemperatureUnits" href="#food.boiling.contacttemperatureUnits">contacttemperatureUnits</a></code></li>
<li><code><a title="food.boiling.contacttime" href="#food.boiling.contacttime">contacttime</a></code></li>
<li><code><a title="food.boiling.contacttimeUnits" href="#food.boiling.contacttimeUnits">contacttimeUnits</a></code></li>
<li><code><a title="food.boiling.description" href="#food.boiling.description">description</a></code></li>
<li><code><a title="food.boiling.level" href="#food.boiling.level">level</a></code></li>
<li><code><a title="food.boiling.name" href="#food.boiling.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.chemicalaffinity" href="#food.chemicalaffinity">chemicalaffinity</a></code></h4>
<ul class="">
<li><code><a title="food.chemicalaffinity.description" href="#food.chemicalaffinity.description">description</a></code></li>
<li><code><a title="food.chemicalaffinity.k0" href="#food.chemicalaffinity.k0">k0</a></code></li>
<li><code><a title="food.chemicalaffinity.level" href="#food.chemicalaffinity.level">level</a></code></li>
<li><code><a title="food.chemicalaffinity.name" href="#food.chemicalaffinity.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.chilled" href="#food.chilled">chilled</a></code></h4>
<ul class="">
<li><code><a title="food.chilled.contacttemperature" href="#food.chilled.contacttemperature">contacttemperature</a></code></li>
<li><code><a title="food.chilled.contacttemperatureUnits" href="#food.chilled.contacttemperatureUnits">contacttemperatureUnits</a></code></li>
<li><code><a title="food.chilled.contacttime" href="#food.chilled.contacttime">contacttime</a></code></li>
<li><code><a title="food.chilled.contacttimeUnits" href="#food.chilled.contacttimeUnits">contacttimeUnits</a></code></li>
<li><code><a title="food.chilled.description" href="#food.chilled.description">description</a></code></li>
<li><code><a title="food.chilled.level" href="#food.chilled.level">level</a></code></li>
<li><code><a title="food.chilled.name" href="#food.chilled.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.ethanol" href="#food.ethanol">ethanol</a></code></h4>
<ul class="">
<li><code><a title="food.ethanol.description" href="#food.ethanol.description">description</a></code></li>
<li><code><a title="food.ethanol.level" href="#food.ethanol.level">level</a></code></li>
<li><code><a title="food.ethanol.name" href="#food.ethanol.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.ethanol50" href="#food.ethanol50">ethanol50</a></code></h4>
<ul class="">
<li><code><a title="food.ethanol50.description" href="#food.ethanol50.description">description</a></code></li>
<li><code><a title="food.ethanol50.level" href="#food.ethanol50.level">level</a></code></li>
<li><code><a title="food.ethanol50.name" href="#food.ethanol50.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.fat" href="#food.fat">fat</a></code></h4>
<ul class="">
<li><code><a title="food.fat.description" href="#food.fat.description">description</a></code></li>
<li><code><a title="food.fat.k0" href="#food.fat.k0">k0</a></code></li>
<li><code><a title="food.fat.k0Units" href="#food.fat.k0Units">k0Units</a></code></li>
<li><code><a title="food.fat.name" href="#food.fat.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.foodlayer" href="#food.foodlayer">foodlayer</a></code></h4>
<ul class="">
<li><code><a title="food.foodlayer.CF0" href="#food.foodlayer.CF0">CF0</a></code></li>
<li><code><a title="food.foodlayer.CF0units" href="#food.foodlayer.CF0units">CF0units</a></code></li>
<li><code><a title="food.foodlayer.contactemperature" href="#food.foodlayer.contactemperature">contactemperature</a></code></li>
<li><code><a title="food.foodlayer.contactemperatureUnits" href="#food.foodlayer.contactemperatureUnits">contactemperatureUnits</a></code></li>
<li><code><a title="food.foodlayer.contacttime" href="#food.foodlayer.contacttime">contacttime</a></code></li>
<li><code><a title="food.foodlayer.contacttime_units" href="#food.foodlayer.contacttime_units">contacttime_units</a></code></li>
<li><code><a title="food.foodlayer.density" href="#food.foodlayer.density">density</a></code></li>
<li><code><a title="food.foodlayer.densityUnits" href="#food.foodlayer.densityUnits">densityUnits</a></code></li>
<li><code><a title="food.foodlayer.description" href="#food.foodlayer.description">description</a></code></li>
<li><code><a title="food.foodlayer.level" href="#food.foodlayer.level">level</a></code></li>
<li><code><a title="food.foodlayer.name" href="#food.foodlayer.name">name</a></code></li>
<li><code><a title="food.foodlayer.surfacearea" href="#food.foodlayer.surfacearea">surfacearea</a></code></li>
<li><code><a title="food.foodlayer.surfaceareaUnits" href="#food.foodlayer.surfaceareaUnits">surfaceareaUnits</a></code></li>
<li><code><a title="food.foodlayer.volume" href="#food.foodlayer.volume">volume</a></code></li>
<li><code><a title="food.foodlayer.volumeUnits" href="#food.foodlayer.volumeUnits">volumeUnits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.foodphysics" href="#food.foodphysics">foodphysics</a></code></h4>
<ul class="two-column">
<li><code><a title="food.foodphysics.PBC" href="#food.foodphysics.PBC">PBC</a></code></li>
<li><code><a title="food.foodphysics.acknowledge" href="#food.foodphysics.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.foodphysics.contact" href="#food.foodphysics.contact">contact</a></code></li>
<li><code><a title="food.foodphysics.copy" href="#food.foodphysics.copy">copy</a></code></li>
<li><code><a title="food.foodphysics.description" href="#food.foodphysics.description">description</a></code></li>
<li><code><a title="food.foodphysics.get_param" href="#food.foodphysics.get_param">get_param</a></code></li>
<li><code><a title="food.foodphysics.hassimulation" href="#food.foodphysics.hassimulation">hassimulation</a></code></li>
<li><code><a title="food.foodphysics.lastinput" href="#food.foodphysics.lastinput">lastinput</a></code></li>
<li><code><a title="food.foodphysics.lastsimulation" href="#food.foodphysics.lastsimulation">lastsimulation</a></code></li>
<li><code><a title="food.foodphysics.level" href="#food.foodphysics.level">level</a></code></li>
<li><code><a title="food.foodphysics.migration" href="#food.foodphysics.migration">migration</a></code></li>
<li><code><a title="food.foodphysics.name" href="#food.foodphysics.name">name</a></code></li>
<li><code><a title="food.foodphysics.refresh" href="#food.foodphysics.refresh">refresh</a></code></li>
<li><code><a title="food.foodphysics.update" href="#food.foodphysics.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.foodproperty" href="#food.foodproperty">foodproperty</a></code></h4>
<ul class="">
<li><code><a title="food.foodproperty.level" href="#food.foodproperty.level">level</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.frozen" href="#food.frozen">frozen</a></code></h4>
<ul class="">
<li><code><a title="food.frozen.contacttemperature" href="#food.frozen.contacttemperature">contacttemperature</a></code></li>
<li><code><a title="food.frozen.contacttemperatureUnits" href="#food.frozen.contacttemperatureUnits">contacttemperatureUnits</a></code></li>
<li><code><a title="food.frozen.contacttime" href="#food.frozen.contacttime">contacttime</a></code></li>
<li><code><a title="food.frozen.contacttimeUnits" href="#food.frozen.contacttimeUnits">contacttimeUnits</a></code></li>
<li><code><a title="food.frozen.description" href="#food.frozen.description">description</a></code></li>
<li><code><a title="food.frozen.level" href="#food.frozen.level">level</a></code></li>
<li><code><a title="food.frozen.name" href="#food.frozen.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.hotfilled" href="#food.hotfilled">hotfilled</a></code></h4>
<ul class="">
<li><code><a title="food.hotfilled.contacttemperature" href="#food.hotfilled.contacttemperature">contacttemperature</a></code></li>
<li><code><a title="food.hotfilled.contacttemperatureUnits" href="#food.hotfilled.contacttemperatureUnits">contacttemperatureUnits</a></code></li>
<li><code><a title="food.hotfilled.contacttime" href="#food.hotfilled.contacttime">contacttime</a></code></li>
<li><code><a title="food.hotfilled.contacttimeUnits" href="#food.hotfilled.contacttimeUnits">contacttimeUnits</a></code></li>
<li><code><a title="food.hotfilled.description" href="#food.hotfilled.description">description</a></code></li>
<li><code><a title="food.hotfilled.level" href="#food.hotfilled.level">level</a></code></li>
<li><code><a title="food.hotfilled.name" href="#food.hotfilled.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.intermediate" href="#food.intermediate">intermediate</a></code></h4>
<ul class="">
<li><code><a title="food.intermediate.description" href="#food.intermediate.description">description</a></code></li>
<li><code><a title="food.intermediate.k0" href="#food.intermediate.k0">k0</a></code></li>
<li><code><a title="food.intermediate.k0Units" href="#food.intermediate.k0Units">k0Units</a></code></li>
<li><code><a title="food.intermediate.name" href="#food.intermediate.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.layer" href="#food.layer">layer</a></code></h4>
<ul class="two-column">
<li><code><a title="food.layer.C0" href="#food.layer.C0">C0</a></code></li>
<li><code><a title="food.layer.Cunit" href="#food.layer.Cunit">Cunit</a></code></li>
<li><code><a title="food.layer.D" href="#food.layer.D">D</a></code></li>
<li><code><a title="food.layer.Dmodel" href="#food.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="food.layer.Dunit" href="#food.layer.Dunit">Dunit</a></code></li>
<li><code><a title="food.layer.Foscale" href="#food.layer.Foscale">Foscale</a></code></li>
<li><code><a title="food.layer.T" href="#food.layer.T">T</a></code></li>
<li><code><a title="food.layer.TK" href="#food.layer.TK">TK</a></code></li>
<li><code><a title="food.layer.TKunit" href="#food.layer.TKunit">TKunit</a></code></li>
<li><code><a title="food.layer.Tunit" href="#food.layer.Tunit">Tunit</a></code></li>
<li><code><a title="food.layer.acknowledge" href="#food.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="food.layer.checknumvalue" href="#food.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="food.layer.checktextvalue" href="#food.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="food.layer.code" href="#food.layer.code">code</a></code></li>
<li><code><a title="food.layer.concentration" href="#food.layer.concentration">concentration</a></code></li>
<li><code><a title="food.layer.contact" href="#food.layer.contact">contact</a></code></li>
<li><code><a title="food.layer.copy" href="#food.layer.copy">copy</a></code></li>
<li><code><a title="food.layer.hashlayer" href="#food.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="food.layer.help" href="#food.layer.help">help</a></code></li>
<li><code><a title="food.layer.k" href="#food.layer.k">k</a></code></li>
<li><code><a title="food.layer.kmodel" href="#food.layer.kmodel">kmodel</a></code></li>
<li><code><a title="food.layer.kunit" href="#food.layer.kunit">kunit</a></code></li>
<li><code><a title="food.layer.l" href="#food.layer.l">l</a></code></li>
<li><code><a title="food.layer.lag" href="#food.layer.lag">lag</a></code></li>
<li><code><a title="food.layer.layerclass" href="#food.layer.layerclass">layerclass</a></code></li>
<li><code><a title="food.layer.layerclass_history" href="#food.layer.layerclass_history">layerclass_history</a></code></li>
<li><code><a title="food.layer.lreferencelayer" href="#food.layer.lreferencelayer">lreferencelayer</a></code></li>
<li><code><a title="food.layer.lunit" href="#food.layer.lunit">lunit</a></code></li>
<li><code><a title="food.layer.material" href="#food.layer.material">material</a></code></li>
<li><code><a title="food.layer.mesh" href="#food.layer.mesh">mesh</a></code></li>
<li><code><a title="food.layer.migration" href="#food.layer.migration">migration</a></code></li>
<li><code><a title="food.layer.n" href="#food.layer.n">n</a></code></li>
<li><code><a title="food.layer.name" href="#food.layer.name">name</a></code></li>
<li><code><a title="food.layer.nmesh" href="#food.layer.nmesh">nmesh</a></code></li>
<li><code><a title="food.layer.nmeshmin" href="#food.layer.nmeshmin">nmeshmin</a></code></li>
<li><code><a title="food.layer.permeability" href="#food.layer.permeability">permeability</a></code></li>
<li><code><a title="food.layer.pressure" href="#food.layer.pressure">pressure</a></code></li>
<li><code><a title="food.layer.rank" href="#food.layer.rank">rank</a></code></li>
<li><code><a title="food.layer.referencelayer" href="#food.layer.referencelayer">referencelayer</a></code></li>
<li><code><a title="food.layer.relative_resistance" href="#food.layer.relative_resistance">relative_resistance</a></code></li>
<li><code><a title="food.layer.relative_thickness" href="#food.layer.relative_thickness">relative_thickness</a></code></li>
<li><code><a title="food.layer.resistance" href="#food.layer.resistance">resistance</a></code></li>
<li><code><a title="food.layer.resolvename" href="#food.layer.resolvename">resolvename</a></code></li>
<li><code><a title="food.layer.rho" href="#food.layer.rho">rho</a></code></li>
<li><code><a title="food.layer.rhounit" href="#food.layer.rhounit">rhounit</a></code></li>
<li><code><a title="food.layer.simplify" href="#food.layer.simplify">simplify</a></code></li>
<li><code><a title="food.layer.split" href="#food.layer.split">split</a></code></li>
<li><code><a title="food.layer.substance" href="#food.layer.substance">substance</a></code></li>
<li><code><a title="food.layer.thickness" href="#food.layer.thickness">thickness</a></code></li>
<li><code><a title="food.layer.type" href="#food.layer.type">type</a></code></li>
<li><code><a title="food.layer.update" href="#food.layer.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.liquid" href="#food.liquid">liquid</a></code></h4>
<ul class="">
<li><code><a title="food.liquid.description" href="#food.liquid.description">description</a></code></li>
<li><code><a title="food.liquid.h" href="#food.liquid.h">h</a></code></li>
<li><code><a title="food.liquid.hUnits" href="#food.liquid.hUnits">hUnits</a></code></li>
<li><code><a title="food.liquid.name" href="#food.liquid.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.nofood" href="#food.nofood">nofood</a></code></h4>
<ul class="">
<li><code><a title="food.nofood.description" href="#food.nofood.description">description</a></code></li>
<li><code><a title="food.nofood.h" href="#food.nofood.h">h</a></code></li>
<li><code><a title="food.nofood.level" href="#food.nofood.level">level</a></code></li>
<li><code><a title="food.nofood.name" href="#food.nofood.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.oven" href="#food.oven">oven</a></code></h4>
<ul class="">
<li><code><a title="food.oven.contacttemperature" href="#food.oven.contacttemperature">contacttemperature</a></code></li>
<li><code><a title="food.oven.contacttemperatureUnits" href="#food.oven.contacttemperatureUnits">contacttemperatureUnits</a></code></li>
<li><code><a title="food.oven.contacttime" href="#food.oven.contacttime">contacttime</a></code></li>
<li><code><a title="food.oven.contacttimeUnits" href="#food.oven.contacttimeUnits">contacttimeUnits</a></code></li>
<li><code><a title="food.oven.description" href="#food.oven.description">description</a></code></li>
<li><code><a title="food.oven.level" href="#food.oven.level">level</a></code></li>
<li><code><a title="food.oven.name" href="#food.oven.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.pasteurization" href="#food.pasteurization">pasteurization</a></code></h4>
<ul class="">
<li><code><a title="food.pasteurization.contacttemperature" href="#food.pasteurization.contacttemperature">contacttemperature</a></code></li>
<li><code><a title="food.pasteurization.contacttemperatureUnits" href="#food.pasteurization.contacttemperatureUnits">contacttemperatureUnits</a></code></li>
<li><code><a title="food.pasteurization.contacttime" href="#food.pasteurization.contacttime">contacttime</a></code></li>
<li><code><a title="food.pasteurization.contacttimeUnits" href="#food.pasteurization.contacttimeUnits">contacttimeUnits</a></code></li>
<li><code><a title="food.pasteurization.description" href="#food.pasteurization.description">description</a></code></li>
<li><code><a title="food.pasteurization.level" href="#food.pasteurization.level">level</a></code></li>
<li><code><a title="food.pasteurization.name" href="#food.pasteurization.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.perfectlymixed" href="#food.perfectlymixed">perfectlymixed</a></code></h4>
<ul class="">
<li><code><a title="food.perfectlymixed.description" href="#food.perfectlymixed.description">description</a></code></li>
<li><code><a title="food.perfectlymixed.h" href="#food.perfectlymixed.h">h</a></code></li>
<li><code><a title="food.perfectlymixed.hUnits" href="#food.perfectlymixed.hUnits">hUnits</a></code></li>
<li><code><a title="food.perfectlymixed.name" href="#food.perfectlymixed.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.realcontact" href="#food.realcontact">realcontact</a></code></h4>
<ul class="">
<li><code><a title="food.realcontact.contacttemperature" href="#food.realcontact.contacttemperature">contacttemperature</a></code></li>
<li><code><a title="food.realcontact.contacttemperatureUnits" href="#food.realcontact.contacttemperatureUnits">contacttemperatureUnits</a></code></li>
<li><code><a title="food.realcontact.contacttime" href="#food.realcontact.contacttime">contacttime</a></code></li>
<li><code><a title="food.realcontact.contacttimeUnits" href="#food.realcontact.contacttimeUnits">contacttimeUnits</a></code></li>
<li><code><a title="food.realcontact.description" href="#food.realcontact.description">description</a></code></li>
<li><code><a title="food.realcontact.level" href="#food.realcontact.level">level</a></code></li>
<li><code><a title="food.realcontact.name" href="#food.realcontact.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.realfood" href="#food.realfood">realfood</a></code></h4>
<ul class="">
<li><code><a title="food.realfood.description" href="#food.realfood.description">description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.rolled" href="#food.rolled">rolled</a></code></h4>
<ul class="">
<li><code><a title="food.rolled.description" href="#food.rolled.description">description</a></code></li>
<li><code><a title="food.rolled.level" href="#food.rolled.level">level</a></code></li>
<li><code><a title="food.rolled.name" href="#food.rolled.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.semisolid" href="#food.semisolid">semisolid</a></code></h4>
<ul class="">
<li><code><a title="food.semisolid.description" href="#food.semisolid.description">description</a></code></li>
<li><code><a title="food.semisolid.h" href="#food.semisolid.h">h</a></code></li>
<li><code><a title="food.semisolid.hUnits" href="#food.semisolid.hUnits">hUnits</a></code></li>
<li><code><a title="food.semisolid.name" href="#food.semisolid.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.setoff" href="#food.setoff">setoff</a></code></h4>
<ul class="">
<li><code><a title="food.setoff.description" href="#food.setoff.description">description</a></code></li>
<li><code><a title="food.setoff.h" href="#food.setoff.h">h</a></code></li>
<li><code><a title="food.setoff.level" href="#food.setoff.level">level</a></code></li>
<li><code><a title="food.setoff.name" href="#food.setoff.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.simulant" href="#food.simulant">simulant</a></code></h4>
<ul class="">
<li><code><a title="food.simulant.description" href="#food.simulant.description">description</a></code></li>
<li><code><a title="food.simulant.name" href="#food.simulant.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.solid" href="#food.solid">solid</a></code></h4>
<ul class="">
<li><code><a title="food.solid.description" href="#food.solid.description">description</a></code></li>
<li><code><a title="food.solid.h" href="#food.solid.h">h</a></code></li>
<li><code><a title="food.solid.hUnits" href="#food.solid.hUnits">hUnits</a></code></li>
<li><code><a title="food.solid.name" href="#food.solid.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.stacked" href="#food.stacked">stacked</a></code></h4>
<ul class="">
<li><code><a title="food.stacked.description" href="#food.stacked.description">description</a></code></li>
<li><code><a title="food.stacked.level" href="#food.stacked.level">level</a></code></li>
<li><code><a title="food.stacked.name" href="#food.stacked.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.sterilization" href="#food.sterilization">sterilization</a></code></h4>
<ul class="">
<li><code><a title="food.sterilization.contacttemperature" href="#food.sterilization.contacttemperature">contacttemperature</a></code></li>
<li><code><a title="food.sterilization.contacttemperatureUnits" href="#food.sterilization.contacttemperatureUnits">contacttemperatureUnits</a></code></li>
<li><code><a title="food.sterilization.contacttime" href="#food.sterilization.contacttime">contacttime</a></code></li>
<li><code><a title="food.sterilization.contacttimeUnits" href="#food.sterilization.contacttimeUnits">contacttimeUnits</a></code></li>
<li><code><a title="food.sterilization.description" href="#food.sterilization.description">description</a></code></li>
<li><code><a title="food.sterilization.level" href="#food.sterilization.level">level</a></code></li>
<li><code><a title="food.sterilization.name" href="#food.sterilization.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.tenax" href="#food.tenax">tenax</a></code></h4>
<ul class="">
<li><code><a title="food.tenax.description" href="#food.tenax.description">description</a></code></li>
<li><code><a title="food.tenax.level" href="#food.tenax.level">level</a></code></li>
<li><code><a title="food.tenax.name" href="#food.tenax.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.testcontact" href="#food.testcontact">testcontact</a></code></h4>
<ul class="">
<li><code><a title="food.testcontact.contacttemperature" href="#food.testcontact.contacttemperature">contacttemperature</a></code></li>
<li><code><a title="food.testcontact.contacttemperatureUnits" href="#food.testcontact.contacttemperatureUnits">contacttemperatureUnits</a></code></li>
<li><code><a title="food.testcontact.contacttime" href="#food.testcontact.contacttime">contacttime</a></code></li>
<li><code><a title="food.testcontact.contacttimeUnits" href="#food.testcontact.contacttimeUnits">contacttimeUnits</a></code></li>
<li><code><a title="food.testcontact.description" href="#food.testcontact.description">description</a></code></li>
<li><code><a title="food.testcontact.level" href="#food.testcontact.level">level</a></code></li>
<li><code><a title="food.testcontact.name" href="#food.testcontact.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.texture" href="#food.texture">texture</a></code></h4>
<ul class="">
<li><code><a title="food.texture.description" href="#food.texture.description">description</a></code></li>
<li><code><a title="food.texture.h" href="#food.texture.h">h</a></code></li>
<li><code><a title="food.texture.level" href="#food.texture.level">level</a></code></li>
<li><code><a title="food.texture.name" href="#food.texture.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.water" href="#food.water">water</a></code></h4>
<ul class="">
<li><code><a title="food.water.description" href="#food.water.description">description</a></code></li>
<li><code><a title="food.water.level" href="#food.water.level">level</a></code></li>
<li><code><a title="food.water.name" href="#food.water.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="food.yogurt" href="#food.yogurt">yogurt</a></code></h4>
<ul class="two-column">
<li><code><a title="food.yogurt.description" href="#food.yogurt.description">description</a></code></li>
<li><code><a title="food.yogurt.k0" href="#food.yogurt.k0">k0</a></code></li>
<li><code><a title="food.yogurt.k0Units" href="#food.yogurt.k0Units">k0Units</a></code></li>
<li><code><a title="food.yogurt.level" href="#food.yogurt.level">level</a></code></li>
<li><code><a title="food.yogurt.volume" href="#food.yogurt.volume">volume</a></code></li>
<li><code><a title="food.yogurt.volumeUnits" href="#food.yogurt.volumeUnits">volumeUnits</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>