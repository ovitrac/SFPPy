<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>layer API documentation</title>
<meta name="description" content="SFPPy Module: Layer (Packaging Materials)
Defines **packaging materials** as 1D layers. Supports:
- **Multilayer assembly (`layer1 + layer2`)**
- …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>layer</code></h1>
</header>
<section id="section-intro">
<p>===============================================================================
SFPPy Module: Layer (Packaging Materials)
===============================================================================
Defines <strong>packaging materials</strong> as 1D layers. Supports:
- <strong>Multilayer assembly (<code>layer1 + layer2</code>)</strong>
- <strong>Mass transfer modeling (<code>layer &gt;&gt; food</code>)</strong>
- <strong>Automatic meshing for finite-volume solvers</strong></p>
<p><strong>Main Components:</strong>
- <strong>Base Class: <code><a title="layer.layer" href="#layer.layer">layer</a></code></strong> (Defines all packaging materials)
- Properties: <code>D</code> (diffusivity), <code>k</code> (partition coefficient), <code>l</code> (thickness)
- Supports <strong>+ (stacking)</strong> and <strong>splitting</strong> layers
- Propagates contact temperature from <code>food.py</code>
- <strong>Predefined Materials (Subclasses)</strong>:
- <code><a title="layer.LDPE" href="#layer.LDPE">LDPE</a></code>, <code><a title="layer.PP" href="#layer.PP">PP</a></code>, <code>PET</code>, <code><a title="layer.Cardboard" href="#layer.Cardboard">Cardboard</a></code>, <code>Ink</code>
- <strong>Dynamic Property Models:</strong>
- <code>Dmodel()</code>, <code>kmodel()</code>: Call <code>property.py</code> to predict diffusion and partitioning</p>
<p><strong>Integration with SFPPy Modules:</strong>
- Used in <code>migration.py</code> to define the <strong>left-side boundary</strong>.
- Retrieves chemical properties from <code>loadpubchem.py</code>.
- Works with <code>food.py</code> to model <strong>food-contact</strong> interactions.</p>
<p>Example:</p>
<pre><code class="language-python">from patankar.layer import LDPE
A = LDPE(l=50e-6, D=1e-14)
</code></pre>
<p>===============================================================================
Details
===============================================================================
Layer builder for patankar package</p>
<p>All materials are represented as layers and be combined, merged with mathematical
operations such as +. The general object general object is of class layer.</p>
<p>Specific materials with known properties have been derived: LDPE(),HDPE(),PP()&hellip;air()</p>
<p>List of implemnted materials:</p>
<pre><code>| Class Name              | Type     | Material                        | Code    |
|-------------------------|----------|---------------------------------|---------|
| AdhesiveAcrylate        | adhesive | acrylate adhesive               | Acryl   |
| AdhesiveEVA             | adhesive | EVA adhesive                    | EVA     |
| AdhesiveNaturalRubber   | adhesive | natural rubber adhesive         | rubber  |
| AdhesivePU              | adhesive | polyurethane adhesive           | PU      |
| AdhesivePVAC            | adhesive | PVAc adhesive                   | PVAc    |
| AdhesiveSyntheticRubber | adhesive | synthetic rubber adhesive       | sRubber |
| AdhesiveVAE             | adhesive | VAE adhesive                    | VAE     |
| Cardboard               | paper    | cardboard                       | board   |
| HDPE                    | polymer  | high-density polyethylene       | HDPE    |
| HIPS                    | polymer  | high-impact polystyrene         | HIPS    |
| LDPE                    | polymer  | low-density polyethylene        | LDPE    |
| LLDPE                   | polymer  | linear low-density polyethylene | LLDPE   |
| PA6                     | polymer  | polyamide 6                     | PA6     |
| PA66                    | polymer  | polyamide 6,6                   | PA6,6   |
| SBS                     | polymer  | styrene-based polymer SBS       | SBS     |
| PBT                     | polymer  | polybutylene terephthalate      | PBT     |
| PEN                     | polymer  | polyethylene naphthalate        | PEN     |
| PP                      | polymer  | isotactic polypropylene         | PP      |
| PPrubber                | polymer  | atactic polypropylene           | aPP     |
| PS                      | polymer  | polystyrene                     | PS      |
| Paper                   | paper    | paper                           | paper   |
| air                     | air      | ideal gas                       | gas     |
| gPET                    | polymer  | glassy PET                      | PET     |
| oPP                     | polymer  | bioriented polypropylene        | oPP     |
| plasticizedPVC          | polymer  | plasticized PVC                 | pPVC    |
| rPET                    | polymer  | rubbery PET                     | rPET    |
| rigidPVC                | polymer  | rigid PVC                       | PVC     |
</code></pre>
<p>Mass transfer within each layer are governed by a diffusion coefficient, a Henri-like coefficient
enabling to describe the partitioning between layers. All materials are automatically meshed using
a modified finite volume technique exact at steady state and offering good accuracy in non-steady
conditions.</p>
<p>A temperature and substance can be assigned to layers.</p>
<p>@version: 1.2
@project: SFPPy - SafeFoodPackaging Portal in Python initiative
@author: INRAE\olivier.vitrac@agroparistech.fr
@licence: MIT
@Date: 2022-02-21
@rev. 2025-02-14</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
===============================================================================
SFPPy Module: Layer (Packaging Materials)
===============================================================================
Defines **packaging materials** as 1D layers. Supports:
- **Multilayer assembly (`layer1 + layer2`)**
- **Mass transfer modeling (`layer &gt;&gt; food`)**
- **Automatic meshing for finite-volume solvers**

**Main Components:**
- **Base Class: `layer`** (Defines all packaging materials)
    - Properties: `D` (diffusivity), `k` (partition coefficient), `l` (thickness)
    - Supports **+ (stacking)** and **splitting** layers
    - Propagates contact temperature from `food.py`
- **Predefined Materials (Subclasses)**:
    - `LDPE`, `PP`, `PET`, `Cardboard`, `Ink`
- **Dynamic Property Models:**
    - `Dmodel()`, `kmodel()`: Call `property.py` to predict diffusion and partitioning

**Integration with SFPPy Modules:**
- Used in `migration.py` to define the **left-side boundary**.
- Retrieves chemical properties from `loadpubchem.py`.
- Works with `food.py` to model **food-contact** interactions.

Example:
```python
from patankar.layer import LDPE
A = LDPE(l=50e-6, D=1e-14)
```


===============================================================================
Details
===============================================================================
Layer builder for patankar package

All materials are represented as layers and be combined, merged with mathematical
operations such as +. The general object general object is of class layer.

Specific materials with known properties have been derived: LDPE(),HDPE(),PP()...air()

List of implemnted materials:

    | Class Name              | Type     | Material                        | Code    |
    |-------------------------|----------|---------------------------------|---------|
    | AdhesiveAcrylate        | adhesive | acrylate adhesive               | Acryl   |
    | AdhesiveEVA             | adhesive | EVA adhesive                    | EVA     |
    | AdhesiveNaturalRubber   | adhesive | natural rubber adhesive         | rubber  |
    | AdhesivePU              | adhesive | polyurethane adhesive           | PU      |
    | AdhesivePVAC            | adhesive | PVAc adhesive                   | PVAc    |
    | AdhesiveSyntheticRubber | adhesive | synthetic rubber adhesive       | sRubber |
    | AdhesiveVAE             | adhesive | VAE adhesive                    | VAE     |
    | Cardboard               | paper    | cardboard                       | board   |
    | HDPE                    | polymer  | high-density polyethylene       | HDPE    |
    | HIPS                    | polymer  | high-impact polystyrene         | HIPS    |
    | LDPE                    | polymer  | low-density polyethylene        | LDPE    |
    | LLDPE                   | polymer  | linear low-density polyethylene | LLDPE   |
    | PA6                     | polymer  | polyamide 6                     | PA6     |
    | PA66                    | polymer  | polyamide 6,6                   | PA6,6   |
    | SBS                     | polymer  | styrene-based polymer SBS       | SBS     |
    | PBT                     | polymer  | polybutylene terephthalate      | PBT     |
    | PEN                     | polymer  | polyethylene naphthalate        | PEN     |
    | PP                      | polymer  | isotactic polypropylene         | PP      |
    | PPrubber                | polymer  | atactic polypropylene           | aPP     |
    | PS                      | polymer  | polystyrene                     | PS      |
    | Paper                   | paper    | paper                           | paper   |
    | air                     | air      | ideal gas                       | gas     |
    | gPET                    | polymer  | glassy PET                      | PET     |
    | oPP                     | polymer  | bioriented polypropylene        | oPP     |
    | plasticizedPVC          | polymer  | plasticized PVC                 | pPVC    |
    | rPET                    | polymer  | rubbery PET                     | rPET    |
    | rigidPVC                | polymer  | rigid PVC                       | PVC     |


Mass transfer within each layer are governed by a diffusion coefficient, a Henri-like coefficient
enabling to describe the partitioning between layers. All materials are automatically meshed using
a modified finite volume technique exact at steady state and offering good accuracy in non-steady
conditions.

A temperature and substance can be assigned to layers.


@version: 1.2
@project: SFPPy - SafeFoodPackaging Portal in Python initiative
@author: INRAE\\olivier.vitrac@agroparistech.fr
@licence: MIT
@Date: 2022-02-21
@rev. 2025-02-14

&#34;&#34;&#34;

# ---- History ----
# Created on Tue Jan 18 09:14:34 2022
# 2022-01-19 RC
# 2022-01-20 full indexing and simplification
# 2022-01-21 add split()
# 2022-01-22 add child classes for common polymers
# 2022-01-23 full implementation of units
# 2022-01-26 mesh() method generating mesh objects
# 2022-02-21 add compatibility with migration


oneline = &#34;Build multilayer objects&#34;

docstr = &#34;&#34;&#34;
Build layer(s) for SENSPATANKAR

Example of caller:
    from patankar.layer import layer
    A=layer(D=1e-14,l=50e-6)
    A

&#34;&#34;&#34;


# Package Dependencies
# ====================
# &lt;--  generic packages  --&gt;
import sys
import inspect
import textwrap
import numpy as np
from copy import deepcopy as duplicate
# &lt;--  local packages  --&gt;
if &#39;SIbase&#39; not in dir(): # avoid loading it twice
    from patankar.private.pint import UnitRegistry as SIbase
    from patankar.private.pint import set_application_registry as fixSIbase
if &#39;migrant&#39; not in dir():
    from patankar.loadpubchem import migrant


__all__ = [&#39;AdhesiveAcrylate&#39;, &#39;AdhesiveEVA&#39;, &#39;AdhesiveNaturalRubber&#39;, &#39;AdhesivePU&#39;, &#39;AdhesivePVAC&#39;, &#39;AdhesiveSyntheticRubber&#39;, &#39;AdhesiveVAE&#39;, &#39;Cardboard&#39;, &#39;HDPE&#39;, &#39;HIPS&#39;, &#39;LDPE&#39;, &#39;LLDPE&#39;, &#39;PA6&#39;, &#39;PA66&#39;, &#39;PBT&#39;, &#39;PEN&#39;, &#39;PP&#39;, &#39;PPrubber&#39;, &#39;PS&#39;, &#39;Paper&#39;, &#39;R&#39;, &#39;RT0K&#39;, &#39;SBS&#39;, &#39;SI&#39;, &#39;SIbase&#39;, &#39;T0K&#39;, &#39;air&#39;, &#39;check_units&#39;, &#39;fixSIbase&#39;, &#39;gPET&#39;, &#39;help_layer&#39;, &#39;iRT0K&#39;, &#39;layer&#39;, &#39;list_layer_subclasses&#39;, &#39;mesh&#39;, &#39;migrant&#39;, &#39;oPP&#39;, &#39;plasticizedPVC&#39;, &#39;qSI&#39;, &#39;rPET&#39;, &#39;rigidPVC&#39;, &#39;toSI&#39;]

__project__ = &#34;SFPPy&#34;
__author__ = &#34;Olivier Vitrac&#34;
__copyright__ = &#34;Copyright 2022&#34;
__credits__ = [&#34;Olivier Vitrac&#34;]
__license__ = &#34;MIT&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;1.2&#34;
# %% Private functions

# Initialize unit conversion (intensive initialization with old Python versions)
# NB: degC and kelvin must be used for temperature
# conversion as obj,valueSI,unitSI = toSI(qSI(numvalue,&#34;unit&#34;))
# conversion as obj,valueSI,unitSI = toSI(qSI(&#34;value unit&#34;))
def toSI(q): q=q.to_base_units(); return q,q.m,str(q.u)
NoUnits = &#39;a.u.&#39;     # value for arbitrary unit
UnknownUnits = &#39;N/A&#39; # no non indentified units
if (&#34;SI&#34; not in locals()) or (&#34;qSI&#34; not in locals()):
    SI = SIbase()      # unit engine
    fixSIbase(SI)      # keep the same instance between calls
    qSI = SI.Quantity  # main unit consersion method from string
    # constants (usable in layer object methods)
    # define R,T0K,R*T0K,1/(R*T0K) with there SI units
    constants = {}
    R,constants[&#34;R&#34;],constants[&#34;Runit&#34;] = toSI(qSI(1,&#39;avogadro_number*boltzmann_constant&#39;))
    T0K,constants[&#34;T0K&#34;],constants[&#34;T0Kunit&#34;] = toSI(qSI(0,&#39;degC&#39;))
    RT0K,constants[&#34;RT0K&#34;],constants[&#34;RT0Kunit&#34;] = toSI(R*T0K)
    iRT0K,constants[&#34;iRT0K&#34;],constants[&#34;iRT0Kunit&#34;] = toSI(1/RT0K)


# Concise data validator with unit convertor to SI
# To prevent many issues with temperature and to adhere to 2024 golden standard in layer
# defaulttempUnits has been set back to &#34;degC&#34; from &#34;K&#34;.
def check_units(value,ProvidedUnits=None,ExpectedUnits=None,defaulttempUnits=&#34;degC&#34;):
    &#34;&#34;&#34; check numeric inputs and convert them to SI units &#34;&#34;&#34;
    # by convention, NumPy arrays and None are return unchanged (prevent nesting)
    if isinstance(value,np.ndarray) or value is None:
        return value,UnknownUnits
    if isinstance(value,tuple):
        if len(value) != 2:
            raise ValueError(&#39;value should be a tuple: (value,&#34;unit&#34;&#39;)
        ProvidedUnits = value[1]
        value = value[0]
    if isinstance(value,list): # the function is vectorized
        value = np.array(value)
    if {&#34;degC&#34;, &#34;K&#34;} &amp; {ProvidedUnits, ExpectedUnits}: # the value is a temperature
        ExpectedUnits = defaulttempUnits if ExpectedUnits is None else ExpectedUnits
        ProvidedUnits = ExpectedUnits if ProvidedUnits is None else ProvidedUnits
        if ProvidedUnits==&#34;degC&#34; and ExpectedUnits==&#34;K&#34;:
            value += constants[&#34;T0K&#34;]
        elif ProvidedUnits==&#34;K&#34; and ExpectedUnits==&#34;degC&#34;:
            value -= constants[&#34;T0K&#34;]
        return np.array([value]),ExpectedUnits
    else: # the value is not a temperature
        ExpectedUnits = NoUnits if ExpectedUnits is None else ExpectedUnits
        if (ProvidedUnits==ExpectedUnits) or (ProvidedUnits==NoUnits) or (ExpectedUnits==None):
            conversion =1               # no conversion needed
            units = ExpectedUnits if ExpectedUnits is not None else NoUnits
        else:
            q0,conversion,units = toSI(qSI(1,ProvidedUnits))
        return np.array([value*conversion]),units

# _toSI: function helper for the enduser outside layer
def _toSI(value=None):
    &#39;&#39;&#39;return an SI value from (value,&#34;unit&#34;)&#39;&#39;&#39;
    if not isinstance(value,tuple) or len(value)!=2 \
        or not isinstance(value[0],(float,int,list,np.ndarray)) \
            or  not isinstance(value[1],str):
        raise ValueError(&#39;value must be (currentvalue,&#34;unit&#34;) - for example: (10,&#34;days&#34;)&#39;)
    return check_units(value)[0]

def list_layer_subclasses():
    &#34;&#34;&#34;
    Lists all classes in this module that derive from &#39;layer&#39;,
    along with their layertype and layermaterial properties.

    Returns:
        list of tuples (classname, layertype, layermaterial)
    &#34;&#34;&#34;
    subclasses_info = []
    current_module = sys.modules[__name__]  # This refers to layer.py itself
    for name, obj in inspect.getmembers(current_module, inspect.isclass):
        # Make sure &#39;obj&#39; is actually a subclass of layer (and not &#39;layer&#39; itself)
        if obj is not layer and issubclass(obj, layer):
            try:
                # Instantiate with default parameters so that .layertype / .layermaterial are accessible
                instance = obj()
                subclasses_info.append(
                    {&#34;classname&#34;:name,
                     &#34;type&#34;:instance._type[0],
                     &#34;material&#34;:instance._material[0],
                     &#34;code&#34;:instance._code[0]}
                )
            except TypeError as e:
                # Log error and rethrow for debugging
                print(f&#34;⚠️ Error: Could not instantiate class &#39;{name}&#39;. Check its constructor.&#34;)
                print(f&#34;🔍 Exception: {e}&#34;)
                raise  # Rethrow the error with full traceback
    return subclasses_info


def help_layer():
    &#34;&#34;&#34;
    Print all subclasses with their type/material info in a Markdown table with dynamic column widths.
    &#34;&#34;&#34;
    derived = list_layer_subclasses()
    # Extract table content
    headers = [&#34;Class Name&#34;, &#34;Type&#34;, &#34;Material&#34;, &#34;Code&#34;]
    rows = [[item[&#34;classname&#34;], item[&#34;type&#34;], item[&#34;material&#34;], item[&#34;code&#34;]] for item in derived]
    # Compute column widths based on content
    col_widths = [max(len(str(cell)) for cell in col) for col in zip(headers, *rows)]
    # Formatting row template
    row_format = &#34;| &#34; + &#34; | &#34;.join(f&#34;{{:&lt;{w}}}&#34; for w in col_widths) + &#34; |&#34;
    # Print header
    print(row_format.format(*headers))
    print(&#34;|-&#34; + &#34;-|-&#34;.join(&#34;-&#34; * w for w in col_widths) + &#34;-|&#34;)

    # Print table rows
    for row in rows:
        print(row_format.format(*row))




# %% Core class: layer
# default values (usable in layer object methods)
# these default values can be moved in a configuration file


# Main class definition
# =======================
class layer:
    &#34;&#34;&#34;
        layer class from patankar package
        ...
        strings properties: layername, layertype, layermaterial
        scalar properties: D,k,l,C0
        ...
        Example:
            A = layer(D=1e-14,l=50e-6,layername=&#34;layer A&#34;,layertype=&#34;polymer&#34;,layermaterial=&#34;PP&#34;)
    &#34;&#34;&#34;
    # --------------------------------------------------------------------
    # PRIVATE PROPERTIES (cannot be changed by the user)
    # __ read only attributes
    #  _ private attributes (not public)
    # --------------------------------------------------------------------
    __description = &#34;LAYER object&#34;                # description
    __version = 1.0                               # version
    __contact = &#34;olivier.vitrac@agroparistech.fr&#34; # contact person
    _printformat = &#34;%0.4g&#34;   # format to display D, k, l values


    # Synonyms dictionary: Maps alternative names to the actual parameter
    # these synonyms can be used during construction
    _synonyms = {
        &#34;substance&#34;: {&#34;migrant&#34;, &#34;compound&#34;, &#34;chemical&#34;,&#34;molecule&#34;,&#34;solute&#34;},
        &#34;C0&#34;: {&#34;CP0&#34;, &#34;Cp0&#34;},
        &#34;l&#34;: {&#34;lp&#34;, &#34;lP&#34;},
        &#34;D&#34;: {&#34;Dp&#34;, &#34;DP&#34;},
        &#34;k&#34;: {&#34;kp&#34;, &#34;kP&#34;},
        &#34;T&#34;: {&#34;temp&#34;,&#34;Temp&#34;,&#34;temperature&#34;,&#34;Temperature&#34;,
              &#34;contacttemperature&#34;,&#34;ContactTemperature&#34;,&#34;contactTemperature&#34;}
    }
    # Default values for parameters (note that Td cannot be changed by the end-user)
    _defaults = {
        &#34;l&#34;: 5e-5,   # Thickness (m)
        &#34;D&#34;: 1e-14,  # Diffusion coefficient (m^2/s)
        &#34;k&#34;: 1.0,      # Henri-like coefficient (dimensionless)
        &#34;C0&#34;: 1000,  # Initial concentration (arbitrary units)
        &#34;rho&#34;: 1000, # Default density (kg/m³)
        &#34;T&#34;: 40.0,     # Default temperature (°C)
        &#34;Td&#34;: 25.0,    # Reference temperature for densities (°C)
        # Units (do not change)
        &#34;lunit&#34;: &#34;m&#34;,
        &#34;Dunit&#34;: &#34;m**2/s&#34;,
        &#34;kunit&#34;: &#34;a.u.&#34;,  # NoUnits
        &#34;Cunit&#34;: &#34;a.u.&#34;,  # NoUnits
        &#34;rhounit&#34;: &#34;kg/m**3&#34;,
        &#34;Tunit&#34;: &#34;degC&#34;,  # Temperatures are indicated in °C instead of K (to reduce end-user mistakes)
        # Layer properties
        &#34;layername&#34;: &#34;my layer&#34;,
        &#34;layertype&#34;: &#34;unknown type&#34;,
        &#34;layermaterial&#34;: &#34;unknown material&#34;,
        &#34;layercode&#34;: &#34;N/A&#34;,
        # Mesh parameters
        &#34;nmeshmin&#34;: 20,
        &#34;nmesh&#34;: 600,
        # Substance
        &#34;substance&#34;: None,
        # Other parameters
        &#34;verbose&#34;: None,
        &#34;verbosity&#34;: 2
    }

    # List units
    _parametersWithUnits = {
        &#34;l&#34;: &#34;m&#34;,
        &#34;D&#34;: &#34;m**2/s&#34;,
        &#34;k&#34;: &#34;a.u.&#34;,
        &#34;C&#34;: &#34;a.u.&#34;,
        &#34;rhp&#34;: &#34;kg/m**3&#34;,
        &#34;T&#34;: &#34;degC&#34;,
        }

    # Brief descriptions for each parameter
    _descriptionInputs = {
        &#34;l&#34;: &#34;Thickness of the layer (m)&#34;,
        &#34;D&#34;: &#34;Diffusion coefficient (m²/s)&#34;,
        &#34;k&#34;: &#34;Henri-like coefficient (dimensionless)&#34;,
        &#34;C0&#34;: &#34;Initial concentration (arbitrary units)&#34;,
        &#34;rho&#34;: &#34;Density of the material (kg/m³)&#34;,
        &#34;T&#34;: &#34;Layer temperature (°C)&#34;,
        &#34;Td&#34;: &#34;Reference temperature for densities (°C)&#34;,
        &#34;lunit&#34;: &#34;Unit of thickness (default: m)&#34;,
        &#34;Dunit&#34;: &#34;Unit of diffusion coefficient (default: m²/s)&#34;,
        &#34;kunit&#34;: &#34;Unit of Henri-like coefficient (default: a.u.)&#34;,
        &#34;Cunit&#34;: &#34;Unit of initial concentration (default: a.u.)&#34;,
        &#34;rhounit&#34;: &#34;Unit of density (default: kg/m³)&#34;,
        &#34;Tunit&#34;: &#34;Unit of temperature (default: degC)&#34;,
        &#34;layername&#34;: &#34;Name of the layer&#34;,
        &#34;layertype&#34;: &#34;Type of layer (e.g., polymer, ink, air)&#34;,
        &#34;layermaterial&#34;: &#34;Material composition of the layer&#34;,
        &#34;layercode&#34;: &#34;Identification code for the layer&#34;,
        &#34;nmeshmin&#34;: &#34;Minimum number of FV mesh elements for the layer&#34;,
        &#34;nmesh&#34;: &#34;Number of FV mesh elements for numerical computation&#34;,
        &#34;verbose&#34;: &#34;Verbose mode (None or boolean)&#34;,
        &#34;verbosity&#34;: &#34;Level of verbosity for debug messages (integer)&#34;
    }

    # --------------------------------------------------------------------
    # CONSTRUCTOR OF INSTANCE PROPERTIES
    # None = missing numeric value (managed by default)
    # --------------------------------------------------------------------
    def __init__(self,
                 l=None, D=None, k=None, C0=None, rho=None, T=None,
                 lunit=None, Dunit=None, kunit=None, Cunit=None, rhounit=None, Tunit=None,
                 layername=None,layertype=None,layermaterial=None,layercode=None,
                 substance = None, Dmodel = None, kmodel = None,
                 nmesh=None, nmeshmin=None,
                 verbose=None, verbosity=2,**unresolved):
        &#34;&#34;&#34;

        Parameters
        ----------

        layername : TYPE, optional, string
                    DESCRIPTION. Layer Name. The default is &#34;my layer&#34;.
        layertype : TYPE, optional, string
                    DESCRIPTION. Layer Type. The default is &#34;unknown type&#34;.
        layermaterial : TYPE, optional, string
                        DESCRIPTION. Material identification . The default is &#34;unknown material&#34;.
        PHYSICAL QUANTITIES
        l : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Thickness. The default is 50e-6 (m).
        D : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).
        k : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).
        C0 : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Initial concentration. The default is 1000 (a.u.).
        PHYSICAL UNITS
        lunit : TYPE, optional, string
                DESCRIPTION. Length units. The default unit is &#34;m.
        Dunit : TYPE, optional, string
                DESCRIPTION. Diffusivity units. The default unit is 1e-14 &#34;m^2/s&#34;.
        kunit : TYPE, optional, string
                DESCRIPTION. Henry-like coefficient. The default unit is &#34;a.u.&#34;.
        Cunit : TYPE, optional, string
                DESCRIPTION. Initial concentration. The default unit is &#34;a.u.&#34;.
        Returns
        -------
        a monolayer object which can be assembled into a multilayer structure

        &#34;&#34;&#34;
        # resolve alternative names used by end-users
        substance = layer.resolvename(substance,&#34;substance&#34;,**unresolved)
        C0 = layer.resolvename(C0,&#34;C0&#34;,**unresolved)
        l = layer.resolvename(l,&#34;l&#34;,**unresolved)
        D = layer.resolvename(D,&#34;D&#34;,**unresolved)
        k = layer.resolvename(k,&#34;k&#34;,**unresolved)
        T = layer.resolvename(T,&#34;T&#34;,**unresolved)

        # Assign defaults only if values are not provided
        l = l if l is not None else layer._defaults[&#34;l&#34;]
        D = D if D is not None else layer._defaults[&#34;D&#34;]
        k = k if k is not None else layer._defaults[&#34;k&#34;]
        C0 = C0 if C0 is not None else layer._defaults[&#34;C0&#34;]
        rho = rho if rho is not None else layer._defaults[&#34;rho&#34;]
        T = T if T is not None else layer._defaults[&#34;T&#34;]
        lunit = lunit if lunit is not None else layer._defaults[&#34;lunit&#34;]
        Dunit = Dunit if Dunit is not None else layer._defaults[&#34;Dunit&#34;]
        kunit = kunit if kunit is not None else layer._defaults[&#34;kunit&#34;]
        Cunit = Cunit if Cunit is not None else layer._defaults[&#34;Cunit&#34;]
        rhounit = rhounit if rhounit is not None else layer._defaults[&#34;rhounit&#34;]
        Tunit = Tunit if Tunit is not None else layer._defaults[&#34;Tunit&#34;]
        nmesh = nmesh if nmesh is not None else layer._defaults[&#34;nmesh&#34;]
        nmeshmin = nmeshmin if nmeshmin is not None else layer._defaults[&#34;nmeshmin&#34;]
        verbose = verbose if verbose is not None else layer._defaults[&#34;verbose&#34;]
        verbosity = verbosity if verbosity is not None else layer._defaults[&#34;verbosity&#34;]

        # Assign layer id properties
        layername = layername if layername is not None else layer._defaults[&#34;layername&#34;]
        layertype = layertype if layertype is not None else layer._defaults[&#34;layertype&#34;]
        layermaterial = layermaterial if layermaterial is not None else layer._defaults[&#34;layermaterial&#34;]
        layercode = layercode if layercode is not None else layer._defaults[&#34;layercode&#34;]

        # validate all physical paramaters with their units
        l,lunit = check_units(l,lunit,layer._defaults[&#34;lunit&#34;])
        D,Dunit = check_units(D,Dunit,layer._defaults[&#34;Dunit&#34;])
        k,kunit = check_units(k,kunit,layer._defaults[&#34;kunit&#34;])
        C0,Cunit = check_units(C0,Cunit,layer._defaults[&#34;Cunit&#34;])
        rho,rhounit = check_units(rho,rhounit,layer._defaults[&#34;rhounit&#34;])
        T,Tunit = check_units(T,Tunit,layer._defaults[&#34;Tunit&#34;])

        # set attributes: id and physical properties
        self._name = [layername]
        self._type = [layertype]
        self._material = [layermaterial]
        self._code = [layercode]
        self._nlayer = 1
        self._l = l[:1]
        self._D = D[:1]
        self._k = k[:1]
        self._C0 = C0[:1]
        self._rho = rho[:1]
        self._T = T
        self._lunit = lunit
        self._Dunit = Dunit
        self._kunit = kunit
        self._Cunit = Cunit
        self._rhounit = rhounit
        self._Tunit = Tunit
        self._nmesh = nmesh
        self._nmeshmin = nmeshmin

        # set substance and property models
        self._substance = substance

        # set history for all layers merged with +
        self._layerclass_history = []

        # set verbosity attributes
        self.verbosity = 0 if verbosity is None else verbosity
        self.verbose = verbosity&gt;0 if verbose is None else verbose

        # we initialize the acknowlegment process for future property propagation
        self._hasbeeninherited = {}

    # --------------------------------------------------------------------
    # Class method returning help() for the end user
    # --------------------------------------------------------------------
    @classmethod
    def help(cls):
        &#34;&#34;&#34;
        Prints a dynamically formatted summary of all input parameters,
        adjusting column widths based on content and wrapping long descriptions.
        &#34;&#34;&#34;

        # Column Headers
        headers = [&#34;Parameter&#34;, &#34;Default Value&#34;, &#34;Has Synonyms?&#34;, &#34;Description&#34;]
        col_widths = [len(h) for h in headers]  # Start with header widths

        # Collect Data Rows
        rows = []
        for param, default in cls._defaults.items():
            has_synonyms = &#34;✅ Yes&#34; if param in cls._synonyms else &#34;❌ No&#34;
            description = cls._descriptionInputs.get(param, &#34;No description available&#34;)

            # Update column widths dynamically
            col_widths[0] = max(col_widths[0], len(param))
            col_widths[1] = max(col_widths[1], len(str(default)))
            col_widths[2] = max(col_widths[2], len(has_synonyms))
            col_widths[3] = max(col_widths[3], len(description))

            rows.append([param, str(default), has_synonyms, description])

        # Function to wrap text for a given column width
        def wrap_text(text, width):
            return textwrap.fill(text, width)

        # Print Table with Adjusted Column Widths
        separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in col_widths) + &#34;-+&#34;
        print(&#34;\n### **Accepted Parameters and Defaults**\n&#34;)
        print(separator)
        print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(col_widths[i]) for i, h in enumerate(headers)) + &#34; |&#34;)
        print(separator)
        for row in rows:
            # Wrap text in the description column
            row[3] = wrap_text(row[3], col_widths[3])

            # Print row
            print(&#34;| &#34; + &#34; | &#34;.join(row[i].ljust(col_widths[i]) for i in range(3)) + &#34; | &#34; + row[3])
        print(separator)

        # Synonyms Table
        print(&#34;\n### **Parameter Synonyms**\n&#34;)
        syn_headers = [&#34;Parameter&#34;, &#34;Synonyms&#34;]
        syn_col_widths = [
            max(len(&#34;Parameter&#34;), max(len(k) for k in cls._synonyms.keys())),  # Ensure it fits &#34;Parameter&#34;
            max(len(&#34;Synonyms&#34;), max(len(&#34;, &#34;.join(v)) for v in cls._synonyms.values()))  # Ensure it fits &#34;Synonyms&#34;
        ]
        syn_separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in syn_col_widths) + &#34;-+&#34;
        print(syn_separator)
        print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(syn_col_widths[i]) for i, h in enumerate(syn_headers)) + &#34; |&#34;)
        print(syn_separator)
        for param, synonyms in cls._synonyms.items():
            print(f&#34;| {param.ljust(syn_col_widths[0])} | {&#39;, &#39;.join(synonyms).ljust(syn_col_widths[1])} |&#34;)
        print(syn_separator)


    # --------------------------------------------------------------------
    # Class method to handle ambiguous definition from end-user
    # --------------------------------------------------------------------
    @classmethod
    def resolvename(cls, param_value, param_key, **unresolved):
        &#34;&#34;&#34;
        Resolves the correct parameter value using known synonyms.

        - If param_value is already set (not None), return it.
        - If a synonym exists in **unresolved, assign its value.
        - If multiple synonyms of the same parameter appear in **unresolved, raise an error.
        - Otherwise, return None.

        Parameters:
        - `param_name` (any): The original value (if provided).
        - `param_key` (str): The legitimate parameter name we are resolving.
        - `unresolved` (dict): The dictionary of unrecognized keyword arguments.

        Returns:
        - The resolved value or None if not found.
        &#34;&#34;&#34;
        if param_value is not None:
            return param_value  # The parameter is explicitly defined, do not override
        if not unresolved:      # shortcut
            return None
        resolved_value = None
        found_keys = []
        # Check if param_key itself is present in unresolved
        if param_key in unresolved:
            found_keys.append(param_key)
            resolved_value = unresolved[param_key]
        # Check if any of its synonyms are in unresolved
        if param_key in cls._synonyms:
            for synonym in cls._synonyms[param_key]:
                if synonym in unresolved:
                    found_keys.append(synonym)
                    resolved_value = unresolved[synonym]
        # Raise error if multiple synonyms were found
        if len(found_keys) &gt; 1:
            raise ValueError(
                f&#34;Conflicting definitions: Multiple synonyms {found_keys} were provided for &#39;{param_key}&#39;.&#34;
            )
        return resolved_value


    # --------------------------------------------------------------------
    # overloading binary addition (note that the output is of type layer)
    # --------------------------------------------------------------------
    def __add__(self,other):
        &#34;&#34;&#34; C=A+B | overload + operator &#34;&#34;&#34;
        if isinstance(other, layer):
            res = duplicate(self)
            res._nmeshmin = min(self._nmeshmin,other._nmeshmin)
            # propage substance
            if self._substance is None:
                res._substance = other._substance
            else:
                if isinstance(self._substance,migrant) and isinstance(other._substance,migrant):
                    if self._substance.M != other._substance.M:
                        print(&#34;Warning: the smallest subtance is propagated everywhere&#34;)
                    res._substance = self._substance if self._substance.M&lt;=other._substance.M else other._substance
                else:
                    res._substance = None
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_code&#34;,&#34;_nlayer&#34;]:
                setattr(res,p,getattr(self,p)+getattr(other,p))
            for p in [&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;,&#34;_rho&#34;,&#34;_T&#34;]:
                setattr(res,p,np.concatenate((getattr(self,p),getattr(other,p))))
            # we add the history of all layers
            res._layerclass_history = self.layerclass_history + other.layerclass_history
            return res
        else: raise ValueError(&#34;invalid layer object&#34;)


    # --------------------------------------------------------------------
    # overloading binary multiplication (note that the output is of type layer)
    # --------------------------------------------------------------------
    def __mul__(self,ntimes):
        &#34;&#34;&#34; nA = A*n | overload * operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
            res = duplicate(self)
            if ntimes&gt;1:
                for n in range(1,ntimes): res += self
            return res
        else: raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)


    # --------------------------------------------------------------------
    # len method
    # --------------------------------------------------------------------
    def __len__(self):
        &#34;&#34;&#34; length method &#34;&#34;&#34;
        return self._nlayer

    # --------------------------------------------------------------------
    # object indexing (get,set) method
    # --------------------------------------------------------------------
    def __getitem__(self,i):
        &#34;&#34;&#34; get indexing method &#34;&#34;&#34;
        res = duplicate(self)
        # check indices
        isscalar = isinstance(i,int)
        if isinstance(i,slice):
            if i.step==None: j = list(range(i.start,i.stop))
            else: j = list(range(i.start,i.stop,i.step))
            res._nlayer = len(j)
        if isinstance(i,int): res._nlayer = 1
        # pick indices for each property
        for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
            content = getattr(self,p)
            try:
                if isscalar: setattr(res,p,content[i:i+1])
                else: setattr(res,p,content[i])
            except IndexError as err:
                if self.verbosity&gt;0 and self.verbose:
                    print(&#34;bad layer object indexing: &#34;,err)
        return res

    def __setitem__(self,i,other):
        &#34;&#34;&#34; set indexing method &#34;&#34;&#34;
        # check indices
        if isinstance(i,slice):
            if i.step==None: j = list(range(i.start,i.stop))
            else: j = list(range(i.start,i.stop,i.step))
        elif isinstance(i,int): j = [i]
        else:raise IndexError(&#34;invalid index&#34;)
        islayer = isinstance(other,layer)
        isempty = not islayer and isinstance(other,list) and len(other)&lt;1
        if isempty:         # empty right hand side
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
                content = getattr(self,p)
                try:
                    newcontent = [content[k] for k in range(self._nlayer) if k not in j]
                except IndexError as err:
                    if self.verbosity&gt;0 and self.verbose:
                        print(&#34;bad layer object indexing: &#34;,err)
                if isinstance(content,np.ndarray) and not isinstance(newcontent,np.ndarray):
                    newcontent = np.array(newcontent)
                setattr(self,p,newcontent)
            self._nlayer = len(newcontent)
        elif islayer:        # islayer right hand side
            nk1 = len(j)
            nk2 = other._nlayer
            if nk1 != nk2:
                raise IndexError(&#34;the number of elements does not match the number of indices&#34;)
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
                content1 = getattr(self,p)
                content2 = getattr(other,p)
                for k in range(nk1):
                    try:
                        content1[j[k]] = content2[k]
                    except IndexError as err:
                        if self.verbosity&gt;0 and self.verbose:
                            print(&#34;bad layer object indexing: &#34;,err)
                setattr(self,p,content1)
        else:
            raise ValueError(&#34;only [] or layer object are accepted&#34;)


    # --------------------------------------------------------------------
    # Getter methods (show private/hidden properties and meta-properties)
    # --------------------------------------------------------------------
    @property
    def layerclass_history(self):
        return self._layerclass_history if self._layerclass_history != [] else [self.layerclass]
    @property
    def layerclass(self): return type(self).__name__
    @property
    def name(self): return self._name
    @property
    def type(self): return self._type
    @property
    def material(self): return self._material
    @property
    def code(self): return self._code
    @property
    def l(self): return self._l
    @property
    def D(self):
        Dtmp = self.Dmodel()
        if Dtmp is not None:
            return np.full_like(self._D, Dtmp)
        else:
            return self._D
    @property
    def k(self):
        ktmp = self.kmodel()
        if ktmp:
            return np.full_like(self._D, ktmp)
        else:
            return self._k
    @property
    def C0(self): return self._C0
    @property
    def rho(self): return self._rho
    @property
    def T(self): return self._T
    @property
    def TK(self): return self._T+T0K
    @property
    def lunit(self): return self._lunit
    @property
    def Dunit(self): return self._Dunit
    @property
    def kunit(self): return self._kunit
    @property
    def Cunit(self): return self._Cunit
    @property
    def rhounit(self): return self._rhounit
    @property
    def Tunit(self): return self._Tunit
    @property
    def TKunit(self): return &#34;K&#34;
    @property
    def n(self): return self._nlayer
    @property
    def nmesh(self): return self._nmesh
    @property
    def nmeshmin(self): return self._nmeshmin
    @property
    def resistance(self): return self.l*self.k/self.D
    @property
    def permeability(self): return self.D/(self.l*self.k)
    @property
    def lag(self): return self.l**2/(6*self.D)
    @property
    def pressure(self): return self.k*self.C0
    @property
    def thickness(self): return sum(self.l)
    @property
    def concentration(self): return sum(self.l*self.C0)/self.thickness
    @property
    def relative_thickness(self): return self.l/self.thickness
    @property
    def relative_resistance(self): return self.resistance/sum(self.resistance)
    @property
    def rank(self): return np.flip(np.argsort(np.array(self.resistance))+1).tolist()
    @property
    def referencelayer(self): return np.argmax(self.resistance)
    @property
    def lreferencelayer(self): return self.l[self.referencelayer]
    @property
    def Foscale(self): return self.D[self.referencelayer]/self.lreferencelayer**2

    # layer substance (of class migrant or None)
    @property
    def substance(self): return self._substance

    # Dmodel and kmodel returned as properties (they are lambda functions)
    # polymer and mass are udpdated on the fly (the code loops over all layers)
    @property
    def Dmodel(self):
        &#34;&#34;&#34;Return a callable function that evaluates D with updated parameters.&#34;&#34;&#34;
        if not isinstance(self._substance,migrant) or self._substance.Deval() is None:
            return lambda **kwargs: None  # Return a function that always returns None
        template = self._substance.Dtemplate.copy()
        template.update()
        def func(**kwargs):
            D = np.empty_like(self._D)
            for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
                template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
                # inherit eventual user parameters
                D[i] = self._substance.D.evaluate(**dict(template, **kwargs))
            return D
        return func

    @property
    def kmodel(self):
        &#34;&#34;&#34;Return a callable function that evaluates k with updated parameters.&#34;&#34;&#34;
        if not isinstance(self._substance,migrant) or self._substance.keval() is None:
            return lambda **kwargs: None  # Return a function that always returns None
        template = self._substance.ktemplate.copy()
        template.update()
        def func(**kwargs):
            k = np.empty_like(self._k)
            for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
                template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
                # inherit eventual user parameters
                k[i] = self._substance.k.evaluate(**dict(template, **kwargs))
            return k
        return func


    # --------------------------------------------------------------------
    # comparators based resistance
    # --------------------------------------------------------------------
    def __eq__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1==value2

    def __ne__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1!=value2

    def __lt__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&lt;value2

    def __gt__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&gt;value2

    def __le__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&lt;=value2

    def __ge__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&gt;=value2


    # --------------------------------------------------------------------
    # Generates mesh
    # --------------------------------------------------------------------
    def mesh(self,nmesh=None,nmeshmin=None):
        &#34;&#34;&#34; nmesh() generates mesh based on nmesh and nmeshmin, nmesh(nmesh=value,nmeshmin=value) &#34;&#34;&#34;
        if nmesh==None: nmesh = self.nmesh
        if nmeshmin==None: nmeshmin = self.nmeshmin
        if nmeshmin&gt;nmesh: nmeshmin,nmesh = nmesh, nmeshmin
        # X = mesh distribution (number of nodes per layer)
        X = np.ones(self._nlayer)
        for i in range(1,self._nlayer):
           X[i] = X[i-1]*(self.permeability[i-1]*self.l[i])/(self.permeability[i]*self.l[i-1])
        X = np.maximum(nmeshmin,np.ceil(nmesh*X/sum(X)))
        X = np.round((X/sum(X))*nmesh).astype(int)
        # do the mesh
        x0 = 0
        mymesh = []
        for i in range(self._nlayer):
            mymesh.append(mesh(self.l[i]/self.l[self.referencelayer],X[i],x0=x0,index=i))
            x0 += self.l[i]
        return mymesh

    # --------------------------------------------------------------------
    # Getter methods and tools to validate inputs checknumvalue and checktextvalue
    # --------------------------------------------------------------------
    def checknumvalue(self,value,ExpectedUnits=None):
        &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
        if isinstance(value,tuple):
            value = check_units(value,ExpectedUnits=ExpectedUnits)
        if isinstance(value,int): value = float(value)
        if isinstance(value,float): value = np.array([value])
        if isinstance(value,list): value = np.array(value)
        if len(value)&gt;self._nlayer:
            value = value[:self._nlayer]
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the extra value(s) has been removed&#39;)
        elif len(value)&lt;self._nlayer:
            value = np.concatenate((value,value[-1:]*np.ones(self._nlayer-len(value))))
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the last value has been repeated&#39;)
        return value

    def checktextvalue(self,value):
        &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
        if not isinstance(value,list): value = [value]
        if len(value)&gt;self._nlayer:
            value = value[:self._nlayer]
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the extra entry(ies) has been removed&#39;)
        elif len(value)&lt;self._nlayer:
            value = value + value[-1:]*(self._nlayer-len(value))
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the last entry has been repeated&#39;)
        return value

    @l.setter
    def l(self,value): self._l =self.checknumvalue(value,layer._defaults[&#34;lunit&#34;])
    @D.setter
    def D(self,value): self._D=self.checknumvalue(value,layer._defaults[&#34;Dunit&#34;])
    @k.setter
    def k(self,value): self._k =self.checknumvalue(value,layer._defaults[&#34;kunit&#34;])
    @C0.setter
    def C0(self,value): self._C0 =self.checknumvalue(value,layer._defaults[&#34;Cunit&#34;])
    @rho.setter
    def rho(self,value): self._rho =self.checknumvalue(value,layer._defaults[&#34;rhounit&#34;])
    @T.setter
    def T(self,value): self._T =self.checknumvalue(value,layer._defaults[&#34;Tunit&#34;])
    @name.setter
    def name(self,value): self._name =self.checktextvalue(value)
    @type.setter
    def type(self,value): self._type =self.checktextvalue(value)
    @material.setter
    def material(self,value): self._material =self.checktextvalue(value)
    @nmesh.setter
    def nmesh(self,value): self._nmesh = max(value,self._nlayer*self._nmeshmin)
    @nmeshmin.setter
    def nmeshmin(self,value): self._nmeshmin = max(value,round(self._nmesh/(2*self._nlayer)))
    @substance.setter
    def substance(self,value):
        if not isinstance(value,migrant):
            raise TypeError(f&#34;value must be a migrant class not a {type(value).__name__}&#34;)
        self._substance = value


    # --------------------------------------------------------------------
    # hash methods (assembly and layer-by-layer)
    # note that list needs to be converted into tuples to be hashed
    # --------------------------------------------------------------------
    def __hash__(self):
        &#34;&#34;&#34; hash layer-object (assembly) method &#34;&#34;&#34;
        return hash((tuple(self._name),
                     tuple(self._type),
                     tuple(self._material),
                     tuple(self._l),
                     tuple(self._D),
                     tuple(self.k),
                     tuple(self._C0),
                     tuple(self._rho)))

    # layer-by-layer @property = decoration to consider it
    # as a property instead of a method/attribute
    # comprehension for n in range(self._nlayer) applies it to all layers
    @property
    def hashlayer(self):
        &#34;&#34;&#34; hash layer (layer-by-layer) method &#34;&#34;&#34;
        return [hash((self._name[n],
                      self._type[n],
                      self._material[n],
                      self._l[n],
                      self._D[n],
                      self.k[n],
                      self._C0[n],
                      self._rho[n]))
                for n in range(self._nlayer)
                ]


    # --------------------------------------------------------------------
    # repr method (since the getter are defined, the &#39;_&#39; is dropped)
    # --------------------------------------------------------------------
    # density and temperature are not shown
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        print(&#34;\n[%s version=%0.4g, contact=%s]&#34; % (self.__description,self.__version,self.__contact))
        if self._nlayer==0:
            print(&#34;empty %s&#34; % (self.__description))
        else:
            hasDmodel = self.Dmodel() is not None
            haskmodel = self.kmodel() is not None
            properties_ = {&#34;l&#34;:False,&#34;D&#34;:hasDmodel,&#34;k&#34;:haskmodel,&#34;C0&#34;:False}
            if hasDmodel or haskmodel:
                properties_[&#34;T&#34;] = False
            fmtval = &#39;%10s: &#39;+self._printformat+&#34; [%s]&#34;
            fmtstr = &#39;%10s= %s&#39;
            if self._nlayer==1:
                print(f&#39;monolayer of {self.__description}:&#39;)
            else:
                print(f&#39;{self._nlayer}-multilayer of {self.__description}:&#39;)
            for n in range(1,self._nlayer+1):
                modelinfo = {
                    &#34;D&#34;: f&#34;{self._substance.D.__name__}({self.layerclass_history[n-1]},{self._substance},T={float(self.T[0])} {self.Tunit})&#34; if hasDmodel else &#34;&#34;,
                    &#34;k&#34;: f&#34;{self._substance.k.__name__}({self.layerclass_history[n-1]},{self._substance} g/mol,T={float(self.T[0])} {self.Tunit})&#34; if haskmodel else &#34;&#34;,
                    }
                print(&#39;-- [ layer %d of %d ] ---------- barrier rank=%d --------------&#39;
                      % (n,self._nlayer,self.rank[n-1]))
                for p in [&#34;name&#34;,&#34;type&#34;,&#34;material&#34;,&#34;code&#34;]:
                    v = getattr(self,p)
                    print(&#39;%10s: &#34;%s&#34;&#39; % (p,v[n-1]),flush=True)
                for p in properties_.keys():
                    v = getattr(self,p)                 # value
                    vunit = getattr(self,p[0]+&#34;unit&#34;)   # value unit
                    print(fmtval % (p,v[n-1],vunit),flush=True)
                    if properties_[p]:
                        print(fmtstr % (&#34;&#34;,modelinfo[p]),flush=True)
        return str(self)

    def __str__(self):
        &#34;&#34;&#34;Formatted string representation of layer&#34;&#34;&#34;
        all_identical = len(set(self.layerclass_history)) == 1
        cls = self.__class__.__name__ if all_identical else &#34;multilayer&#34;
        return f&#34;&lt;{cls} with {self.n} layer{&#39;s&#39; if self.n&gt;1 else &#39;&#39;}: {self.name}&gt;&#34;

    # --------------------------------------------------------------------
    # Returns the equivalent dictionary from an object for debugging
    # --------------------------------------------------------------------
    def _todict(self):
        &#34;&#34;&#34; returns the equivalent dictionary from an object &#34;&#34;&#34;
        return dict((key, getattr(self, key)) for key in dir(self) if key not in dir(self.__class__))
    # --------------------------------------------------------------------

    # --------------------------------------------------------------------
    # Simplify layers by collecting similar ones
    # --------------------------------------------------------------------
    def simplify(self):
        &#34;&#34;&#34; merge continuous layers of the same type &#34;&#34;&#34;
        nlayer = self._nlayer
        if nlayer&gt;1:
           res = self[0]
           ires = 0
           ireshash = res.hashlayer[0]
           for i in range(1,nlayer):
               if self.hashlayer[i]==ireshash:
                   res.l[ires] = res.l[ires]+self.l[i]
               else:
                   res = res + self[i]
                   ires = ires+1
                   ireshash = self.hashlayer[i]
        else:
             res = self.copy()
        return res

    # --------------------------------------------------------------------
    # Split layers into a tuple
    # --------------------------------------------------------------------
    def split(self):
        &#34;&#34;&#34; split layers &#34;&#34;&#34;
        out = ()
        if self._nlayer&gt;0:
            for i in range(self._nlayer):
                out = out + (self[i],) # (,) special syntax for tuple singleton
        return out

    # --------------------------------------------------------------------
    # deepcopy
    # --------------------------------------------------------------------
    def copy(self,**kwargs):
        &#34;&#34;&#34;
        Creates a deep copy of the current layer instance.

        Returns:
        - layer: A new layer instance identical to the original.
        &#34;&#34;&#34;
        return duplicate(self).update(**kwargs)

    # --------------------------------------------------------------------
    # update contact conditions from a foodphysics instance (or do the reverse)
    # material &lt;&lt; medium
    # --------------------------------------------------------------------
    def _from(self,medium=None):
        &#34;&#34;&#34;Propagates contact conditions from food instance&#34;&#34;&#34;
        from patankar.food import foodphysics
        if not isinstance(medium,foodphysics):
            raise TypeError(f&#34;medium must be a foodphysics, foodlayer not a {type(medium).__name__}&#34;)
        if not hasattr(medium, &#34;contacttemperature&#34;):
            medium.contacttemperature = self.T[0]
        T = self.get_param(&#34;contacttemperature&#34;,40,acceptNone=False)
        self.T = np.full_like(self.T,T)

    # overloading operation
    def __lshift__(self, medium):
        &#34;&#34;&#34;Overloads &lt;&lt; to propagate contact conditions from food.&#34;&#34;&#34;
        self._from(medium)

    # --------------------------------------------------------------------
    # Inheritance registration mechanism associated with food &gt;&gt; layer
    # It is used by food, not by layer (please refer to food.py).
    # Note that layer &gt;&gt; food means mass transfer simulation
    # --------------------------------------------------------------------
    def acknowledge(self, what=None, category=None):
        &#34;&#34;&#34;
        Register inherited properties under a given category.

        Parameters:
        -----------
        what : str or list of str or a set
            The properties or attributes that have been inherited.
        category : str
            The category under which the properties are grouped.
        &#34;&#34;&#34;
        if category is None or what is None:
            raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
        if isinstance(what, str):
            what = {what}  # Convert string to a set
        elif isinstance(what, list):
            what = set(what)  # Convert list to a set for uniqueness
        elif not isinstance(what,set):
            raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
        if category not in self._hasbeeninherited:
            self._hasbeeninherited[category] = set()
        self._hasbeeninherited[category].update(what)

    # --------------------------------------------------------------------
    # migration simulation overloaded as sim = layer &gt;&gt; food
    # using layer &gt;&gt; food without output works also.
    # The result is stored in food.lastsimulation
    # --------------------------------------------------------------------
    def contact(self,medium,**kwargs):
        return self.migration(medium,**kwargs)

    def migration(self,medium,**kwargs):
        from patankar.migration import senspatankar
        sim = senspatankar(self,medium,**kwargs)
        medium.lastsimulation = sim # store the last simulation result in medium
        medium.lastinput = self # store the last input (self)
        sim.savestate(self,medium) # store store the inputs in sim for chaining
        return sim

    # overloading operation
    def __rshift__(self, medium):
        &#34;&#34;&#34;Overloads &gt;&gt; to propagate migration to food.&#34;&#34;&#34;
        from patankar.food import foodphysics
        if not isinstance(medium,foodphysics):
            raise TypeError(f&#34;medium must be a foodphysics object not a {type(medium).__name__}&#34;)
        return self.contact(medium)

    # --------------------------------------------------------------------
    # Safe update method
    # --------------------------------------------------------------------
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update layer parameters following strict validation rules.

        Rules:
        1) key should be listed in self._defaults
        2) for some keys, synonyms are acceptable as reported in self._synonyms
        3) values cannot be None if they were not None in _defaults
        4) values should be str if they were initially str, idem with bool
        5) values which were numeric (int, float, np.ndarray) should remain numeric.
        6) lists are acceptable as numeric arrays
        7) all numerical (float, np.ndarray, list) except int must be converted into numpy arrays.
           Values which were int in _defaults must remain int and an error should be raised
           if a float value is proposed.
        8) keys listed in _parametersWithUnits can be assigned with tuples (value, &#34;unit&#34;).
           They will be converted automatically with check_units(value).
        9) for parameters with a default value None, any value is acceptable
        10) A clear error message should be displayed for any bad value showing the
            current value of the parameter and its default value.
        &#34;&#34;&#34;

        if not kwargs:  # shortcut
            return self # for chaining

        param_counts = {key: 0 for key in self._defaults}  # Track how many times each param is set

        def resolve_key(key):
            &#34;&#34;&#34;Resolve key considering synonyms and check for duplicates.&#34;&#34;&#34;
            for main_key, synonyms in self._synonyms.items():
                if key == main_key or key in synonyms:
                    param_counts[main_key] += 1
                    return main_key
            param_counts[key] += 1
            return key

        def validate_value(key, value):
            &#34;&#34;&#34;Validate and process the value according to the rules.&#34;&#34;&#34;
            default_value = self._defaults[key]

            # Rule 3: values cannot be None if they were not None in _defaults
            if value is None and default_value is not None:
                raise ValueError(f&#34;Invalid value for &#39;{key}&#39;: None is not allowed. &#34;
                                 f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 9: If default is None, any value is acceptable
            if default_value is None:
                return value

            # Rule 4 &amp; 5: Ensure type consistency (str, bool, or numeric types)
            if isinstance(default_value, str) and not isinstance(value, str):
                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected str, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
            if isinstance(default_value, bool) and not isinstance(value, bool):
                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected bool, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 6 &amp; 7: Convert numeric types properly
            if isinstance(default_value, (int, float, np.ndarray)):
                if isinstance(value, list):
                    value = np.array(value)

                if isinstance(default_value, int):
                    if isinstance(value, float) or (isinstance(value, np.ndarray) and np.issubdtype(value.dtype, np.floating)):
                        raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got float. &#34;
                                        f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
                    if isinstance(value, (int, np.integer)):
                        return int(value)  # Ensure it remains an int
                    raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got {type(value).__name__}. &#34;
                                    f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

                if isinstance(value, (int, float, list, np.ndarray)):
                    return np.array(value, dtype=float)  # Convert everything to np.array for floats

                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected numeric, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 8: Convert units if applicable
            if key in self._parametersWithUnits and isinstance(value, tuple):
                value, unit = value
                converted_value, _ = check_units((value, unit), ExpectedUnits=self._parametersWithUnits[key])
                return converted_value

            return value

        # Apply updates while tracking parameter occurrences
        for key, value in kwargs.items():
            resolved_key = resolve_key(key)

            if resolved_key not in self._defaults:
                raise KeyError(f&#34;Invalid key &#39;{key}&#39;. Allowed keys: {list(self._defaults.keys())}.&#34;)

            try:
                validated_value = validate_value(resolved_key, value)
                setattr(self, resolved_key, validated_value)
            except (TypeError, ValueError) as e:
                raise ValueError(f&#34;Error updating &#39;{key}&#39;: {e}&#34;)

        # Ensure that no parameter was set multiple times due to synonyms
        duplicate_keys = [k for k, v in param_counts.items() if v &gt; 1]
        if duplicate_keys:
            raise ValueError(f&#34;Duplicate assignment detected for parameters: {duplicate_keys}. &#34;
                             &#34;Use only one synonym per parameter.&#34;)

        return self # to enable chaining

# %% Mesh class
# Mesh class
# =======================
class mesh():
    &#34;&#34;&#34; simple nodes class for finite-volume methods &#34;&#34;&#34;
    def __init__(self,l,n,x0=0,index=None):
       self.x0 = x0
       self.l = l
       self.n = n
       de = dw = l/(2*n)
       self.de = np.ones(n)*de
       self.dw = np.ones(n)*dw
       self.xmesh = np.linspace(0+dw,l-de,n) # nodes positions
       self.w = self.xmesh - dw
       self.e = self.xmesh + de
       self.index = np.full(n, int(index), dtype=np.int32)

    def __repr__(self):
        print(f&#34;-- mesh object (layer index={self.index[0]}) --&#34;)
        print(&#34;%25s = %0.4g&#34; % (&#34;start at x0&#34;, self.x0))
        print(&#34;%25s = %0.4g&#34; % (&#34;domain length l&#34;, self.l))
        print(&#34;%25s = %0.4g&#34; % (&#34;number of nodes n&#34;, self.n))
        print(&#34;%25s = %0.4g&#34; % (&#34;dw&#34;, self.dw[0]))
        print(&#34;%25s = %0.4g&#34; % (&#34;de&#34;, self.de[0]))
        return &#34;mesh%d=[%0.4g %0.4g]&#34; % \
            (self.n,self.x0+self.xmesh[0],self.x0+self.xmesh[-1])


# %% Material classes
&#34;&#34;&#34;
=======================================================
Child classes derived from layer
this section can be extended to define specific layers
    * polymer
    * ink
    * air
    * paper and board

These classes are more flexible than the parent class layer.
They can include temperature dependence, refined tunning, etc.

Properties taken from
    * linear thermal expansoin
    https://omnexus.specialchem.com/polymer-properties/properties/coefficient-of-linear-thermal-expansion

Once the layers are incorporated in a multilayer structure,
they loose their original subclass and become only an object
layer. These subclasses are therefore useful to refine the
properties of each layer before standarizing them.

=========================================================
&#34;&#34;&#34;

# &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; P O L Y O L E F I N S &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

# &lt;-- LDPE polymer ----------------------------------&gt;
class LDPE(layer):
    &#34;&#34;&#34;  extended pantankar.layer for low-density polyethylene LDPE  &#34;&#34;&#34;
    def __init__(self,l=100e-6,D=1e-12,T=None,
                 k=None,C0=None,lunit=None,Dunit=None,kunit=None,Cunit=None,
                 layername=&#34;layer in LDPE&#34;,**extra):
        &#34;&#34;&#34; LDPE layer constructor &#34;&#34;&#34;
        super().__init__(
                       l=l,D=D,k=k,C0=C0, T=T,
                       lunit=lunit,Dunit=Dunit,kunit=kunit,Cunit=Cunit,
                       layername=layername,
                       layertype=&#34;polymer&#34;, # set by default at inititialization
                       layermaterial=&#34;low-density polyethylene&#34;,
                       layercode=&#34;LDPE&#34;,
                       **extra
                       )
    def density(self,T=None):
        &#34;&#34;&#34; density of LDPE: density(T in K) &#34;&#34;&#34;
        T = self.T if T is None else check_units(T,None,&#34;degC&#34;)[0]
        return 920 *(1-3*(T-layer._defaults[&#34;Td&#34;])*20e-5),&#34;kg/m**3&#34; # lowest temperature
    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of LDPE &#34;&#34;&#34;
        return -130,&#34;degC&#34; # lowest temperature


# &lt;-- HDPE polymer ----------------------------------&gt;
class HDPE(layer):
    &#34;&#34;&#34;  extended pantankar.layer for high-density polyethylene HDPE  &#34;&#34;&#34;
    def __init__(self,l=500e-6,D=1e-13, T=None,
                 k=None,C0=None,lunit=None,Dunit=None,kunit=None,Cunit=None,
                 layername=&#34;layer in HDPE&#34;,**extra):
        &#34;&#34;&#34; HDPE layer constructor &#34;&#34;&#34;
        layer.__init__(self,
                       l=l,D=D,k=k,C0=C0, T=T,
                       lunit=lunit,Dunit=Dunit,kunit=kunit,Cunit=Cunit,
                       layername=layername,
                       layertype=&#34;polymer&#34;, # set by default at inititialization
                       layermaterial=&#34;high-density polyethylene&#34;,
                       layercode=&#34;HDPE&#34;,
                       **extra
                       )
    def density(self,T=None):
        &#34;&#34;&#34; density of HDPE: density(T in K) &#34;&#34;&#34;
        T = self.T if T is None else check_units(T,None,&#34;degC&#34;)[0]
        return 940 *(1-3*(T-layer._defaults[&#34;Td&#34;])*11e-5),&#34;kg/m**3&#34; # lowest temperature
    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of HDPE &#34;&#34;&#34;
        return -100,&#34;degC&#34; # highest temperature

# &lt;-- LLDPE polymer ----------------------------------&gt;
class LLDPE(layer):
    &#34;&#34;&#34; extended pantankar.layer for linear low-density polyethylene LLDPE &#34;&#34;&#34;
    def __init__(self, l=80e-6, D=1e-12, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in LLDPE&#34;,**extra):
        &#34;&#34;&#34;
        LLDPE layer constructor
        Defaults are set to typical values found in the literature or between
        LDPE/HDPE ones. Adjust them as necessary for your models.
        &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;linear low-density polyethylene&#34;,
            layercode=&#34;LLDPE&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of LLDPE: density(T in K)
        By default, uses an approximate value between LDPE and HDPE.
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        # Similar formula to LDPE and HDPE, with a coefficient suitable for LLDPE.
        return 915 * (1 - 3 * (T - layer._defaults[&#34;Td&#34;]) * 15e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34;
        glass transition temperature of LLDPE
        Typically close to LDPE, though slightly higher or lower can be found in the literature.
        &#34;&#34;&#34;
        return -120, &#34;degC&#34;

# &lt;-- PP polymer ----------------------------------&gt;
class PP(layer):
    &#34;&#34;&#34;  extended pantankar.layer for isotactic polypropylene PP  &#34;&#34;&#34;
    def __init__(self,l=300e-6,D=1e-14, T=None,
                 k=None,C0=None,lunit=None,Dunit=None,kunit=None,Cunit=None,
                 layername=&#34;layer in PP&#34;,**extra):
        &#34;&#34;&#34; PP layer constructor &#34;&#34;&#34;
        layer.__init__(self,
                       l=l,D=D,k=k,C0=C0, T=T,
                       lunit=lunit,Dunit=Dunit,kunit=kunit,Cunit=Cunit,
                       layername=layername,
                       layertype=&#34;polymer&#34;, # set by default at inititialization
                       layermaterial=&#34;isotactic polypropylene&#34;,
                       layercode=&#34;PP&#34;,
                       **extra
                       )
    def density(self,T=None):
        &#34;&#34;&#34; density of PP: density(T in K) &#34;&#34;&#34;
        T = self.T if T is None else check_units(T,None,&#34;degC&#34;)[0]
        return 910 *(1-3*(T-layer._defaults[&#34;Td&#34;])*7e-5),&#34;kg/m**3&#34; # lowest temperature
    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PP &#34;&#34;&#34;
        return 0,&#34;degC&#34; # highest temperature

# -- PPrubber (atactic polypropylene) ---------------------------------
class PPrubber(layer):
    &#34;&#34;&#34; extended pantankar.layer for atactic (rubbery) polypropylene PP &#34;&#34;&#34;
    def __init__(self, l=100e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PPrubber&#34;,**extra):
        &#34;&#34;&#34; PPrubber layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;atactic polypropylene&#34;,
            layercode=&#34;aPP&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of atactic (rubbery) PP: density(T in K)
        Approximate initial density ~900 kg/m^3, linear thermal expansion factor
        can be adjusted.
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 900 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of atactic/rubbery PP &#34;&#34;&#34;
        return -20, &#34;degC&#34;


# -- oPP (bioriented polypropylene) ------------------------------------
class oPP(layer):
    &#34;&#34;&#34; extended pantankar.layer for bioriented polypropylene oPP &#34;&#34;&#34;
    def __init__(self, l=40e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in oPP&#34;,**extra):
        &#34;&#34;&#34; oPP layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;bioriented polypropylene&#34;,
            layercode=&#34;oPP&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of bioriented PP: density(T in K)
        Typically close to isotactic PP around ~910 kg/m^3.
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 910 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of bioriented PP &#34;&#34;&#34;
        return 0, &#34;degC&#34;


# &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; P O L Y V I N Y L S &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

# -- PS (polystyrene) -----------------------------------------------
class PS(layer):
    &#34;&#34;&#34; extended pantankar.layer for polystyrene (PS) &#34;&#34;&#34;
    def __init__(self, l=100e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PS&#34;,**extra):
        &#34;&#34;&#34; PS layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;polystyrene&#34;,
            layercode=&#34;PS&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of PS: ~1050 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1050 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PS &#34;&#34;&#34;
        return 100, &#34;degC&#34;


# -- HIPS (high-impact polystyrene) -----------------------------------
class HIPS(layer):
    &#34;&#34;&#34; extended pantankar.layer for high-impact polystyrene (HIPS) &#34;&#34;&#34;
    def __init__(self, l=100e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in HIPS&#34;,**extra):
        &#34;&#34;&#34; HIPS layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;high-impact polystyrene&#34;,
            layercode=&#34;HIPS&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of HIPS: ~1040 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1040 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of HIPS &#34;&#34;&#34;
        return 95, &#34;degC&#34;


# -- PBS (assuming a styrene-based polymer) ---------------------------
class SBS(layer):
    &#34;&#34;&#34;
    extended pantankar.layer for a styrene-based SBS
    Adjust Tg/density as needed for your scenario.
    &#34;&#34;&#34;
    def __init__(self, l=100e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PBS&#34;,**extra):
        &#34;&#34;&#34; DBS layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;styrene-based polymer SBS&#34;,
            layercode=&#34;SBS&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of &#39;DBS&#39;: approximate, around ~1030 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1030 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of &#39;DBS&#39; &#34;&#34;&#34;
        return 90, &#34;degC&#34;


# -- rigidPVC ---------------------------------------------------------
class rigidPVC(layer):
    &#34;&#34;&#34; extended pantankar.layer for rigid PVC &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in rigid PVC&#34;,**extra):
        &#34;&#34;&#34; rigid PVC layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;rigid PVC&#34;,
            layercode=&#34;PVC&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of rigid PVC: ~1400 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1400 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of rigid PVC &#34;&#34;&#34;
        return 80, &#34;degC&#34;


# -- plasticizedPVC ---------------------------------------------------
class plasticizedPVC(layer):
    &#34;&#34;&#34; extended pantankar.layer for plasticized PVC &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in plasticized PVC&#34;,**extra):
        &#34;&#34;&#34; plasticized PVC layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;plasticized PVC&#34;,
            layercode=&#34;pPVC&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of plasticized PVC: ~1300 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1300 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of plasticized PVC &#34;&#34;&#34;
        return -40, &#34;degC&#34;


# &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; P O L Y E S T E R S &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

# -- gPET (glassy PET, T &lt; 76°C) --------------------------------------
class gPET(layer):
    &#34;&#34;&#34; extended pantankar.layer for PET in its glassy state (below ~76°C) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in gPET&#34;,**extra):
        &#34;&#34;&#34; glassy PET layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;glassy PET&#34;,
            layercode=&#34;PET&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of glassy PET: ~1350 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1350 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; approximate glass transition temperature of PET &#34;&#34;&#34;
        return 76, &#34;degC&#34;


# -- rPET (rubbery PET, T &gt; 76°C) --------------------------------------
class rPET(layer):
    &#34;&#34;&#34; extended pantankar.layer for PET in its rubbery state (above ~76°C) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in rPET&#34;,**extra):
        &#34;&#34;&#34; rubbery PET layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;rubbery PET&#34;,
            layercode=&#34;rPET&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of rubbery PET: ~1350 kg/m^3
        but with a different expansion slope possible, if needed
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1350 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 1e-4), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; approximate glass transition temperature of PET &#34;&#34;&#34;
        return 76, &#34;degC&#34;


# -- PBT --------------------------------------------------------------
class PBT(layer):
    &#34;&#34;&#34; extended pantankar.layer for polybutylene terephthalate (PBT) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PBT&#34;,**extra):
        &#34;&#34;&#34; PBT layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;polybutylene terephthalate&#34;,
            layercode=&#34;PBT&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of PBT: ~1310 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1310 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PBT &#34;&#34;&#34;
        return 40, &#34;degC&#34;


# -- PEN --------------------------------------------------------------
class PEN(layer):
    &#34;&#34;&#34; extended pantankar.layer for polyethylene naphthalate (PEN) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PEN&#34;,**extra):
        &#34;&#34;&#34; PEN layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;polyethylene naphthalate&#34;,
            layercode=&#34;PEN&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of PEN: ~1330 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1330 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PEN &#34;&#34;&#34;
        return 120, &#34;degC&#34;


# &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; P O L Y A M I D E S &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

# -- PA6 --------------------------------------------------------------
class PA6(layer):
    &#34;&#34;&#34; extended pantankar.layer for polyamide 6 (PA6) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PA6&#34;,**extra):
        &#34;&#34;&#34; PA6 layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;polyamide 6&#34;,
            layercode=&#34;PA6&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of PA6: ~1140 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1140 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PA6 &#34;&#34;&#34;
        return 50, &#34;degC&#34;


# -- PA66 -------------------------------------------------------------
class PA66(layer):
    &#34;&#34;&#34; extended pantankar.layer for polyamide 66 (PA66) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PA66&#34;,**extra):
        &#34;&#34;&#34; PA66 layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;polyamide 6,6&#34;,
            layercode=&#34;PA6,6&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of PA66: ~1150 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1150 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PA66 &#34;&#34;&#34;
        return 70, &#34;degC&#34;


# &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; A D H E S I V E S &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

# -- AdhesiveNaturalRubber --------------------------------------------
class AdhesiveNaturalRubber(layer):
    &#34;&#34;&#34; extended pantankar.layer for natural rubber adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive natural rubber&#34;,**extra):
        &#34;&#34;&#34; constructor for a natural rubber-based adhesive layer &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;natural rubber adhesive&#34;,
            layercode=&#34;rubber&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~910 kg/m^3, adjust as needed &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 910 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of natural rubber adhesives &#34;&#34;&#34;
        return -70, &#34;degC&#34;


# -- AdhesiveSyntheticRubber ------------------------------------------
class AdhesiveSyntheticRubber(layer):
    &#34;&#34;&#34; extended pantankar.layer for synthetic rubber adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive synthetic rubber&#34;,**extra):
        &#34;&#34;&#34; constructor for a synthetic rubber-based adhesive layer &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;synthetic rubber adhesive&#34;,
            layercode=&#34;sRubber&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~920 kg/m^3, adjust as needed &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 920 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of synthetic rubber adhesives &#34;&#34;&#34;
        return -50, &#34;degC&#34;


# -- AdhesiveEVA (ethylene-vinyl acetate) ------------------------------
class AdhesiveEVA(layer):
    &#34;&#34;&#34; extended pantankar.layer for EVA-based adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive EVA&#34;,**extra):
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;EVA adhesive&#34;,
            layercode=&#34;EVA&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~930 kg/m^3 &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 930 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of EVA adhesives &#34;&#34;&#34;
        return -30, &#34;degC&#34;


# -- AdhesiveVAE (vinyl acetate-ethylene) -----------------------------
class AdhesiveVAE(layer):
    &#34;&#34;&#34; extended pantankar.layer for VAE adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive VAE&#34;,**extra):
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;VAE adhesive&#34;,
            layercode=&#34;VAE&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~950 kg/m^3 &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 950 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of VAE adhesives &#34;&#34;&#34;
        return 10, &#34;degC&#34;


# -- AdhesivePVAC (polyvinyl acetate) ---------------------------------
class AdhesivePVAC(layer):
    &#34;&#34;&#34; extended pantankar.layer for PVAc adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive PVAc&#34;,**extra):
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;PVAc adhesive&#34;,
            layercode=&#34;PVAc&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~1100 kg/m^3 &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1100 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of PVAc adhesives &#34;&#34;&#34;
        return 35, &#34;degC&#34;


# -- AdhesiveAcrylate -------------------------------------------------
class AdhesiveAcrylate(layer):
    &#34;&#34;&#34; extended pantankar.layer for acrylate adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive acrylate&#34;,**extra):
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;acrylate adhesive&#34;,
            layercode=&#34;Acryl&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~1000 kg/m^3 &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1000 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of acrylate adhesives &#34;&#34;&#34;
        return -20, &#34;degC&#34;


# -- AdhesivePU (polyurethane) ----------------------------------------
class AdhesivePU(layer):
    &#34;&#34;&#34; extended pantankar.layer for polyurethane adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive PU&#34;,**extra):
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;polyurethane adhesive&#34;,
            layercode=&#34;PU&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~1100 kg/m^3 &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1100 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of polyurethane adhesives &#34;&#34;&#34;
        return -50, &#34;degC&#34;


# &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; P A P E R   &amp;   C A R D B O A R D &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

# -- Paper ------------------------------------------------------------
class Paper(layer):
    &#34;&#34;&#34; extended pantankar.layer for paper (cellulose-based) &#34;&#34;&#34;
    def __init__(self, l=80e-6, D=1e-15, T=None,  # a guess for barrier properties
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;paper layer&#34;,**extra):
        &#34;&#34;&#34; Paper layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;paper&#34;,
            layermaterial=&#34;paper&#34;,
            layercode=&#34;paper&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        approximate density for typical paper ~800 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 800 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 1e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34;
        glass transition temperature is not typically used for paper,
        but we provide a placeholder.
        &#34;&#34;&#34;
        return 200, &#34;degC&#34;  # purely illustrative placeholder


# -- Cardboard --------------------------------------------------------
class Cardboard(layer):
    &#34;&#34;&#34; extended pantankar.layer for cardboard (cellulose-based) &#34;&#34;&#34;
    def __init__(self, l=500e-6, D=1e-15, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;cardboard layer&#34;,**extra):
        &#34;&#34;&#34; Cardboard layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;paper&#34;,
            layermaterial=&#34;cardboard&#34;,
            layercode=&#34;board&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        approximate density for typical cardboard ~700 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 700 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 1e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34;
        same placeholder concept for paper-based material
        &#34;&#34;&#34;
        return 200, &#34;degC&#34;





# &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; G A S E S  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

# &lt;-- air | ideal gas layer ----------------------------------&gt;
class air(layer):
    &#34;&#34;&#34;  extended pantankar.layer for ideal gases such as air &#34;&#34;&#34;
    def __init__(self,l=1e-2,D=1e-6,T=None,
                 lunit=None,Dunit=None,Cunit=None,
                 layername=&#34;air layer&#34;,layercode=&#34;air&#34;,**extra):
        &#34;&#34;&#34; air layer constructor &#34;&#34;&#34;
        T = layer._defaults[&#34;T&#34;] if T is None else check_units(T,None,&#34;degC&#34;)[0]
        TK = constants[&#34;T0K&#34;]+T
        kair = 1/(constants[&#34;R&#34;] *TK)
        kairunit = constants[&#34;iRT0Kunit&#34;]
        layer.__init__(self,
                       l=l,D=D,k=kair,C0=0,T=T,
                       lunit=lunit,Dunit=Dunit,kunit=kairunit,Cunit=Cunit,
                       layername=layername,
                       layertype=&#34;air&#34;, # set by default at inititialization
                       layermaterial=&#34;ideal gas&#34;,
                       layercode=&#34;gas&#34;,
                       **extra
                       )

    def density(self, T=None):
        &#34;&#34;&#34;Density of air at atmospheric pressure: density(T in K)&#34;&#34;&#34;
        TK = self.TK if T is None else check_units(T,None,&#34;K&#34;)[0]
        P_atm = 101325  # Pa (1 atm)
        M_air = 28.9647 # g/mol = 0.0289647 kg/mol (Molar mass of dry air).
        return P_atm / ((constants[&#34;R&#34;]/M_air) * TK), &#34;kg/m**3&#34;

# %% For testing and debugging
# ===================================================
# main()
# ===================================================
# for debugging purposes (code called as a script)
# the code is called from here
# ===================================================
if __name__ == &#39;__main__&#39;:
    G = air(T=60)
    P = LDPE(D=1e-8,Dunit=&#39;cm**2/s&#39;)
    P = LDPE(D=(1e-8,&#34;cm**2/s&#34;))
    A = LDPE()
    A=layer(D=1e-14,l=50e-6)
    print(&#34;\n&#34;,repr(A),&#34;\n&#34;*2)
    A
    B=A*3
    D = B[1:2]
    B=A+A
    C=B[1]
    B.l = [1,2]
    A.struct()
    E = B*4
    #E[1:4]=[]
    E
    # ======
    A = layer(layername = &#34;layer A&#34;)
    B = layer(layername = &#34;layer B&#34;)
    C = layer(layername = &#34;layer C&#34;)
    D = layer(layername = &#34;layer D&#34;)
    # test = A+B+C+D
    # test[2] = test[0]
    # test[3] = []
    # test
    test = A+A+B+B+B+C
    print(&#34;\n&#34;,repr(test),&#34;\n&#34;*2)
    testsimple = test.simplify()
    print(&#34;\n&#34;,repr(testsimple),&#34;\n&#34;*2)
    testsimple.mesh()

    # test with substance
    m1 = migrant(name=&#39;limonene&#39;)
    m2 = migrant(name=&#39;anisole&#39;)
    pet_with_limonene = gPET(substance=m1,D=None,T=40,l=(50,&#34;um&#34;))
    PP_with_anisole = PP(substance=m2,D=None,T=40,l=(200,&#34;um&#34;))
    print(&#34;\n&#34;,repr(pet_with_limonene),&#34;\n&#34;*2)

    test = pet_with_limonene + PP_with_anisole
    test.D
    print(&#34;\n&#34;,repr(test),&#34;\n&#34;*2)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="layer.check_units"><code class="name flex">
<span>def <span class="ident">check_units</span></span>(<span>value, ProvidedUnits=None, ExpectedUnits=None, defaulttempUnits='degC')</span>
</code></dt>
<dd>
<div class="desc"><p>check numeric inputs and convert them to SI units</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_units(value,ProvidedUnits=None,ExpectedUnits=None,defaulttempUnits=&#34;degC&#34;):
    &#34;&#34;&#34; check numeric inputs and convert them to SI units &#34;&#34;&#34;
    # by convention, NumPy arrays and None are return unchanged (prevent nesting)
    if isinstance(value,np.ndarray) or value is None:
        return value,UnknownUnits
    if isinstance(value,tuple):
        if len(value) != 2:
            raise ValueError(&#39;value should be a tuple: (value,&#34;unit&#34;&#39;)
        ProvidedUnits = value[1]
        value = value[0]
    if isinstance(value,list): # the function is vectorized
        value = np.array(value)
    if {&#34;degC&#34;, &#34;K&#34;} &amp; {ProvidedUnits, ExpectedUnits}: # the value is a temperature
        ExpectedUnits = defaulttempUnits if ExpectedUnits is None else ExpectedUnits
        ProvidedUnits = ExpectedUnits if ProvidedUnits is None else ProvidedUnits
        if ProvidedUnits==&#34;degC&#34; and ExpectedUnits==&#34;K&#34;:
            value += constants[&#34;T0K&#34;]
        elif ProvidedUnits==&#34;K&#34; and ExpectedUnits==&#34;degC&#34;:
            value -= constants[&#34;T0K&#34;]
        return np.array([value]),ExpectedUnits
    else: # the value is not a temperature
        ExpectedUnits = NoUnits if ExpectedUnits is None else ExpectedUnits
        if (ProvidedUnits==ExpectedUnits) or (ProvidedUnits==NoUnits) or (ExpectedUnits==None):
            conversion =1               # no conversion needed
            units = ExpectedUnits if ExpectedUnits is not None else NoUnits
        else:
            q0,conversion,units = toSI(qSI(1,ProvidedUnits))
        return np.array([value*conversion]),units</code></pre>
</details>
</dd>
<dt id="layer.fixSIbase"><code class="name flex">
<span>def <span class="ident">fixSIbase</span></span>(<span>registry)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the application registry, which is used for unpickling operations
and when invoking pint.Quantity or pint.Unit directly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>registry</code></strong> :&ensp;<code>pint.UnitRegistry</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_application_registry(registry):
    &#34;&#34;&#34;Set the application registry, which is used for unpickling operations
    and when invoking pint.Quantity or pint.Unit directly.

    Parameters
    ----------
    registry : pint.UnitRegistry
    &#34;&#34;&#34;
    application_registry.set(registry)</code></pre>
</details>
</dd>
<dt id="layer.help_layer"><code class="name flex">
<span>def <span class="ident">help_layer</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Print all subclasses with their type/material info in a Markdown table with dynamic column widths.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def help_layer():
    &#34;&#34;&#34;
    Print all subclasses with their type/material info in a Markdown table with dynamic column widths.
    &#34;&#34;&#34;
    derived = list_layer_subclasses()
    # Extract table content
    headers = [&#34;Class Name&#34;, &#34;Type&#34;, &#34;Material&#34;, &#34;Code&#34;]
    rows = [[item[&#34;classname&#34;], item[&#34;type&#34;], item[&#34;material&#34;], item[&#34;code&#34;]] for item in derived]
    # Compute column widths based on content
    col_widths = [max(len(str(cell)) for cell in col) for col in zip(headers, *rows)]
    # Formatting row template
    row_format = &#34;| &#34; + &#34; | &#34;.join(f&#34;{{:&lt;{w}}}&#34; for w in col_widths) + &#34; |&#34;
    # Print header
    print(row_format.format(*headers))
    print(&#34;|-&#34; + &#34;-|-&#34;.join(&#34;-&#34; * w for w in col_widths) + &#34;-|&#34;)

    # Print table rows
    for row in rows:
        print(row_format.format(*row))</code></pre>
</details>
</dd>
<dt id="layer.list_layer_subclasses"><code class="name flex">
<span>def <span class="ident">list_layer_subclasses</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all classes in this module that derive from 'layer',
along with their layertype and layermaterial properties.</p>
<h2 id="returns">Returns</h2>
<p>list of tuples (classname, layertype, layermaterial)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_layer_subclasses():
    &#34;&#34;&#34;
    Lists all classes in this module that derive from &#39;layer&#39;,
    along with their layertype and layermaterial properties.

    Returns:
        list of tuples (classname, layertype, layermaterial)
    &#34;&#34;&#34;
    subclasses_info = []
    current_module = sys.modules[__name__]  # This refers to layer.py itself
    for name, obj in inspect.getmembers(current_module, inspect.isclass):
        # Make sure &#39;obj&#39; is actually a subclass of layer (and not &#39;layer&#39; itself)
        if obj is not layer and issubclass(obj, layer):
            try:
                # Instantiate with default parameters so that .layertype / .layermaterial are accessible
                instance = obj()
                subclasses_info.append(
                    {&#34;classname&#34;:name,
                     &#34;type&#34;:instance._type[0],
                     &#34;material&#34;:instance._material[0],
                     &#34;code&#34;:instance._code[0]}
                )
            except TypeError as e:
                # Log error and rethrow for debugging
                print(f&#34;⚠️ Error: Could not instantiate class &#39;{name}&#39;. Check its constructor.&#34;)
                print(f&#34;🔍 Exception: {e}&#34;)
                raise  # Rethrow the error with full traceback
    return subclasses_info</code></pre>
</details>
</dd>
<dt id="layer.toSI"><code class="name flex">
<span>def <span class="ident">toSI</span></span>(<span>q)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toSI(q): q=q.to_base_units(); return q,q.m,str(q.u)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="layer.AdhesiveAcrylate"><code class="flex name class">
<span>class <span class="ident">AdhesiveAcrylate</span></span>
<span>(</span><span>l=2e-05, D=1e-13, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='adhesive acrylate', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for acrylate adhesives </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layername</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Name. The default is "my layer".</dd>
<dt><strong><code>layertype</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Type. The default is "unknown type".</dd>
<dt><strong><code>layermaterial</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Material identification . The default is "unknown material".</dd>
<dt>PHYSICAL QUANTITIES</dt>
<dt><strong><code>l</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Thickness. The default is 50e-6 (m).</dd>
<dt><strong><code>D</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).</dd>
<dt><strong><code>C0</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Initial concentration. The default is 1000 (a.u.).</dd>
<dt>PHYSICAL UNITS</dt>
<dt><strong><code>lunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Length units. The default unit is "m.</dd>
<dt><strong><code>Dunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Diffusivity units. The default unit is 1e-14 "m^2/s".</dd>
<dt><strong><code>kunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default unit is "a.u.".</dd>
<dt><strong><code>Cunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Initial concentration. The default unit is "a.u.".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>a monolayer object which can be assembled into a multilayer structure</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdhesiveAcrylate(layer):
    &#34;&#34;&#34; extended pantankar.layer for acrylate adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive acrylate&#34;,**extra):
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;acrylate adhesive&#34;,
            layercode=&#34;Acryl&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~1000 kg/m^3 &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1000 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of acrylate adhesives &#34;&#34;&#34;
        return -20, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.AdhesiveAcrylate.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>approximate Tg of acrylate adhesives</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; approximate Tg of acrylate adhesives &#34;&#34;&#34;
    return -20, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.AdhesiveAcrylate.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>typical density ~1000 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34; typical density ~1000 kg/m^3 &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1000 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.AdhesiveEVA"><code class="flex name class">
<span>class <span class="ident">AdhesiveEVA</span></span>
<span>(</span><span>l=2e-05, D=1e-13, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='adhesive EVA', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for EVA-based adhesives </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layername</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Name. The default is "my layer".</dd>
<dt><strong><code>layertype</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Type. The default is "unknown type".</dd>
<dt><strong><code>layermaterial</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Material identification . The default is "unknown material".</dd>
<dt>PHYSICAL QUANTITIES</dt>
<dt><strong><code>l</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Thickness. The default is 50e-6 (m).</dd>
<dt><strong><code>D</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).</dd>
<dt><strong><code>C0</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Initial concentration. The default is 1000 (a.u.).</dd>
<dt>PHYSICAL UNITS</dt>
<dt><strong><code>lunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Length units. The default unit is "m.</dd>
<dt><strong><code>Dunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Diffusivity units. The default unit is 1e-14 "m^2/s".</dd>
<dt><strong><code>kunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default unit is "a.u.".</dd>
<dt><strong><code>Cunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Initial concentration. The default unit is "a.u.".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>a monolayer object which can be assembled into a multilayer structure</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdhesiveEVA(layer):
    &#34;&#34;&#34; extended pantankar.layer for EVA-based adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive EVA&#34;,**extra):
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;EVA adhesive&#34;,
            layercode=&#34;EVA&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~930 kg/m^3 &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 930 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of EVA adhesives &#34;&#34;&#34;
        return -30, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.AdhesiveEVA.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>approximate Tg of EVA adhesives</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; approximate Tg of EVA adhesives &#34;&#34;&#34;
    return -30, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.AdhesiveEVA.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>typical density ~930 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34; typical density ~930 kg/m^3 &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 930 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.AdhesiveNaturalRubber"><code class="flex name class">
<span>class <span class="ident">AdhesiveNaturalRubber</span></span>
<span>(</span><span>l=2e-05, D=1e-13, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='adhesive natural rubber', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for natural rubber adhesives </p>
<p>constructor for a natural rubber-based adhesive layer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdhesiveNaturalRubber(layer):
    &#34;&#34;&#34; extended pantankar.layer for natural rubber adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive natural rubber&#34;,**extra):
        &#34;&#34;&#34; constructor for a natural rubber-based adhesive layer &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;natural rubber adhesive&#34;,
            layercode=&#34;rubber&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~910 kg/m^3, adjust as needed &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 910 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of natural rubber adhesives &#34;&#34;&#34;
        return -70, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.AdhesiveNaturalRubber.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>approximate Tg of natural rubber adhesives</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; approximate Tg of natural rubber adhesives &#34;&#34;&#34;
    return -70, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.AdhesiveNaturalRubber.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>typical density ~910 kg/m^3, adjust as needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34; typical density ~910 kg/m^3, adjust as needed &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 910 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.AdhesivePU"><code class="flex name class">
<span>class <span class="ident">AdhesivePU</span></span>
<span>(</span><span>l=2e-05, D=1e-13, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='adhesive PU', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for polyurethane adhesives </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layername</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Name. The default is "my layer".</dd>
<dt><strong><code>layertype</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Type. The default is "unknown type".</dd>
<dt><strong><code>layermaterial</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Material identification . The default is "unknown material".</dd>
<dt>PHYSICAL QUANTITIES</dt>
<dt><strong><code>l</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Thickness. The default is 50e-6 (m).</dd>
<dt><strong><code>D</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).</dd>
<dt><strong><code>C0</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Initial concentration. The default is 1000 (a.u.).</dd>
<dt>PHYSICAL UNITS</dt>
<dt><strong><code>lunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Length units. The default unit is "m.</dd>
<dt><strong><code>Dunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Diffusivity units. The default unit is 1e-14 "m^2/s".</dd>
<dt><strong><code>kunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default unit is "a.u.".</dd>
<dt><strong><code>Cunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Initial concentration. The default unit is "a.u.".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>a monolayer object which can be assembled into a multilayer structure</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdhesivePU(layer):
    &#34;&#34;&#34; extended pantankar.layer for polyurethane adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive PU&#34;,**extra):
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;polyurethane adhesive&#34;,
            layercode=&#34;PU&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~1100 kg/m^3 &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1100 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of polyurethane adhesives &#34;&#34;&#34;
        return -50, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.AdhesivePU.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>approximate Tg of polyurethane adhesives</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; approximate Tg of polyurethane adhesives &#34;&#34;&#34;
    return -50, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.AdhesivePU.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>typical density ~1100 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34; typical density ~1100 kg/m^3 &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1100 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.AdhesivePVAC"><code class="flex name class">
<span>class <span class="ident">AdhesivePVAC</span></span>
<span>(</span><span>l=2e-05, D=1e-13, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='adhesive PVAc', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for PVAc adhesives </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layername</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Name. The default is "my layer".</dd>
<dt><strong><code>layertype</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Type. The default is "unknown type".</dd>
<dt><strong><code>layermaterial</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Material identification . The default is "unknown material".</dd>
<dt>PHYSICAL QUANTITIES</dt>
<dt><strong><code>l</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Thickness. The default is 50e-6 (m).</dd>
<dt><strong><code>D</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).</dd>
<dt><strong><code>C0</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Initial concentration. The default is 1000 (a.u.).</dd>
<dt>PHYSICAL UNITS</dt>
<dt><strong><code>lunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Length units. The default unit is "m.</dd>
<dt><strong><code>Dunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Diffusivity units. The default unit is 1e-14 "m^2/s".</dd>
<dt><strong><code>kunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default unit is "a.u.".</dd>
<dt><strong><code>Cunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Initial concentration. The default unit is "a.u.".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>a monolayer object which can be assembled into a multilayer structure</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdhesivePVAC(layer):
    &#34;&#34;&#34; extended pantankar.layer for PVAc adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive PVAc&#34;,**extra):
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;PVAc adhesive&#34;,
            layercode=&#34;PVAc&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~1100 kg/m^3 &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1100 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of PVAc adhesives &#34;&#34;&#34;
        return 35, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.AdhesivePVAC.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>approximate Tg of PVAc adhesives</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; approximate Tg of PVAc adhesives &#34;&#34;&#34;
    return 35, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.AdhesivePVAC.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>typical density ~1100 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34; typical density ~1100 kg/m^3 &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1100 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.AdhesiveSyntheticRubber"><code class="flex name class">
<span>class <span class="ident">AdhesiveSyntheticRubber</span></span>
<span>(</span><span>l=2e-05, D=1e-13, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='adhesive synthetic rubber', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for synthetic rubber adhesives </p>
<p>constructor for a synthetic rubber-based adhesive layer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdhesiveSyntheticRubber(layer):
    &#34;&#34;&#34; extended pantankar.layer for synthetic rubber adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive synthetic rubber&#34;,**extra):
        &#34;&#34;&#34; constructor for a synthetic rubber-based adhesive layer &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;synthetic rubber adhesive&#34;,
            layercode=&#34;sRubber&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~920 kg/m^3, adjust as needed &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 920 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of synthetic rubber adhesives &#34;&#34;&#34;
        return -50, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.AdhesiveSyntheticRubber.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>approximate Tg of synthetic rubber adhesives</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; approximate Tg of synthetic rubber adhesives &#34;&#34;&#34;
    return -50, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.AdhesiveSyntheticRubber.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>typical density ~920 kg/m^3, adjust as needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34; typical density ~920 kg/m^3, adjust as needed &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 920 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.AdhesiveVAE"><code class="flex name class">
<span>class <span class="ident">AdhesiveVAE</span></span>
<span>(</span><span>l=2e-05, D=1e-13, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='adhesive VAE', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for VAE adhesives </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layername</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Name. The default is "my layer".</dd>
<dt><strong><code>layertype</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Type. The default is "unknown type".</dd>
<dt><strong><code>layermaterial</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Material identification . The default is "unknown material".</dd>
<dt>PHYSICAL QUANTITIES</dt>
<dt><strong><code>l</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Thickness. The default is 50e-6 (m).</dd>
<dt><strong><code>D</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).</dd>
<dt><strong><code>C0</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Initial concentration. The default is 1000 (a.u.).</dd>
<dt>PHYSICAL UNITS</dt>
<dt><strong><code>lunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Length units. The default unit is "m.</dd>
<dt><strong><code>Dunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Diffusivity units. The default unit is 1e-14 "m^2/s".</dd>
<dt><strong><code>kunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default unit is "a.u.".</dd>
<dt><strong><code>Cunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Initial concentration. The default unit is "a.u.".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>a monolayer object which can be assembled into a multilayer structure</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AdhesiveVAE(layer):
    &#34;&#34;&#34; extended pantankar.layer for VAE adhesives &#34;&#34;&#34;
    def __init__(self, l=20e-6, D=1e-13, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;adhesive VAE&#34;,**extra):
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;adhesive&#34;,
            layermaterial=&#34;VAE adhesive&#34;,
            layercode=&#34;VAE&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34; typical density ~950 kg/m^3 &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 950 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34; approximate Tg of VAE adhesives &#34;&#34;&#34;
        return 10, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.AdhesiveVAE.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>approximate Tg of VAE adhesives</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; approximate Tg of VAE adhesives &#34;&#34;&#34;
    return 10, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.AdhesiveVAE.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>typical density ~950 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34; typical density ~950 kg/m^3 &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 950 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.Cardboard"><code class="flex name class">
<span>class <span class="ident">Cardboard</span></span>
<span>(</span><span>l=0.0005, D=1e-15, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='cardboard layer', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for cardboard (cellulose-based) </p>
<p>Cardboard layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cardboard(layer):
    &#34;&#34;&#34; extended pantankar.layer for cardboard (cellulose-based) &#34;&#34;&#34;
    def __init__(self, l=500e-6, D=1e-15, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;cardboard layer&#34;,**extra):
        &#34;&#34;&#34; Cardboard layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;paper&#34;,
            layermaterial=&#34;cardboard&#34;,
            layercode=&#34;board&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        approximate density for typical cardboard ~700 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 700 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 1e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34;
        same placeholder concept for paper-based material
        &#34;&#34;&#34;
        return 200, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.Cardboard.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>same placeholder concept for paper-based material</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34;
    same placeholder concept for paper-based material
    &#34;&#34;&#34;
    return 200, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.Cardboard.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>approximate density for typical cardboard ~700 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    approximate density for typical cardboard ~700 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 700 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 1e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.HDPE"><code class="flex name class">
<span>class <span class="ident">HDPE</span></span>
<span>(</span><span>l=0.0005, D=1e-13, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in HDPE', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for high-density polyethylene HDPE
</p>
<p>HDPE layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HDPE(layer):
    &#34;&#34;&#34;  extended pantankar.layer for high-density polyethylene HDPE  &#34;&#34;&#34;
    def __init__(self,l=500e-6,D=1e-13, T=None,
                 k=None,C0=None,lunit=None,Dunit=None,kunit=None,Cunit=None,
                 layername=&#34;layer in HDPE&#34;,**extra):
        &#34;&#34;&#34; HDPE layer constructor &#34;&#34;&#34;
        layer.__init__(self,
                       l=l,D=D,k=k,C0=C0, T=T,
                       lunit=lunit,Dunit=Dunit,kunit=kunit,Cunit=Cunit,
                       layername=layername,
                       layertype=&#34;polymer&#34;, # set by default at inititialization
                       layermaterial=&#34;high-density polyethylene&#34;,
                       layercode=&#34;HDPE&#34;,
                       **extra
                       )
    def density(self,T=None):
        &#34;&#34;&#34; density of HDPE: density(T in K) &#34;&#34;&#34;
        T = self.T if T is None else check_units(T,None,&#34;degC&#34;)[0]
        return 940 *(1-3*(T-layer._defaults[&#34;Td&#34;])*11e-5),&#34;kg/m**3&#34; # lowest temperature
    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of HDPE &#34;&#34;&#34;
        return -100,&#34;degC&#34; # highest temperature</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.HDPE.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of HDPE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of HDPE &#34;&#34;&#34;
    return -100,&#34;degC&#34; # highest temperature</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.HDPE.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of HDPE: density(T in K)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self,T=None):
    &#34;&#34;&#34; density of HDPE: density(T in K) &#34;&#34;&#34;
    T = self.T if T is None else check_units(T,None,&#34;degC&#34;)[0]
    return 940 *(1-3*(T-layer._defaults[&#34;Td&#34;])*11e-5),&#34;kg/m**3&#34; # lowest temperature</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.HIPS"><code class="flex name class">
<span>class <span class="ident">HIPS</span></span>
<span>(</span><span>l=0.0001, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in HIPS', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for high-impact polystyrene (HIPS) </p>
<p>HIPS layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HIPS(layer):
    &#34;&#34;&#34; extended pantankar.layer for high-impact polystyrene (HIPS) &#34;&#34;&#34;
    def __init__(self, l=100e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in HIPS&#34;,**extra):
        &#34;&#34;&#34; HIPS layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;high-impact polystyrene&#34;,
            layercode=&#34;HIPS&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of HIPS: ~1040 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1040 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of HIPS &#34;&#34;&#34;
        return 95, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.HIPS.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of HIPS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of HIPS &#34;&#34;&#34;
    return 95, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.HIPS.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of HIPS: ~1040 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of HIPS: ~1040 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1040 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.LDPE"><code class="flex name class">
<span>class <span class="ident">LDPE</span></span>
<span>(</span><span>l=0.0001, D=1e-12, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in LDPE', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for low-density polyethylene LDPE
</p>
<p>LDPE layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LDPE(layer):
    &#34;&#34;&#34;  extended pantankar.layer for low-density polyethylene LDPE  &#34;&#34;&#34;
    def __init__(self,l=100e-6,D=1e-12,T=None,
                 k=None,C0=None,lunit=None,Dunit=None,kunit=None,Cunit=None,
                 layername=&#34;layer in LDPE&#34;,**extra):
        &#34;&#34;&#34; LDPE layer constructor &#34;&#34;&#34;
        super().__init__(
                       l=l,D=D,k=k,C0=C0, T=T,
                       lunit=lunit,Dunit=Dunit,kunit=kunit,Cunit=Cunit,
                       layername=layername,
                       layertype=&#34;polymer&#34;, # set by default at inititialization
                       layermaterial=&#34;low-density polyethylene&#34;,
                       layercode=&#34;LDPE&#34;,
                       **extra
                       )
    def density(self,T=None):
        &#34;&#34;&#34; density of LDPE: density(T in K) &#34;&#34;&#34;
        T = self.T if T is None else check_units(T,None,&#34;degC&#34;)[0]
        return 920 *(1-3*(T-layer._defaults[&#34;Td&#34;])*20e-5),&#34;kg/m**3&#34; # lowest temperature
    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of LDPE &#34;&#34;&#34;
        return -130,&#34;degC&#34; # lowest temperature</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.LDPE.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of LDPE</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of LDPE &#34;&#34;&#34;
    return -130,&#34;degC&#34; # lowest temperature</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.LDPE.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of LDPE: density(T in K)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self,T=None):
    &#34;&#34;&#34; density of LDPE: density(T in K) &#34;&#34;&#34;
    T = self.T if T is None else check_units(T,None,&#34;degC&#34;)[0]
    return 920 *(1-3*(T-layer._defaults[&#34;Td&#34;])*20e-5),&#34;kg/m**3&#34; # lowest temperature</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.LLDPE"><code class="flex name class">
<span>class <span class="ident">LLDPE</span></span>
<span>(</span><span>l=8e-05, D=1e-12, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in LLDPE', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for linear low-density polyethylene LLDPE </p>
<p>LLDPE layer constructor
Defaults are set to typical values found in the literature or between
LDPE/HDPE ones. Adjust them as necessary for your models.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LLDPE(layer):
    &#34;&#34;&#34; extended pantankar.layer for linear low-density polyethylene LLDPE &#34;&#34;&#34;
    def __init__(self, l=80e-6, D=1e-12, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in LLDPE&#34;,**extra):
        &#34;&#34;&#34;
        LLDPE layer constructor
        Defaults are set to typical values found in the literature or between
        LDPE/HDPE ones. Adjust them as necessary for your models.
        &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;linear low-density polyethylene&#34;,
            layercode=&#34;LLDPE&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of LLDPE: density(T in K)
        By default, uses an approximate value between LDPE and HDPE.
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        # Similar formula to LDPE and HDPE, with a coefficient suitable for LLDPE.
        return 915 * (1 - 3 * (T - layer._defaults[&#34;Td&#34;]) * 15e-5), &#34;kg/m**3&#34;
    @property
    def Tg(self):
        &#34;&#34;&#34;
        glass transition temperature of LLDPE
        Typically close to LDPE, though slightly higher or lower can be found in the literature.
        &#34;&#34;&#34;
        return -120, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.LLDPE.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of LLDPE
Typically close to LDPE, though slightly higher or lower can be found in the literature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34;
    glass transition temperature of LLDPE
    Typically close to LDPE, though slightly higher or lower can be found in the literature.
    &#34;&#34;&#34;
    return -120, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.LLDPE.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of LLDPE: density(T in K)
By default, uses an approximate value between LDPE and HDPE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of LLDPE: density(T in K)
    By default, uses an approximate value between LDPE and HDPE.
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    # Similar formula to LDPE and HDPE, with a coefficient suitable for LLDPE.
    return 915 * (1 - 3 * (T - layer._defaults[&#34;Td&#34;]) * 15e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.PA6"><code class="flex name class">
<span>class <span class="ident">PA6</span></span>
<span>(</span><span>l=0.0002, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in PA6', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for polyamide 6 (PA6) </p>
<p>PA6 layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PA6(layer):
    &#34;&#34;&#34; extended pantankar.layer for polyamide 6 (PA6) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PA6&#34;,**extra):
        &#34;&#34;&#34; PA6 layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;polyamide 6&#34;,
            layercode=&#34;PA6&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of PA6: ~1140 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1140 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PA6 &#34;&#34;&#34;
        return 50, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.PA6.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of PA6</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of PA6 &#34;&#34;&#34;
    return 50, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.PA6.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of PA6: ~1140 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of PA6: ~1140 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1140 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.PA66"><code class="flex name class">
<span>class <span class="ident">PA66</span></span>
<span>(</span><span>l=0.0002, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in PA66', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for polyamide 66 (PA66) </p>
<p>PA66 layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PA66(layer):
    &#34;&#34;&#34; extended pantankar.layer for polyamide 66 (PA66) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PA66&#34;,**extra):
        &#34;&#34;&#34; PA66 layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;polyamide 6,6&#34;,
            layercode=&#34;PA6,6&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of PA66: ~1150 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1150 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PA66 &#34;&#34;&#34;
        return 70, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.PA66.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of PA66</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of PA66 &#34;&#34;&#34;
    return 70, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.PA66.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of PA66: ~1150 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of PA66: ~1150 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1150 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.PBT"><code class="flex name class">
<span>class <span class="ident">PBT</span></span>
<span>(</span><span>l=0.0002, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in PBT', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for polybutylene terephthalate (PBT) </p>
<p>PBT layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PBT(layer):
    &#34;&#34;&#34; extended pantankar.layer for polybutylene terephthalate (PBT) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PBT&#34;,**extra):
        &#34;&#34;&#34; PBT layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;polybutylene terephthalate&#34;,
            layercode=&#34;PBT&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of PBT: ~1310 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1310 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PBT &#34;&#34;&#34;
        return 40, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.PBT.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of PBT</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of PBT &#34;&#34;&#34;
    return 40, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.PBT.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of PBT: ~1310 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of PBT: ~1310 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1310 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.PEN"><code class="flex name class">
<span>class <span class="ident">PEN</span></span>
<span>(</span><span>l=0.0002, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in PEN', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for polyethylene naphthalate (PEN) </p>
<p>PEN layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PEN(layer):
    &#34;&#34;&#34; extended pantankar.layer for polyethylene naphthalate (PEN) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PEN&#34;,**extra):
        &#34;&#34;&#34; PEN layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;polyethylene naphthalate&#34;,
            layercode=&#34;PEN&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of PEN: ~1330 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1330 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PEN &#34;&#34;&#34;
        return 120, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.PEN.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of PEN</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of PEN &#34;&#34;&#34;
    return 120, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.PEN.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of PEN: ~1330 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of PEN: ~1330 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1330 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.PP"><code class="flex name class">
<span>class <span class="ident">PP</span></span>
<span>(</span><span>l=0.0003, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in PP', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for isotactic polypropylene PP
</p>
<p>PP layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PP(layer):
    &#34;&#34;&#34;  extended pantankar.layer for isotactic polypropylene PP  &#34;&#34;&#34;
    def __init__(self,l=300e-6,D=1e-14, T=None,
                 k=None,C0=None,lunit=None,Dunit=None,kunit=None,Cunit=None,
                 layername=&#34;layer in PP&#34;,**extra):
        &#34;&#34;&#34; PP layer constructor &#34;&#34;&#34;
        layer.__init__(self,
                       l=l,D=D,k=k,C0=C0, T=T,
                       lunit=lunit,Dunit=Dunit,kunit=kunit,Cunit=Cunit,
                       layername=layername,
                       layertype=&#34;polymer&#34;, # set by default at inititialization
                       layermaterial=&#34;isotactic polypropylene&#34;,
                       layercode=&#34;PP&#34;,
                       **extra
                       )
    def density(self,T=None):
        &#34;&#34;&#34; density of PP: density(T in K) &#34;&#34;&#34;
        T = self.T if T is None else check_units(T,None,&#34;degC&#34;)[0]
        return 910 *(1-3*(T-layer._defaults[&#34;Td&#34;])*7e-5),&#34;kg/m**3&#34; # lowest temperature
    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PP &#34;&#34;&#34;
        return 0,&#34;degC&#34; # highest temperature</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.PP.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of PP</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of PP &#34;&#34;&#34;
    return 0,&#34;degC&#34; # highest temperature</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.PP.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of PP: density(T in K)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self,T=None):
    &#34;&#34;&#34; density of PP: density(T in K) &#34;&#34;&#34;
    T = self.T if T is None else check_units(T,None,&#34;degC&#34;)[0]
    return 910 *(1-3*(T-layer._defaults[&#34;Td&#34;])*7e-5),&#34;kg/m**3&#34; # lowest temperature</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.PPrubber"><code class="flex name class">
<span>class <span class="ident">PPrubber</span></span>
<span>(</span><span>l=0.0001, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in PPrubber', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for atactic (rubbery) polypropylene PP </p>
<p>PPrubber layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PPrubber(layer):
    &#34;&#34;&#34; extended pantankar.layer for atactic (rubbery) polypropylene PP &#34;&#34;&#34;
    def __init__(self, l=100e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PPrubber&#34;,**extra):
        &#34;&#34;&#34; PPrubber layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;atactic polypropylene&#34;,
            layercode=&#34;aPP&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of atactic (rubbery) PP: density(T in K)
        Approximate initial density ~900 kg/m^3, linear thermal expansion factor
        can be adjusted.
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 900 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of atactic/rubbery PP &#34;&#34;&#34;
        return -20, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.PPrubber.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of atactic/rubbery PP</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of atactic/rubbery PP &#34;&#34;&#34;
    return -20, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.PPrubber.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of atactic (rubbery) PP: density(T in K)
Approximate initial density ~900 kg/m^3, linear thermal expansion factor
can be adjusted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of atactic (rubbery) PP: density(T in K)
    Approximate initial density ~900 kg/m^3, linear thermal expansion factor
    can be adjusted.
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 900 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.PS"><code class="flex name class">
<span>class <span class="ident">PS</span></span>
<span>(</span><span>l=0.0001, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in PS', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for polystyrene (PS) </p>
<p>PS layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PS(layer):
    &#34;&#34;&#34; extended pantankar.layer for polystyrene (PS) &#34;&#34;&#34;
    def __init__(self, l=100e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PS&#34;,**extra):
        &#34;&#34;&#34; PS layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;polystyrene&#34;,
            layercode=&#34;PS&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of PS: ~1050 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1050 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of PS &#34;&#34;&#34;
        return 100, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.PS.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of PS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of PS &#34;&#34;&#34;
    return 100, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.PS.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of PS: ~1050 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of PS: ~1050 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1050 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.Paper"><code class="flex name class">
<span>class <span class="ident">Paper</span></span>
<span>(</span><span>l=8e-05, D=1e-15, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='paper layer', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for paper (cellulose-based) </p>
<p>Paper layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Paper(layer):
    &#34;&#34;&#34; extended pantankar.layer for paper (cellulose-based) &#34;&#34;&#34;
    def __init__(self, l=80e-6, D=1e-15, T=None,  # a guess for barrier properties
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;paper layer&#34;,**extra):
        &#34;&#34;&#34; Paper layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;paper&#34;,
            layermaterial=&#34;paper&#34;,
            layercode=&#34;paper&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        approximate density for typical paper ~800 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 800 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 1e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34;
        glass transition temperature is not typically used for paper,
        but we provide a placeholder.
        &#34;&#34;&#34;
        return 200, &#34;degC&#34;  # purely illustrative placeholder</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.Paper.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature is not typically used for paper,
but we provide a placeholder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34;
    glass transition temperature is not typically used for paper,
    but we provide a placeholder.
    &#34;&#34;&#34;
    return 200, &#34;degC&#34;  # purely illustrative placeholder</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.Paper.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>approximate density for typical paper ~800 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    approximate density for typical paper ~800 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 800 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 1e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.SBS"><code class="flex name class">
<span>class <span class="ident">SBS</span></span>
<span>(</span><span>l=0.0001, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in PBS', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for a styrene-based SBS
Adjust Tg/density as needed for your scenario.</p>
<p>DBS layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SBS(layer):
    &#34;&#34;&#34;
    extended pantankar.layer for a styrene-based SBS
    Adjust Tg/density as needed for your scenario.
    &#34;&#34;&#34;
    def __init__(self, l=100e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in PBS&#34;,**extra):
        &#34;&#34;&#34; DBS layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;styrene-based polymer SBS&#34;,
            layercode=&#34;SBS&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of &#39;DBS&#39;: approximate, around ~1030 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1030 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of &#39;DBS&#39; &#34;&#34;&#34;
        return 90, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.SBS.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of 'DBS'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of &#39;DBS&#39; &#34;&#34;&#34;
    return 90, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.SBS.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of 'DBS': approximate, around ~1030 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of &#39;DBS&#39;: approximate, around ~1030 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1030 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.UnitRegistry"><code class="flex name class">
<span>class <span class="ident">SIbase</span></span>
<span>(</span><span>filename='', force_ndarray: bool = False, force_ndarray_like: bool = False, default_as_delta: bool = True, autoconvert_offset_to_baseunit: bool = False, on_redefinition: str = 'warn', system=None, auto_reduce_dimensions=False, preprocessors=None, fmt_locale=None, non_int_type=builtins.float, case_sensitive: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>The unit registry stores the definitions and relationships between units.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>filename :</dt>
<dt>path of the units definition file to load or line-iterable object.</dt>
<dt>Empty to load the default definition file.</dt>
<dt>None to leave the UnitRegistry empty.</dt>
<dt><strong><code>force_ndarray</code></strong> :&ensp;<code>bool</code></dt>
<dd>convert any input, scalar or not to a numpy.ndarray.</dd>
<dt><strong><code>force_ndarray_like</code></strong> :&ensp;<code>bool</code></dt>
<dd>convert all inputs other than duck arrays to a numpy.ndarray.</dd>
<dt>default_as_delta :</dt>
<dt>In the context of a multiplication of units, interpret</dt>
<dt>non-multiplicative units as their <em>delta</em> counterparts.</dt>
<dt>autoconvert_offset_to_baseunit :</dt>
<dt>If True converts offset units in quantities are</dt>
<dt>converted to their base units in multiplicative</dt>
<dt>context. If False no conversion happens.</dt>
<dt><strong><code>on_redefinition</code></strong> :&ensp;<code>str</code></dt>
<dd>action to take in case a unit is redefined.
'warn', 'raise', 'ignore'</dd>
<dt>auto_reduce_dimensions :</dt>
<dt>If True, reduce dimensionality on appropriate operations.</dt>
<dt>preprocessors :</dt>
<dt>list of callables which are iteratively ran on any input expression</dt>
<dt>or unit string</dt>
<dt>fmt_locale :</dt>
<dt>locale identifier string, used in <code>format_babel</code>. Default to None</dt>
<dt><strong><code>case_sensitive</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Control default case sensitivity of unit parsing. (Default: True)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnitRegistry(SystemRegistry, ContextRegistry, NonMultiplicativeRegistry):
    &#34;&#34;&#34;The unit registry stores the definitions and relationships between units.

    Parameters
    ----------
    filename :
        path of the units definition file to load or line-iterable object.
        Empty to load the default definition file.
        None to leave the UnitRegistry empty.
    force_ndarray : bool
        convert any input, scalar or not to a numpy.ndarray.
    force_ndarray_like : bool
        convert all inputs other than duck arrays to a numpy.ndarray.
    default_as_delta :
        In the context of a multiplication of units, interpret
        non-multiplicative units as their *delta* counterparts.
    autoconvert_offset_to_baseunit :
        If True converts offset units in quantities are
        converted to their base units in multiplicative
        context. If False no conversion happens.
    on_redefinition : str
        action to take in case a unit is redefined.
        &#39;warn&#39;, &#39;raise&#39;, &#39;ignore&#39;
    auto_reduce_dimensions :
        If True, reduce dimensionality on appropriate operations.
    preprocessors :
        list of callables which are iteratively ran on any input expression
        or unit string
    fmt_locale :
        locale identifier string, used in `format_babel`. Default to None
    case_sensitive : bool, optional
        Control default case sensitivity of unit parsing. (Default: True)
    &#34;&#34;&#34;

    def __init__(
        self,
        filename=&#34;&#34;,
        force_ndarray: bool = False,
        force_ndarray_like: bool = False,
        default_as_delta: bool = True,
        autoconvert_offset_to_baseunit: bool = False,
        on_redefinition: str = &#34;warn&#34;,
        system=None,
        auto_reduce_dimensions=False,
        preprocessors=None,
        fmt_locale=None,
        non_int_type=float,
        case_sensitive: bool = True,
    ):

        super().__init__(
            filename=filename,
            force_ndarray=force_ndarray,
            force_ndarray_like=force_ndarray_like,
            on_redefinition=on_redefinition,
            default_as_delta=default_as_delta,
            autoconvert_offset_to_baseunit=autoconvert_offset_to_baseunit,
            system=system,
            auto_reduce_dimensions=auto_reduce_dimensions,
            preprocessors=preprocessors,
            fmt_locale=fmt_locale,
            non_int_type=non_int_type,
            case_sensitive=case_sensitive,
        )

    def pi_theorem(self, quantities):
        &#34;&#34;&#34;Builds dimensionless quantities using the Buckingham π theorem

        Parameters
        ----------
        quantities : dict
            mapping between variable name and units

        Returns
        -------
        list
            a list of dimensionless quantities expressed as dicts

        &#34;&#34;&#34;
        return pi_theorem(quantities, self)

    def setup_matplotlib(self, enable: bool = True) -&gt; None:
        &#34;&#34;&#34;Set up handlers for matplotlib&#39;s unit support.

        Parameters
        ----------
        enable : bool
            whether support should be enabled or disabled (Default value = True)

        &#34;&#34;&#34;
        # Delays importing matplotlib until it&#39;s actually requested
        from .matplotlib import setup_matplotlib_handlers

        setup_matplotlib_handlers(self, enable)

    wraps = registry_helpers.wraps

    check = registry_helpers.check</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>patankar.private.pint.registry.SystemRegistry</li>
<li>patankar.private.pint.registry.ContextRegistry</li>
<li>patankar.private.pint.registry.NonMultiplicativeRegistry</li>
<li>patankar.private.pint.registry.BaseRegistry</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="layer.UnitRegistry.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>ureg: <a title="layer.UnitRegistry" href="#layer.UnitRegistry">UnitRegistry</a>, *args: Union[str, patankar.private.pint.util.UnitsContainer, ForwardRef('Unit'), NoneType]) ‑> Callable[[~F], ~F]</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to for quantity type checking for function inputs.</p>
<p>Use it to ensure that the decorated function input parameters match
the expected dimension of pint quantity.</p>
<p>The wrapper function raises:
- <code>pint.DimensionalityError</code> if an argument doesn't match the required dimensions.</p>
<p>ureg : UnitRegistry
a UnitRegistry instance.
args : str or UnitContainer or None
Dimensions of each of the input arguments.
Use <code>None</code> to skip argument conversion.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>callable</code></dt>
<dd>the wrapped function.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If the number of given dimensions does not match the number of function
parameters.</dd>
<dt><code>ValueError</code></dt>
<dd>If the any of the provided dimensions cannot be parsed as a dimension.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(
    ureg: &#34;UnitRegistry&#34;, *args: Union[str, UnitsContainer, &#34;Unit&#34;, None]
) -&gt; Callable[[F], F]:
    &#34;&#34;&#34;Decorator to for quantity type checking for function inputs.

    Use it to ensure that the decorated function input parameters match
    the expected dimension of pint quantity.

    The wrapper function raises:
      - `pint.DimensionalityError` if an argument doesn&#39;t match the required dimensions.

    ureg : UnitRegistry
        a UnitRegistry instance.
    args : str or UnitContainer or None
        Dimensions of each of the input arguments.
        Use `None` to skip argument conversion.

    Returns
    -------
    callable
        the wrapped function.

    Raises
    ------
    TypeError
        If the number of given dimensions does not match the number of function
        parameters.
    ValueError
        If the any of the provided dimensions cannot be parsed as a dimension.
    &#34;&#34;&#34;
    dimensions = [
        ureg.get_dimensionality(dim) if dim is not None else None for dim in args
    ]

    def decorator(func):

        count_params = len(signature(func).parameters)
        if len(dimensions) != count_params:
            raise TypeError(
                &#34;%s takes %i parameters, but %i dimensions were passed&#34;
                % (func.__name__, count_params, len(dimensions))
            )

        assigned = tuple(
            attr for attr in functools.WRAPPER_ASSIGNMENTS if hasattr(func, attr)
        )
        updated = tuple(
            attr for attr in functools.WRAPPER_UPDATES if hasattr(func, attr)
        )

        @functools.wraps(func, assigned=assigned, updated=updated)
        def wrapper(*args, **kwargs):
            list_args, empty = _apply_defaults(func, args, kwargs)

            for dim, value in zip(dimensions, list_args):

                if dim is None:
                    continue

                if not ureg.Quantity(value).check(dim):
                    val_dim = ureg.get_dimensionality(value)
                    raise DimensionalityError(value, &#34;a quantity of&#34;, val_dim, dim)
            return func(*args, **kwargs)

        return wrapper

    return decorator</code></pre>
</details>
</dd>
<dt id="layer.UnitRegistry.pi_theorem"><code class="name flex">
<span>def <span class="ident">pi_theorem</span></span>(<span>self, quantities)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds dimensionless quantities using the Buckingham π theorem</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>quantities</code></strong> :&ensp;<code>dict</code></dt>
<dd>mapping between variable name and units</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>a list of dimensionless quantities expressed as dicts</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pi_theorem(self, quantities):
    &#34;&#34;&#34;Builds dimensionless quantities using the Buckingham π theorem

    Parameters
    ----------
    quantities : dict
        mapping between variable name and units

    Returns
    -------
    list
        a list of dimensionless quantities expressed as dicts

    &#34;&#34;&#34;
    return pi_theorem(quantities, self)</code></pre>
</details>
</dd>
<dt id="layer.UnitRegistry.setup_matplotlib"><code class="name flex">
<span>def <span class="ident">setup_matplotlib</span></span>(<span>self, enable: bool = True) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set up handlers for matplotlib's unit support.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>enable</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether support should be enabled or disabled (Default value = True)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_matplotlib(self, enable: bool = True) -&gt; None:
    &#34;&#34;&#34;Set up handlers for matplotlib&#39;s unit support.

    Parameters
    ----------
    enable : bool
        whether support should be enabled or disabled (Default value = True)

    &#34;&#34;&#34;
    # Delays importing matplotlib until it&#39;s actually requested
    from .matplotlib import setup_matplotlib_handlers

    setup_matplotlib_handlers(self, enable)</code></pre>
</details>
</dd>
<dt id="layer.UnitRegistry.wraps"><code class="name flex">
<span>def <span class="ident">wraps</span></span>(<span>ureg: <a title="layer.UnitRegistry" href="#layer.UnitRegistry">UnitRegistry</a>, ret: Union[str, ForwardRef('Unit'), Iterable[Union[str, ForwardRef('Unit'), NoneType]], NoneType], args: Union[str, ForwardRef('Unit'), Iterable[Union[str, ForwardRef('Unit'), NoneType]], NoneType], strict: bool = True) ‑> Callable[[Callable[..., ~T]], Callable[..., patankar.private.pint.quantity.Quantity[~T]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Wraps a function to become pint-aware.</p>
<p>Use it when a function requires a numerical value but in some specific
units. The wrapper function will take a pint quantity, convert to the units
specified in <code>args</code> and then call the wrapped function with the resulting
magnitude.</p>
<p>The value returned by the wrapped function will be converted to the units
specified in <code>ret</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ureg</code></strong> :&ensp;<code>pint.UnitRegistry</code></dt>
<dd>a UnitRegistry instance.</dd>
<dt><strong><code>ret</code></strong> :&ensp;<code>str, pint.Unit,</code> or <code>iterable</code> of <code>str</code> or <code>pint.Unit</code></dt>
<dd>Units of each of the return values. Use <code>None</code> to skip argument conversion.</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>str, pint.Unit,</code> or <code>iterable</code> of <code>str</code> or <code>pint.Unit</code></dt>
<dd>Units of each of the input arguments. Use <code>None</code> to skip argument conversion.</dd>
<dt><strong><code>strict</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates that only quantities are accepted. (Default value = True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>callable</code></dt>
<dd>the wrapper function.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>if the number of given arguments does not match the number of function parameters.
if any of the provided arguments is not a unit a string or Quantity</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wraps(
    ureg: &#34;UnitRegistry&#34;,
    ret: Union[str, &#34;Unit&#34;, Iterable[Union[str, &#34;Unit&#34;, None]], None],
    args: Union[str, &#34;Unit&#34;, Iterable[Union[str, &#34;Unit&#34;, None]], None],
    strict: bool = True,
) -&gt; Callable[[Callable[..., T]], Callable[..., Quantity[T]]]:
    &#34;&#34;&#34;Wraps a function to become pint-aware.

    Use it when a function requires a numerical value but in some specific
    units. The wrapper function will take a pint quantity, convert to the units
    specified in `args` and then call the wrapped function with the resulting
    magnitude.

    The value returned by the wrapped function will be converted to the units
    specified in `ret`.

    Parameters
    ----------
    ureg : pint.UnitRegistry
        a UnitRegistry instance.
    ret : str, pint.Unit, or iterable of str or pint.Unit
        Units of each of the return values. Use `None` to skip argument conversion.
    args : str, pint.Unit, or iterable of str or pint.Unit
        Units of each of the input arguments. Use `None` to skip argument conversion.
    strict : bool
        Indicates that only quantities are accepted. (Default value = True)

    Returns
    -------
    callable
        the wrapper function.

    Raises
    ------
    TypeError
        if the number of given arguments does not match the number of function parameters.
        if any of the provided arguments is not a unit a string or Quantity

    &#34;&#34;&#34;

    if not isinstance(args, (list, tuple)):
        args = (args,)

    for arg in args:
        if arg is not None and not isinstance(arg, (ureg.Unit, str)):
            raise TypeError(
                &#34;wraps arguments must by of type str or Unit, not %s (%s)&#34;
                % (type(arg), arg)
            )

    converter = _parse_wrap_args(args)

    is_ret_container = isinstance(ret, (list, tuple))
    if is_ret_container:
        for arg in ret:
            if arg is not None and not isinstance(arg, (ureg.Unit, str)):
                raise TypeError(
                    &#34;wraps &#39;ret&#39; argument must by of type str or Unit, not %s (%s)&#34;
                    % (type(arg), arg)
                )
        ret = ret.__class__([_to_units_container(arg, ureg) for arg in ret])
    else:
        if ret is not None and not isinstance(ret, (ureg.Unit, str)):
            raise TypeError(
                &#34;wraps &#39;ret&#39; argument must by of type str or Unit, not %s (%s)&#34;
                % (type(ret), ret)
            )
        ret = _to_units_container(ret, ureg)

    def decorator(func: Callable[..., T]) -&gt; Callable[..., Quantity[T]]:

        count_params = len(signature(func).parameters)
        if len(args) != count_params:
            raise TypeError(
                &#34;%s takes %i parameters, but %i units were passed&#34;
                % (func.__name__, count_params, len(args))
            )

        assigned = tuple(
            attr for attr in functools.WRAPPER_ASSIGNMENTS if hasattr(func, attr)
        )
        updated = tuple(
            attr for attr in functools.WRAPPER_UPDATES if hasattr(func, attr)
        )

        @functools.wraps(func, assigned=assigned, updated=updated)
        def wrapper(*values, **kw) -&gt; Quantity[T]:

            values, kw = _apply_defaults(func, values, kw)

            # In principle, the values are used as is
            # When then extract the magnitudes when needed.
            new_values, values_by_name = converter(ureg, values, strict)

            result = func(*new_values, **kw)

            if is_ret_container:
                out_units = (
                    _replace_units(r, values_by_name) if is_ref else r
                    for (r, is_ref) in ret
                )
                return ret.__class__(
                    res if unit is None else ureg.Quantity(res, unit)
                    for unit, res in zip_longest(out_units, result)
                )

            if ret[0] is None:
                return result

            return ureg.Quantity(
                result, _replace_units(ret[0], values_by_name) if ret[1] else ret[0]
            )

        return wrapper

    return decorator</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="layer.air"><code class="flex name class">
<span>class <span class="ident">air</span></span>
<span>(</span><span>l=0.01, D=1e-06, T=None, lunit=None, Dunit=None, Cunit=None, layername='air layer', layercode='air', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for ideal gases such as air </p>
<p>air layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class air(layer):
    &#34;&#34;&#34;  extended pantankar.layer for ideal gases such as air &#34;&#34;&#34;
    def __init__(self,l=1e-2,D=1e-6,T=None,
                 lunit=None,Dunit=None,Cunit=None,
                 layername=&#34;air layer&#34;,layercode=&#34;air&#34;,**extra):
        &#34;&#34;&#34; air layer constructor &#34;&#34;&#34;
        T = layer._defaults[&#34;T&#34;] if T is None else check_units(T,None,&#34;degC&#34;)[0]
        TK = constants[&#34;T0K&#34;]+T
        kair = 1/(constants[&#34;R&#34;] *TK)
        kairunit = constants[&#34;iRT0Kunit&#34;]
        layer.__init__(self,
                       l=l,D=D,k=kair,C0=0,T=T,
                       lunit=lunit,Dunit=Dunit,kunit=kairunit,Cunit=Cunit,
                       layername=layername,
                       layertype=&#34;air&#34;, # set by default at inititialization
                       layermaterial=&#34;ideal gas&#34;,
                       layercode=&#34;gas&#34;,
                       **extra
                       )

    def density(self, T=None):
        &#34;&#34;&#34;Density of air at atmospheric pressure: density(T in K)&#34;&#34;&#34;
        TK = self.TK if T is None else check_units(T,None,&#34;K&#34;)[0]
        P_atm = 101325  # Pa (1 atm)
        M_air = 28.9647 # g/mol = 0.0289647 kg/mol (Molar mass of dry air).
        return P_atm / ((constants[&#34;R&#34;]/M_air) * TK), &#34;kg/m**3&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="layer.air.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Density of air at atmospheric pressure: density(T in K)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;Density of air at atmospheric pressure: density(T in K)&#34;&#34;&#34;
    TK = self.TK if T is None else check_units(T,None,&#34;K&#34;)[0]
    P_atm = 101325  # Pa (1 atm)
    M_air = 28.9647 # g/mol = 0.0289647 kg/mol (Molar mass of dry air).
    return P_atm / ((constants[&#34;R&#34;]/M_air) * TK), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.build_quantity_class.<locals>.Quantity"><code class="flex name class">
<span>class <span class="ident">qSI</span></span>
<span>(</span><span>value, units=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements a class to describe a physical quantity:
the product of a numerical value and a unit of measurement.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str, pint.Quantity</code> or <code>any numeric type</code></dt>
<dd>Value of the physical quantity to be created.</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>UnitsContainer, str</code> or <code>pint.Quantity</code></dt>
<dd>Units of the physical quantity to be created.</dd>
</dl>
<h2 id="returns">Returns</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Quantity(_Quantity):
    _REGISTRY = registry</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>patankar.private.pint.quantity.Quantity</li>
<li>patankar.private.pint.util.PrettyIPython</li>
<li>patankar.private.pint.util.SharedRegistryObject</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="layer.gPET"><code class="flex name class">
<span>class <span class="ident">gPET</span></span>
<span>(</span><span>l=0.0002, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in gPET', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for PET in its glassy state (below ~76°C) </p>
<p>glassy PET layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class gPET(layer):
    &#34;&#34;&#34; extended pantankar.layer for PET in its glassy state (below ~76°C) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in gPET&#34;,**extra):
        &#34;&#34;&#34; glassy PET layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;glassy PET&#34;,
            layercode=&#34;PET&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of glassy PET: ~1350 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1350 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; approximate glass transition temperature of PET &#34;&#34;&#34;
        return 76, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.gPET.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>approximate glass transition temperature of PET</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; approximate glass transition temperature of PET &#34;&#34;&#34;
    return 76, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.gPET.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of glassy PET: ~1350 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of glassy PET: ~1350 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1350 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.layer"><code class="flex name class">
<span>class <span class="ident">layer</span></span>
<span>(</span><span>l=None, D=None, k=None, C0=None, rho=None, T=None, lunit=None, Dunit=None, kunit=None, Cunit=None, rhounit=None, Tunit=None, layername=None, layertype=None, layermaterial=None, layercode=None, substance=None, Dmodel=None, kmodel=None, nmesh=None, nmeshmin=None, verbose=None, verbosity=2, **unresolved)</span>
</code></dt>
<dd>
<div class="desc"><p>layer class from patankar package
&hellip;
strings properties: layername, layertype, layermaterial
scalar properties: D,k,l,C0
&hellip;</p>
<h2 id="example">Example</h2>
<p>A = layer(D=1e-14,l=50e-6,layername="layer A",layertype="polymer",layermaterial="PP")</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>layername</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Name. The default is "my layer".</dd>
<dt><strong><code>layertype</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Layer Type. The default is "unknown type".</dd>
<dt><strong><code>layermaterial</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Material identification . The default is "unknown material".</dd>
<dt>PHYSICAL QUANTITIES</dt>
<dt><strong><code>l</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Thickness. The default is 50e-6 (m).</dd>
<dt><strong><code>D</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).</dd>
<dt><strong><code>C0</code></strong> :&ensp;<code>TYPE</code>, optional<code>, scalar</code> or <code>tupple (value,"unit")</code></dt>
<dd>DESCRIPTION. Initial concentration. The default is 1000 (a.u.).</dd>
<dt>PHYSICAL UNITS</dt>
<dt><strong><code>lunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Length units. The default unit is "m.</dd>
<dt><strong><code>Dunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Diffusivity units. The default unit is 1e-14 "m^2/s".</dd>
<dt><strong><code>kunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Henry-like coefficient. The default unit is "a.u.".</dd>
<dt><strong><code>Cunit</code></strong> :&ensp;<code>TYPE</code>, optional<code>, string</code></dt>
<dd>DESCRIPTION. Initial concentration. The default unit is "a.u.".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>a monolayer object which can be assembled into a multilayer structure</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class layer:
    &#34;&#34;&#34;
        layer class from patankar package
        ...
        strings properties: layername, layertype, layermaterial
        scalar properties: D,k,l,C0
        ...
        Example:
            A = layer(D=1e-14,l=50e-6,layername=&#34;layer A&#34;,layertype=&#34;polymer&#34;,layermaterial=&#34;PP&#34;)
    &#34;&#34;&#34;
    # --------------------------------------------------------------------
    # PRIVATE PROPERTIES (cannot be changed by the user)
    # __ read only attributes
    #  _ private attributes (not public)
    # --------------------------------------------------------------------
    __description = &#34;LAYER object&#34;                # description
    __version = 1.0                               # version
    __contact = &#34;olivier.vitrac@agroparistech.fr&#34; # contact person
    _printformat = &#34;%0.4g&#34;   # format to display D, k, l values


    # Synonyms dictionary: Maps alternative names to the actual parameter
    # these synonyms can be used during construction
    _synonyms = {
        &#34;substance&#34;: {&#34;migrant&#34;, &#34;compound&#34;, &#34;chemical&#34;,&#34;molecule&#34;,&#34;solute&#34;},
        &#34;C0&#34;: {&#34;CP0&#34;, &#34;Cp0&#34;},
        &#34;l&#34;: {&#34;lp&#34;, &#34;lP&#34;},
        &#34;D&#34;: {&#34;Dp&#34;, &#34;DP&#34;},
        &#34;k&#34;: {&#34;kp&#34;, &#34;kP&#34;},
        &#34;T&#34;: {&#34;temp&#34;,&#34;Temp&#34;,&#34;temperature&#34;,&#34;Temperature&#34;,
              &#34;contacttemperature&#34;,&#34;ContactTemperature&#34;,&#34;contactTemperature&#34;}
    }
    # Default values for parameters (note that Td cannot be changed by the end-user)
    _defaults = {
        &#34;l&#34;: 5e-5,   # Thickness (m)
        &#34;D&#34;: 1e-14,  # Diffusion coefficient (m^2/s)
        &#34;k&#34;: 1.0,      # Henri-like coefficient (dimensionless)
        &#34;C0&#34;: 1000,  # Initial concentration (arbitrary units)
        &#34;rho&#34;: 1000, # Default density (kg/m³)
        &#34;T&#34;: 40.0,     # Default temperature (°C)
        &#34;Td&#34;: 25.0,    # Reference temperature for densities (°C)
        # Units (do not change)
        &#34;lunit&#34;: &#34;m&#34;,
        &#34;Dunit&#34;: &#34;m**2/s&#34;,
        &#34;kunit&#34;: &#34;a.u.&#34;,  # NoUnits
        &#34;Cunit&#34;: &#34;a.u.&#34;,  # NoUnits
        &#34;rhounit&#34;: &#34;kg/m**3&#34;,
        &#34;Tunit&#34;: &#34;degC&#34;,  # Temperatures are indicated in °C instead of K (to reduce end-user mistakes)
        # Layer properties
        &#34;layername&#34;: &#34;my layer&#34;,
        &#34;layertype&#34;: &#34;unknown type&#34;,
        &#34;layermaterial&#34;: &#34;unknown material&#34;,
        &#34;layercode&#34;: &#34;N/A&#34;,
        # Mesh parameters
        &#34;nmeshmin&#34;: 20,
        &#34;nmesh&#34;: 600,
        # Substance
        &#34;substance&#34;: None,
        # Other parameters
        &#34;verbose&#34;: None,
        &#34;verbosity&#34;: 2
    }

    # List units
    _parametersWithUnits = {
        &#34;l&#34;: &#34;m&#34;,
        &#34;D&#34;: &#34;m**2/s&#34;,
        &#34;k&#34;: &#34;a.u.&#34;,
        &#34;C&#34;: &#34;a.u.&#34;,
        &#34;rhp&#34;: &#34;kg/m**3&#34;,
        &#34;T&#34;: &#34;degC&#34;,
        }

    # Brief descriptions for each parameter
    _descriptionInputs = {
        &#34;l&#34;: &#34;Thickness of the layer (m)&#34;,
        &#34;D&#34;: &#34;Diffusion coefficient (m²/s)&#34;,
        &#34;k&#34;: &#34;Henri-like coefficient (dimensionless)&#34;,
        &#34;C0&#34;: &#34;Initial concentration (arbitrary units)&#34;,
        &#34;rho&#34;: &#34;Density of the material (kg/m³)&#34;,
        &#34;T&#34;: &#34;Layer temperature (°C)&#34;,
        &#34;Td&#34;: &#34;Reference temperature for densities (°C)&#34;,
        &#34;lunit&#34;: &#34;Unit of thickness (default: m)&#34;,
        &#34;Dunit&#34;: &#34;Unit of diffusion coefficient (default: m²/s)&#34;,
        &#34;kunit&#34;: &#34;Unit of Henri-like coefficient (default: a.u.)&#34;,
        &#34;Cunit&#34;: &#34;Unit of initial concentration (default: a.u.)&#34;,
        &#34;rhounit&#34;: &#34;Unit of density (default: kg/m³)&#34;,
        &#34;Tunit&#34;: &#34;Unit of temperature (default: degC)&#34;,
        &#34;layername&#34;: &#34;Name of the layer&#34;,
        &#34;layertype&#34;: &#34;Type of layer (e.g., polymer, ink, air)&#34;,
        &#34;layermaterial&#34;: &#34;Material composition of the layer&#34;,
        &#34;layercode&#34;: &#34;Identification code for the layer&#34;,
        &#34;nmeshmin&#34;: &#34;Minimum number of FV mesh elements for the layer&#34;,
        &#34;nmesh&#34;: &#34;Number of FV mesh elements for numerical computation&#34;,
        &#34;verbose&#34;: &#34;Verbose mode (None or boolean)&#34;,
        &#34;verbosity&#34;: &#34;Level of verbosity for debug messages (integer)&#34;
    }

    # --------------------------------------------------------------------
    # CONSTRUCTOR OF INSTANCE PROPERTIES
    # None = missing numeric value (managed by default)
    # --------------------------------------------------------------------
    def __init__(self,
                 l=None, D=None, k=None, C0=None, rho=None, T=None,
                 lunit=None, Dunit=None, kunit=None, Cunit=None, rhounit=None, Tunit=None,
                 layername=None,layertype=None,layermaterial=None,layercode=None,
                 substance = None, Dmodel = None, kmodel = None,
                 nmesh=None, nmeshmin=None,
                 verbose=None, verbosity=2,**unresolved):
        &#34;&#34;&#34;

        Parameters
        ----------

        layername : TYPE, optional, string
                    DESCRIPTION. Layer Name. The default is &#34;my layer&#34;.
        layertype : TYPE, optional, string
                    DESCRIPTION. Layer Type. The default is &#34;unknown type&#34;.
        layermaterial : TYPE, optional, string
                        DESCRIPTION. Material identification . The default is &#34;unknown material&#34;.
        PHYSICAL QUANTITIES
        l : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Thickness. The default is 50e-6 (m).
        D : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Diffusivity. The default is 1e-14 (m^2/s).
        k : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Henry-like coefficient. The default is 1 (a.u.).
        C0 : TYPE, optional, scalar or tupple (value,&#34;unit&#34;)
            DESCRIPTION. Initial concentration. The default is 1000 (a.u.).
        PHYSICAL UNITS
        lunit : TYPE, optional, string
                DESCRIPTION. Length units. The default unit is &#34;m.
        Dunit : TYPE, optional, string
                DESCRIPTION. Diffusivity units. The default unit is 1e-14 &#34;m^2/s&#34;.
        kunit : TYPE, optional, string
                DESCRIPTION. Henry-like coefficient. The default unit is &#34;a.u.&#34;.
        Cunit : TYPE, optional, string
                DESCRIPTION. Initial concentration. The default unit is &#34;a.u.&#34;.
        Returns
        -------
        a monolayer object which can be assembled into a multilayer structure

        &#34;&#34;&#34;
        # resolve alternative names used by end-users
        substance = layer.resolvename(substance,&#34;substance&#34;,**unresolved)
        C0 = layer.resolvename(C0,&#34;C0&#34;,**unresolved)
        l = layer.resolvename(l,&#34;l&#34;,**unresolved)
        D = layer.resolvename(D,&#34;D&#34;,**unresolved)
        k = layer.resolvename(k,&#34;k&#34;,**unresolved)
        T = layer.resolvename(T,&#34;T&#34;,**unresolved)

        # Assign defaults only if values are not provided
        l = l if l is not None else layer._defaults[&#34;l&#34;]
        D = D if D is not None else layer._defaults[&#34;D&#34;]
        k = k if k is not None else layer._defaults[&#34;k&#34;]
        C0 = C0 if C0 is not None else layer._defaults[&#34;C0&#34;]
        rho = rho if rho is not None else layer._defaults[&#34;rho&#34;]
        T = T if T is not None else layer._defaults[&#34;T&#34;]
        lunit = lunit if lunit is not None else layer._defaults[&#34;lunit&#34;]
        Dunit = Dunit if Dunit is not None else layer._defaults[&#34;Dunit&#34;]
        kunit = kunit if kunit is not None else layer._defaults[&#34;kunit&#34;]
        Cunit = Cunit if Cunit is not None else layer._defaults[&#34;Cunit&#34;]
        rhounit = rhounit if rhounit is not None else layer._defaults[&#34;rhounit&#34;]
        Tunit = Tunit if Tunit is not None else layer._defaults[&#34;Tunit&#34;]
        nmesh = nmesh if nmesh is not None else layer._defaults[&#34;nmesh&#34;]
        nmeshmin = nmeshmin if nmeshmin is not None else layer._defaults[&#34;nmeshmin&#34;]
        verbose = verbose if verbose is not None else layer._defaults[&#34;verbose&#34;]
        verbosity = verbosity if verbosity is not None else layer._defaults[&#34;verbosity&#34;]

        # Assign layer id properties
        layername = layername if layername is not None else layer._defaults[&#34;layername&#34;]
        layertype = layertype if layertype is not None else layer._defaults[&#34;layertype&#34;]
        layermaterial = layermaterial if layermaterial is not None else layer._defaults[&#34;layermaterial&#34;]
        layercode = layercode if layercode is not None else layer._defaults[&#34;layercode&#34;]

        # validate all physical paramaters with their units
        l,lunit = check_units(l,lunit,layer._defaults[&#34;lunit&#34;])
        D,Dunit = check_units(D,Dunit,layer._defaults[&#34;Dunit&#34;])
        k,kunit = check_units(k,kunit,layer._defaults[&#34;kunit&#34;])
        C0,Cunit = check_units(C0,Cunit,layer._defaults[&#34;Cunit&#34;])
        rho,rhounit = check_units(rho,rhounit,layer._defaults[&#34;rhounit&#34;])
        T,Tunit = check_units(T,Tunit,layer._defaults[&#34;Tunit&#34;])

        # set attributes: id and physical properties
        self._name = [layername]
        self._type = [layertype]
        self._material = [layermaterial]
        self._code = [layercode]
        self._nlayer = 1
        self._l = l[:1]
        self._D = D[:1]
        self._k = k[:1]
        self._C0 = C0[:1]
        self._rho = rho[:1]
        self._T = T
        self._lunit = lunit
        self._Dunit = Dunit
        self._kunit = kunit
        self._Cunit = Cunit
        self._rhounit = rhounit
        self._Tunit = Tunit
        self._nmesh = nmesh
        self._nmeshmin = nmeshmin

        # set substance and property models
        self._substance = substance

        # set history for all layers merged with +
        self._layerclass_history = []

        # set verbosity attributes
        self.verbosity = 0 if verbosity is None else verbosity
        self.verbose = verbosity&gt;0 if verbose is None else verbose

        # we initialize the acknowlegment process for future property propagation
        self._hasbeeninherited = {}

    # --------------------------------------------------------------------
    # Class method returning help() for the end user
    # --------------------------------------------------------------------
    @classmethod
    def help(cls):
        &#34;&#34;&#34;
        Prints a dynamically formatted summary of all input parameters,
        adjusting column widths based on content and wrapping long descriptions.
        &#34;&#34;&#34;

        # Column Headers
        headers = [&#34;Parameter&#34;, &#34;Default Value&#34;, &#34;Has Synonyms?&#34;, &#34;Description&#34;]
        col_widths = [len(h) for h in headers]  # Start with header widths

        # Collect Data Rows
        rows = []
        for param, default in cls._defaults.items():
            has_synonyms = &#34;✅ Yes&#34; if param in cls._synonyms else &#34;❌ No&#34;
            description = cls._descriptionInputs.get(param, &#34;No description available&#34;)

            # Update column widths dynamically
            col_widths[0] = max(col_widths[0], len(param))
            col_widths[1] = max(col_widths[1], len(str(default)))
            col_widths[2] = max(col_widths[2], len(has_synonyms))
            col_widths[3] = max(col_widths[3], len(description))

            rows.append([param, str(default), has_synonyms, description])

        # Function to wrap text for a given column width
        def wrap_text(text, width):
            return textwrap.fill(text, width)

        # Print Table with Adjusted Column Widths
        separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in col_widths) + &#34;-+&#34;
        print(&#34;\n### **Accepted Parameters and Defaults**\n&#34;)
        print(separator)
        print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(col_widths[i]) for i, h in enumerate(headers)) + &#34; |&#34;)
        print(separator)
        for row in rows:
            # Wrap text in the description column
            row[3] = wrap_text(row[3], col_widths[3])

            # Print row
            print(&#34;| &#34; + &#34; | &#34;.join(row[i].ljust(col_widths[i]) for i in range(3)) + &#34; | &#34; + row[3])
        print(separator)

        # Synonyms Table
        print(&#34;\n### **Parameter Synonyms**\n&#34;)
        syn_headers = [&#34;Parameter&#34;, &#34;Synonyms&#34;]
        syn_col_widths = [
            max(len(&#34;Parameter&#34;), max(len(k) for k in cls._synonyms.keys())),  # Ensure it fits &#34;Parameter&#34;
            max(len(&#34;Synonyms&#34;), max(len(&#34;, &#34;.join(v)) for v in cls._synonyms.values()))  # Ensure it fits &#34;Synonyms&#34;
        ]
        syn_separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in syn_col_widths) + &#34;-+&#34;
        print(syn_separator)
        print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(syn_col_widths[i]) for i, h in enumerate(syn_headers)) + &#34; |&#34;)
        print(syn_separator)
        for param, synonyms in cls._synonyms.items():
            print(f&#34;| {param.ljust(syn_col_widths[0])} | {&#39;, &#39;.join(synonyms).ljust(syn_col_widths[1])} |&#34;)
        print(syn_separator)


    # --------------------------------------------------------------------
    # Class method to handle ambiguous definition from end-user
    # --------------------------------------------------------------------
    @classmethod
    def resolvename(cls, param_value, param_key, **unresolved):
        &#34;&#34;&#34;
        Resolves the correct parameter value using known synonyms.

        - If param_value is already set (not None), return it.
        - If a synonym exists in **unresolved, assign its value.
        - If multiple synonyms of the same parameter appear in **unresolved, raise an error.
        - Otherwise, return None.

        Parameters:
        - `param_name` (any): The original value (if provided).
        - `param_key` (str): The legitimate parameter name we are resolving.
        - `unresolved` (dict): The dictionary of unrecognized keyword arguments.

        Returns:
        - The resolved value or None if not found.
        &#34;&#34;&#34;
        if param_value is not None:
            return param_value  # The parameter is explicitly defined, do not override
        if not unresolved:      # shortcut
            return None
        resolved_value = None
        found_keys = []
        # Check if param_key itself is present in unresolved
        if param_key in unresolved:
            found_keys.append(param_key)
            resolved_value = unresolved[param_key]
        # Check if any of its synonyms are in unresolved
        if param_key in cls._synonyms:
            for synonym in cls._synonyms[param_key]:
                if synonym in unresolved:
                    found_keys.append(synonym)
                    resolved_value = unresolved[synonym]
        # Raise error if multiple synonyms were found
        if len(found_keys) &gt; 1:
            raise ValueError(
                f&#34;Conflicting definitions: Multiple synonyms {found_keys} were provided for &#39;{param_key}&#39;.&#34;
            )
        return resolved_value


    # --------------------------------------------------------------------
    # overloading binary addition (note that the output is of type layer)
    # --------------------------------------------------------------------
    def __add__(self,other):
        &#34;&#34;&#34; C=A+B | overload + operator &#34;&#34;&#34;
        if isinstance(other, layer):
            res = duplicate(self)
            res._nmeshmin = min(self._nmeshmin,other._nmeshmin)
            # propage substance
            if self._substance is None:
                res._substance = other._substance
            else:
                if isinstance(self._substance,migrant) and isinstance(other._substance,migrant):
                    if self._substance.M != other._substance.M:
                        print(&#34;Warning: the smallest subtance is propagated everywhere&#34;)
                    res._substance = self._substance if self._substance.M&lt;=other._substance.M else other._substance
                else:
                    res._substance = None
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_code&#34;,&#34;_nlayer&#34;]:
                setattr(res,p,getattr(self,p)+getattr(other,p))
            for p in [&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;,&#34;_rho&#34;,&#34;_T&#34;]:
                setattr(res,p,np.concatenate((getattr(self,p),getattr(other,p))))
            # we add the history of all layers
            res._layerclass_history = self.layerclass_history + other.layerclass_history
            return res
        else: raise ValueError(&#34;invalid layer object&#34;)


    # --------------------------------------------------------------------
    # overloading binary multiplication (note that the output is of type layer)
    # --------------------------------------------------------------------
    def __mul__(self,ntimes):
        &#34;&#34;&#34; nA = A*n | overload * operator &#34;&#34;&#34;
        if isinstance(ntimes, int) and ntimes&gt;0:
            res = duplicate(self)
            if ntimes&gt;1:
                for n in range(1,ntimes): res += self
            return res
        else: raise ValueError(&#34;multiplicator should be a strictly positive integer&#34;)


    # --------------------------------------------------------------------
    # len method
    # --------------------------------------------------------------------
    def __len__(self):
        &#34;&#34;&#34; length method &#34;&#34;&#34;
        return self._nlayer

    # --------------------------------------------------------------------
    # object indexing (get,set) method
    # --------------------------------------------------------------------
    def __getitem__(self,i):
        &#34;&#34;&#34; get indexing method &#34;&#34;&#34;
        res = duplicate(self)
        # check indices
        isscalar = isinstance(i,int)
        if isinstance(i,slice):
            if i.step==None: j = list(range(i.start,i.stop))
            else: j = list(range(i.start,i.stop,i.step))
            res._nlayer = len(j)
        if isinstance(i,int): res._nlayer = 1
        # pick indices for each property
        for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
            content = getattr(self,p)
            try:
                if isscalar: setattr(res,p,content[i:i+1])
                else: setattr(res,p,content[i])
            except IndexError as err:
                if self.verbosity&gt;0 and self.verbose:
                    print(&#34;bad layer object indexing: &#34;,err)
        return res

    def __setitem__(self,i,other):
        &#34;&#34;&#34; set indexing method &#34;&#34;&#34;
        # check indices
        if isinstance(i,slice):
            if i.step==None: j = list(range(i.start,i.stop))
            else: j = list(range(i.start,i.stop,i.step))
        elif isinstance(i,int): j = [i]
        else:raise IndexError(&#34;invalid index&#34;)
        islayer = isinstance(other,layer)
        isempty = not islayer and isinstance(other,list) and len(other)&lt;1
        if isempty:         # empty right hand side
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
                content = getattr(self,p)
                try:
                    newcontent = [content[k] for k in range(self._nlayer) if k not in j]
                except IndexError as err:
                    if self.verbosity&gt;0 and self.verbose:
                        print(&#34;bad layer object indexing: &#34;,err)
                if isinstance(content,np.ndarray) and not isinstance(newcontent,np.ndarray):
                    newcontent = np.array(newcontent)
                setattr(self,p,newcontent)
            self._nlayer = len(newcontent)
        elif islayer:        # islayer right hand side
            nk1 = len(j)
            nk2 = other._nlayer
            if nk1 != nk2:
                raise IndexError(&#34;the number of elements does not match the number of indices&#34;)
            for p in [&#34;_name&#34;,&#34;_type&#34;,&#34;_material&#34;,&#34;_l&#34;,&#34;_D&#34;,&#34;_k&#34;,&#34;_C0&#34;]:
                content1 = getattr(self,p)
                content2 = getattr(other,p)
                for k in range(nk1):
                    try:
                        content1[j[k]] = content2[k]
                    except IndexError as err:
                        if self.verbosity&gt;0 and self.verbose:
                            print(&#34;bad layer object indexing: &#34;,err)
                setattr(self,p,content1)
        else:
            raise ValueError(&#34;only [] or layer object are accepted&#34;)


    # --------------------------------------------------------------------
    # Getter methods (show private/hidden properties and meta-properties)
    # --------------------------------------------------------------------
    @property
    def layerclass_history(self):
        return self._layerclass_history if self._layerclass_history != [] else [self.layerclass]
    @property
    def layerclass(self): return type(self).__name__
    @property
    def name(self): return self._name
    @property
    def type(self): return self._type
    @property
    def material(self): return self._material
    @property
    def code(self): return self._code
    @property
    def l(self): return self._l
    @property
    def D(self):
        Dtmp = self.Dmodel()
        if Dtmp is not None:
            return np.full_like(self._D, Dtmp)
        else:
            return self._D
    @property
    def k(self):
        ktmp = self.kmodel()
        if ktmp:
            return np.full_like(self._D, ktmp)
        else:
            return self._k
    @property
    def C0(self): return self._C0
    @property
    def rho(self): return self._rho
    @property
    def T(self): return self._T
    @property
    def TK(self): return self._T+T0K
    @property
    def lunit(self): return self._lunit
    @property
    def Dunit(self): return self._Dunit
    @property
    def kunit(self): return self._kunit
    @property
    def Cunit(self): return self._Cunit
    @property
    def rhounit(self): return self._rhounit
    @property
    def Tunit(self): return self._Tunit
    @property
    def TKunit(self): return &#34;K&#34;
    @property
    def n(self): return self._nlayer
    @property
    def nmesh(self): return self._nmesh
    @property
    def nmeshmin(self): return self._nmeshmin
    @property
    def resistance(self): return self.l*self.k/self.D
    @property
    def permeability(self): return self.D/(self.l*self.k)
    @property
    def lag(self): return self.l**2/(6*self.D)
    @property
    def pressure(self): return self.k*self.C0
    @property
    def thickness(self): return sum(self.l)
    @property
    def concentration(self): return sum(self.l*self.C0)/self.thickness
    @property
    def relative_thickness(self): return self.l/self.thickness
    @property
    def relative_resistance(self): return self.resistance/sum(self.resistance)
    @property
    def rank(self): return np.flip(np.argsort(np.array(self.resistance))+1).tolist()
    @property
    def referencelayer(self): return np.argmax(self.resistance)
    @property
    def lreferencelayer(self): return self.l[self.referencelayer]
    @property
    def Foscale(self): return self.D[self.referencelayer]/self.lreferencelayer**2

    # layer substance (of class migrant or None)
    @property
    def substance(self): return self._substance

    # Dmodel and kmodel returned as properties (they are lambda functions)
    # polymer and mass are udpdated on the fly (the code loops over all layers)
    @property
    def Dmodel(self):
        &#34;&#34;&#34;Return a callable function that evaluates D with updated parameters.&#34;&#34;&#34;
        if not isinstance(self._substance,migrant) or self._substance.Deval() is None:
            return lambda **kwargs: None  # Return a function that always returns None
        template = self._substance.Dtemplate.copy()
        template.update()
        def func(**kwargs):
            D = np.empty_like(self._D)
            for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
                template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
                # inherit eventual user parameters
                D[i] = self._substance.D.evaluate(**dict(template, **kwargs))
            return D
        return func

    @property
    def kmodel(self):
        &#34;&#34;&#34;Return a callable function that evaluates k with updated parameters.&#34;&#34;&#34;
        if not isinstance(self._substance,migrant) or self._substance.keval() is None:
            return lambda **kwargs: None  # Return a function that always returns None
        template = self._substance.ktemplate.copy()
        template.update()
        def func(**kwargs):
            k = np.empty_like(self._k)
            for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
                template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
                # inherit eventual user parameters
                k[i] = self._substance.k.evaluate(**dict(template, **kwargs))
            return k
        return func


    # --------------------------------------------------------------------
    # comparators based resistance
    # --------------------------------------------------------------------
    def __eq__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1==value2

    def __ne__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1!=value2

    def __lt__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&lt;value2

    def __gt__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&gt;value2

    def __le__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&lt;=value2

    def __ge__(self, o):
        value1 = self.resistance if self._nlayer&gt;1 else self.resistance[0]
        if isinstance(o,layer):
            value2 = o.resistance if o._nlayer&gt;1 else o.resistance[0]
        else:
            value2 = o
        return value1&gt;=value2


    # --------------------------------------------------------------------
    # Generates mesh
    # --------------------------------------------------------------------
    def mesh(self,nmesh=None,nmeshmin=None):
        &#34;&#34;&#34; nmesh() generates mesh based on nmesh and nmeshmin, nmesh(nmesh=value,nmeshmin=value) &#34;&#34;&#34;
        if nmesh==None: nmesh = self.nmesh
        if nmeshmin==None: nmeshmin = self.nmeshmin
        if nmeshmin&gt;nmesh: nmeshmin,nmesh = nmesh, nmeshmin
        # X = mesh distribution (number of nodes per layer)
        X = np.ones(self._nlayer)
        for i in range(1,self._nlayer):
           X[i] = X[i-1]*(self.permeability[i-1]*self.l[i])/(self.permeability[i]*self.l[i-1])
        X = np.maximum(nmeshmin,np.ceil(nmesh*X/sum(X)))
        X = np.round((X/sum(X))*nmesh).astype(int)
        # do the mesh
        x0 = 0
        mymesh = []
        for i in range(self._nlayer):
            mymesh.append(mesh(self.l[i]/self.l[self.referencelayer],X[i],x0=x0,index=i))
            x0 += self.l[i]
        return mymesh

    # --------------------------------------------------------------------
    # Getter methods and tools to validate inputs checknumvalue and checktextvalue
    # --------------------------------------------------------------------
    def checknumvalue(self,value,ExpectedUnits=None):
        &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
        if isinstance(value,tuple):
            value = check_units(value,ExpectedUnits=ExpectedUnits)
        if isinstance(value,int): value = float(value)
        if isinstance(value,float): value = np.array([value])
        if isinstance(value,list): value = np.array(value)
        if len(value)&gt;self._nlayer:
            value = value[:self._nlayer]
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the extra value(s) has been removed&#39;)
        elif len(value)&lt;self._nlayer:
            value = np.concatenate((value,value[-1:]*np.ones(self._nlayer-len(value))))
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the last value has been repeated&#39;)
        return value

    def checktextvalue(self,value):
        &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
        if not isinstance(value,list): value = [value]
        if len(value)&gt;self._nlayer:
            value = value[:self._nlayer]
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the extra entry(ies) has been removed&#39;)
        elif len(value)&lt;self._nlayer:
            value = value + value[-1:]*(self._nlayer-len(value))
            if self.verbosity&gt;1 and self.verbose:
                print(&#39;dimension mismatch, the last entry has been repeated&#39;)
        return value

    @l.setter
    def l(self,value): self._l =self.checknumvalue(value,layer._defaults[&#34;lunit&#34;])
    @D.setter
    def D(self,value): self._D=self.checknumvalue(value,layer._defaults[&#34;Dunit&#34;])
    @k.setter
    def k(self,value): self._k =self.checknumvalue(value,layer._defaults[&#34;kunit&#34;])
    @C0.setter
    def C0(self,value): self._C0 =self.checknumvalue(value,layer._defaults[&#34;Cunit&#34;])
    @rho.setter
    def rho(self,value): self._rho =self.checknumvalue(value,layer._defaults[&#34;rhounit&#34;])
    @T.setter
    def T(self,value): self._T =self.checknumvalue(value,layer._defaults[&#34;Tunit&#34;])
    @name.setter
    def name(self,value): self._name =self.checktextvalue(value)
    @type.setter
    def type(self,value): self._type =self.checktextvalue(value)
    @material.setter
    def material(self,value): self._material =self.checktextvalue(value)
    @nmesh.setter
    def nmesh(self,value): self._nmesh = max(value,self._nlayer*self._nmeshmin)
    @nmeshmin.setter
    def nmeshmin(self,value): self._nmeshmin = max(value,round(self._nmesh/(2*self._nlayer)))
    @substance.setter
    def substance(self,value):
        if not isinstance(value,migrant):
            raise TypeError(f&#34;value must be a migrant class not a {type(value).__name__}&#34;)
        self._substance = value


    # --------------------------------------------------------------------
    # hash methods (assembly and layer-by-layer)
    # note that list needs to be converted into tuples to be hashed
    # --------------------------------------------------------------------
    def __hash__(self):
        &#34;&#34;&#34; hash layer-object (assembly) method &#34;&#34;&#34;
        return hash((tuple(self._name),
                     tuple(self._type),
                     tuple(self._material),
                     tuple(self._l),
                     tuple(self._D),
                     tuple(self.k),
                     tuple(self._C0),
                     tuple(self._rho)))

    # layer-by-layer @property = decoration to consider it
    # as a property instead of a method/attribute
    # comprehension for n in range(self._nlayer) applies it to all layers
    @property
    def hashlayer(self):
        &#34;&#34;&#34; hash layer (layer-by-layer) method &#34;&#34;&#34;
        return [hash((self._name[n],
                      self._type[n],
                      self._material[n],
                      self._l[n],
                      self._D[n],
                      self.k[n],
                      self._C0[n],
                      self._rho[n]))
                for n in range(self._nlayer)
                ]


    # --------------------------------------------------------------------
    # repr method (since the getter are defined, the &#39;_&#39; is dropped)
    # --------------------------------------------------------------------
    # density and temperature are not shown
    def __repr__(self):
        &#34;&#34;&#34; disp method &#34;&#34;&#34;
        print(&#34;\n[%s version=%0.4g, contact=%s]&#34; % (self.__description,self.__version,self.__contact))
        if self._nlayer==0:
            print(&#34;empty %s&#34; % (self.__description))
        else:
            hasDmodel = self.Dmodel() is not None
            haskmodel = self.kmodel() is not None
            properties_ = {&#34;l&#34;:False,&#34;D&#34;:hasDmodel,&#34;k&#34;:haskmodel,&#34;C0&#34;:False}
            if hasDmodel or haskmodel:
                properties_[&#34;T&#34;] = False
            fmtval = &#39;%10s: &#39;+self._printformat+&#34; [%s]&#34;
            fmtstr = &#39;%10s= %s&#39;
            if self._nlayer==1:
                print(f&#39;monolayer of {self.__description}:&#39;)
            else:
                print(f&#39;{self._nlayer}-multilayer of {self.__description}:&#39;)
            for n in range(1,self._nlayer+1):
                modelinfo = {
                    &#34;D&#34;: f&#34;{self._substance.D.__name__}({self.layerclass_history[n-1]},{self._substance},T={float(self.T[0])} {self.Tunit})&#34; if hasDmodel else &#34;&#34;,
                    &#34;k&#34;: f&#34;{self._substance.k.__name__}({self.layerclass_history[n-1]},{self._substance} g/mol,T={float(self.T[0])} {self.Tunit})&#34; if haskmodel else &#34;&#34;,
                    }
                print(&#39;-- [ layer %d of %d ] ---------- barrier rank=%d --------------&#39;
                      % (n,self._nlayer,self.rank[n-1]))
                for p in [&#34;name&#34;,&#34;type&#34;,&#34;material&#34;,&#34;code&#34;]:
                    v = getattr(self,p)
                    print(&#39;%10s: &#34;%s&#34;&#39; % (p,v[n-1]),flush=True)
                for p in properties_.keys():
                    v = getattr(self,p)                 # value
                    vunit = getattr(self,p[0]+&#34;unit&#34;)   # value unit
                    print(fmtval % (p,v[n-1],vunit),flush=True)
                    if properties_[p]:
                        print(fmtstr % (&#34;&#34;,modelinfo[p]),flush=True)
        return str(self)

    def __str__(self):
        &#34;&#34;&#34;Formatted string representation of layer&#34;&#34;&#34;
        all_identical = len(set(self.layerclass_history)) == 1
        cls = self.__class__.__name__ if all_identical else &#34;multilayer&#34;
        return f&#34;&lt;{cls} with {self.n} layer{&#39;s&#39; if self.n&gt;1 else &#39;&#39;}: {self.name}&gt;&#34;

    # --------------------------------------------------------------------
    # Returns the equivalent dictionary from an object for debugging
    # --------------------------------------------------------------------
    def _todict(self):
        &#34;&#34;&#34; returns the equivalent dictionary from an object &#34;&#34;&#34;
        return dict((key, getattr(self, key)) for key in dir(self) if key not in dir(self.__class__))
    # --------------------------------------------------------------------

    # --------------------------------------------------------------------
    # Simplify layers by collecting similar ones
    # --------------------------------------------------------------------
    def simplify(self):
        &#34;&#34;&#34; merge continuous layers of the same type &#34;&#34;&#34;
        nlayer = self._nlayer
        if nlayer&gt;1:
           res = self[0]
           ires = 0
           ireshash = res.hashlayer[0]
           for i in range(1,nlayer):
               if self.hashlayer[i]==ireshash:
                   res.l[ires] = res.l[ires]+self.l[i]
               else:
                   res = res + self[i]
                   ires = ires+1
                   ireshash = self.hashlayer[i]
        else:
             res = self.copy()
        return res

    # --------------------------------------------------------------------
    # Split layers into a tuple
    # --------------------------------------------------------------------
    def split(self):
        &#34;&#34;&#34; split layers &#34;&#34;&#34;
        out = ()
        if self._nlayer&gt;0:
            for i in range(self._nlayer):
                out = out + (self[i],) # (,) special syntax for tuple singleton
        return out

    # --------------------------------------------------------------------
    # deepcopy
    # --------------------------------------------------------------------
    def copy(self,**kwargs):
        &#34;&#34;&#34;
        Creates a deep copy of the current layer instance.

        Returns:
        - layer: A new layer instance identical to the original.
        &#34;&#34;&#34;
        return duplicate(self).update(**kwargs)

    # --------------------------------------------------------------------
    # update contact conditions from a foodphysics instance (or do the reverse)
    # material &lt;&lt; medium
    # --------------------------------------------------------------------
    def _from(self,medium=None):
        &#34;&#34;&#34;Propagates contact conditions from food instance&#34;&#34;&#34;
        from patankar.food import foodphysics
        if not isinstance(medium,foodphysics):
            raise TypeError(f&#34;medium must be a foodphysics, foodlayer not a {type(medium).__name__}&#34;)
        if not hasattr(medium, &#34;contacttemperature&#34;):
            medium.contacttemperature = self.T[0]
        T = self.get_param(&#34;contacttemperature&#34;,40,acceptNone=False)
        self.T = np.full_like(self.T,T)

    # overloading operation
    def __lshift__(self, medium):
        &#34;&#34;&#34;Overloads &lt;&lt; to propagate contact conditions from food.&#34;&#34;&#34;
        self._from(medium)

    # --------------------------------------------------------------------
    # Inheritance registration mechanism associated with food &gt;&gt; layer
    # It is used by food, not by layer (please refer to food.py).
    # Note that layer &gt;&gt; food means mass transfer simulation
    # --------------------------------------------------------------------
    def acknowledge(self, what=None, category=None):
        &#34;&#34;&#34;
        Register inherited properties under a given category.

        Parameters:
        -----------
        what : str or list of str or a set
            The properties or attributes that have been inherited.
        category : str
            The category under which the properties are grouped.
        &#34;&#34;&#34;
        if category is None or what is None:
            raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
        if isinstance(what, str):
            what = {what}  # Convert string to a set
        elif isinstance(what, list):
            what = set(what)  # Convert list to a set for uniqueness
        elif not isinstance(what,set):
            raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
        if category not in self._hasbeeninherited:
            self._hasbeeninherited[category] = set()
        self._hasbeeninherited[category].update(what)

    # --------------------------------------------------------------------
    # migration simulation overloaded as sim = layer &gt;&gt; food
    # using layer &gt;&gt; food without output works also.
    # The result is stored in food.lastsimulation
    # --------------------------------------------------------------------
    def contact(self,medium,**kwargs):
        return self.migration(medium,**kwargs)

    def migration(self,medium,**kwargs):
        from patankar.migration import senspatankar
        sim = senspatankar(self,medium,**kwargs)
        medium.lastsimulation = sim # store the last simulation result in medium
        medium.lastinput = self # store the last input (self)
        sim.savestate(self,medium) # store store the inputs in sim for chaining
        return sim

    # overloading operation
    def __rshift__(self, medium):
        &#34;&#34;&#34;Overloads &gt;&gt; to propagate migration to food.&#34;&#34;&#34;
        from patankar.food import foodphysics
        if not isinstance(medium,foodphysics):
            raise TypeError(f&#34;medium must be a foodphysics object not a {type(medium).__name__}&#34;)
        return self.contact(medium)

    # --------------------------------------------------------------------
    # Safe update method
    # --------------------------------------------------------------------
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update layer parameters following strict validation rules.

        Rules:
        1) key should be listed in self._defaults
        2) for some keys, synonyms are acceptable as reported in self._synonyms
        3) values cannot be None if they were not None in _defaults
        4) values should be str if they were initially str, idem with bool
        5) values which were numeric (int, float, np.ndarray) should remain numeric.
        6) lists are acceptable as numeric arrays
        7) all numerical (float, np.ndarray, list) except int must be converted into numpy arrays.
           Values which were int in _defaults must remain int and an error should be raised
           if a float value is proposed.
        8) keys listed in _parametersWithUnits can be assigned with tuples (value, &#34;unit&#34;).
           They will be converted automatically with check_units(value).
        9) for parameters with a default value None, any value is acceptable
        10) A clear error message should be displayed for any bad value showing the
            current value of the parameter and its default value.
        &#34;&#34;&#34;

        if not kwargs:  # shortcut
            return self # for chaining

        param_counts = {key: 0 for key in self._defaults}  # Track how many times each param is set

        def resolve_key(key):
            &#34;&#34;&#34;Resolve key considering synonyms and check for duplicates.&#34;&#34;&#34;
            for main_key, synonyms in self._synonyms.items():
                if key == main_key or key in synonyms:
                    param_counts[main_key] += 1
                    return main_key
            param_counts[key] += 1
            return key

        def validate_value(key, value):
            &#34;&#34;&#34;Validate and process the value according to the rules.&#34;&#34;&#34;
            default_value = self._defaults[key]

            # Rule 3: values cannot be None if they were not None in _defaults
            if value is None and default_value is not None:
                raise ValueError(f&#34;Invalid value for &#39;{key}&#39;: None is not allowed. &#34;
                                 f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 9: If default is None, any value is acceptable
            if default_value is None:
                return value

            # Rule 4 &amp; 5: Ensure type consistency (str, bool, or numeric types)
            if isinstance(default_value, str) and not isinstance(value, str):
                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected str, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
            if isinstance(default_value, bool) and not isinstance(value, bool):
                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected bool, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 6 &amp; 7: Convert numeric types properly
            if isinstance(default_value, (int, float, np.ndarray)):
                if isinstance(value, list):
                    value = np.array(value)

                if isinstance(default_value, int):
                    if isinstance(value, float) or (isinstance(value, np.ndarray) and np.issubdtype(value.dtype, np.floating)):
                        raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got float. &#34;
                                        f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
                    if isinstance(value, (int, np.integer)):
                        return int(value)  # Ensure it remains an int
                    raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got {type(value).__name__}. &#34;
                                    f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

                if isinstance(value, (int, float, list, np.ndarray)):
                    return np.array(value, dtype=float)  # Convert everything to np.array for floats

                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected numeric, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            # Rule 8: Convert units if applicable
            if key in self._parametersWithUnits and isinstance(value, tuple):
                value, unit = value
                converted_value, _ = check_units((value, unit), ExpectedUnits=self._parametersWithUnits[key])
                return converted_value

            return value

        # Apply updates while tracking parameter occurrences
        for key, value in kwargs.items():
            resolved_key = resolve_key(key)

            if resolved_key not in self._defaults:
                raise KeyError(f&#34;Invalid key &#39;{key}&#39;. Allowed keys: {list(self._defaults.keys())}.&#34;)

            try:
                validated_value = validate_value(resolved_key, value)
                setattr(self, resolved_key, validated_value)
            except (TypeError, ValueError) as e:
                raise ValueError(f&#34;Error updating &#39;{key}&#39;: {e}&#34;)

        # Ensure that no parameter was set multiple times due to synonyms
        duplicate_keys = [k for k, v in param_counts.items() if v &gt; 1]
        if duplicate_keys:
            raise ValueError(f&#34;Duplicate assignment detected for parameters: {duplicate_keys}. &#34;
                             &#34;Use only one synonym per parameter.&#34;)

        return self # to enable chaining</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="layer.AdhesiveAcrylate" href="#layer.AdhesiveAcrylate">AdhesiveAcrylate</a></li>
<li><a title="layer.AdhesiveEVA" href="#layer.AdhesiveEVA">AdhesiveEVA</a></li>
<li><a title="layer.AdhesiveNaturalRubber" href="#layer.AdhesiveNaturalRubber">AdhesiveNaturalRubber</a></li>
<li><a title="layer.AdhesivePU" href="#layer.AdhesivePU">AdhesivePU</a></li>
<li><a title="layer.AdhesivePVAC" href="#layer.AdhesivePVAC">AdhesivePVAC</a></li>
<li><a title="layer.AdhesiveSyntheticRubber" href="#layer.AdhesiveSyntheticRubber">AdhesiveSyntheticRubber</a></li>
<li><a title="layer.AdhesiveVAE" href="#layer.AdhesiveVAE">AdhesiveVAE</a></li>
<li><a title="layer.Cardboard" href="#layer.Cardboard">Cardboard</a></li>
<li><a title="layer.HDPE" href="#layer.HDPE">HDPE</a></li>
<li><a title="layer.HIPS" href="#layer.HIPS">HIPS</a></li>
<li><a title="layer.LDPE" href="#layer.LDPE">LDPE</a></li>
<li><a title="layer.LLDPE" href="#layer.LLDPE">LLDPE</a></li>
<li><a title="layer.PA6" href="#layer.PA6">PA6</a></li>
<li><a title="layer.PA66" href="#layer.PA66">PA66</a></li>
<li><a title="layer.PBT" href="#layer.PBT">PBT</a></li>
<li><a title="layer.PEN" href="#layer.PEN">PEN</a></li>
<li><a title="layer.PP" href="#layer.PP">PP</a></li>
<li><a title="layer.PPrubber" href="#layer.PPrubber">PPrubber</a></li>
<li><a title="layer.PS" href="#layer.PS">PS</a></li>
<li><a title="layer.Paper" href="#layer.Paper">Paper</a></li>
<li><a title="layer.SBS" href="#layer.SBS">SBS</a></li>
<li><a title="layer.air" href="#layer.air">air</a></li>
<li><a title="layer.gPET" href="#layer.gPET">gPET</a></li>
<li><a title="layer.oPP" href="#layer.oPP">oPP</a></li>
<li><a title="layer.plasticizedPVC" href="#layer.plasticizedPVC">plasticizedPVC</a></li>
<li><a title="layer.rPET" href="#layer.rPET">rPET</a></li>
<li><a title="layer.rigidPVC" href="#layer.rigidPVC">rigidPVC</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="layer.layer.help"><code class="name flex">
<span>def <span class="ident">help</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a dynamically formatted summary of all input parameters,
adjusting column widths based on content and wrapping long descriptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def help(cls):
    &#34;&#34;&#34;
    Prints a dynamically formatted summary of all input parameters,
    adjusting column widths based on content and wrapping long descriptions.
    &#34;&#34;&#34;

    # Column Headers
    headers = [&#34;Parameter&#34;, &#34;Default Value&#34;, &#34;Has Synonyms?&#34;, &#34;Description&#34;]
    col_widths = [len(h) for h in headers]  # Start with header widths

    # Collect Data Rows
    rows = []
    for param, default in cls._defaults.items():
        has_synonyms = &#34;✅ Yes&#34; if param in cls._synonyms else &#34;❌ No&#34;
        description = cls._descriptionInputs.get(param, &#34;No description available&#34;)

        # Update column widths dynamically
        col_widths[0] = max(col_widths[0], len(param))
        col_widths[1] = max(col_widths[1], len(str(default)))
        col_widths[2] = max(col_widths[2], len(has_synonyms))
        col_widths[3] = max(col_widths[3], len(description))

        rows.append([param, str(default), has_synonyms, description])

    # Function to wrap text for a given column width
    def wrap_text(text, width):
        return textwrap.fill(text, width)

    # Print Table with Adjusted Column Widths
    separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in col_widths) + &#34;-+&#34;
    print(&#34;\n### **Accepted Parameters and Defaults**\n&#34;)
    print(separator)
    print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(col_widths[i]) for i, h in enumerate(headers)) + &#34; |&#34;)
    print(separator)
    for row in rows:
        # Wrap text in the description column
        row[3] = wrap_text(row[3], col_widths[3])

        # Print row
        print(&#34;| &#34; + &#34; | &#34;.join(row[i].ljust(col_widths[i]) for i in range(3)) + &#34; | &#34; + row[3])
    print(separator)

    # Synonyms Table
    print(&#34;\n### **Parameter Synonyms**\n&#34;)
    syn_headers = [&#34;Parameter&#34;, &#34;Synonyms&#34;]
    syn_col_widths = [
        max(len(&#34;Parameter&#34;), max(len(k) for k in cls._synonyms.keys())),  # Ensure it fits &#34;Parameter&#34;
        max(len(&#34;Synonyms&#34;), max(len(&#34;, &#34;.join(v)) for v in cls._synonyms.values()))  # Ensure it fits &#34;Synonyms&#34;
    ]
    syn_separator = &#34;+-&#34; + &#34;-+-&#34;.join(&#34;-&#34; * w for w in syn_col_widths) + &#34;-+&#34;
    print(syn_separator)
    print(&#34;| &#34; + &#34; | &#34;.join(h.ljust(syn_col_widths[i]) for i, h in enumerate(syn_headers)) + &#34; |&#34;)
    print(syn_separator)
    for param, synonyms in cls._synonyms.items():
        print(f&#34;| {param.ljust(syn_col_widths[0])} | {&#39;, &#39;.join(synonyms).ljust(syn_col_widths[1])} |&#34;)
    print(syn_separator)</code></pre>
</details>
</dd>
<dt id="layer.layer.resolvename"><code class="name flex">
<span>def <span class="ident">resolvename</span></span>(<span>param_value, param_key, **unresolved)</span>
</code></dt>
<dd>
<div class="desc"><p>Resolves the correct parameter value using known synonyms.</p>
<ul>
<li>If param_value is already set (not None), return it.</li>
<li>If a synonym exists in **unresolved, assign its value.</li>
<li>If multiple synonyms of the same parameter appear in **unresolved, raise an error.</li>
<li>Otherwise, return None.</li>
</ul>
<p>Parameters:
- <code>param_name</code> (any): The original value (if provided).
- <code>param_key</code> (str): The legitimate parameter name we are resolving.
- <code>unresolved</code> (dict): The dictionary of unrecognized keyword arguments.</p>
<p>Returns:
- The resolved value or None if not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def resolvename(cls, param_value, param_key, **unresolved):
    &#34;&#34;&#34;
    Resolves the correct parameter value using known synonyms.

    - If param_value is already set (not None), return it.
    - If a synonym exists in **unresolved, assign its value.
    - If multiple synonyms of the same parameter appear in **unresolved, raise an error.
    - Otherwise, return None.

    Parameters:
    - `param_name` (any): The original value (if provided).
    - `param_key` (str): The legitimate parameter name we are resolving.
    - `unresolved` (dict): The dictionary of unrecognized keyword arguments.

    Returns:
    - The resolved value or None if not found.
    &#34;&#34;&#34;
    if param_value is not None:
        return param_value  # The parameter is explicitly defined, do not override
    if not unresolved:      # shortcut
        return None
    resolved_value = None
    found_keys = []
    # Check if param_key itself is present in unresolved
    if param_key in unresolved:
        found_keys.append(param_key)
        resolved_value = unresolved[param_key]
    # Check if any of its synonyms are in unresolved
    if param_key in cls._synonyms:
        for synonym in cls._synonyms[param_key]:
            if synonym in unresolved:
                found_keys.append(synonym)
                resolved_value = unresolved[synonym]
    # Raise error if multiple synonyms were found
    if len(found_keys) &gt; 1:
        raise ValueError(
            f&#34;Conflicting definitions: Multiple synonyms {found_keys} were provided for &#39;{param_key}&#39;.&#34;
        )
    return resolved_value</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="layer.layer.C0"><code class="name">var <span class="ident">C0</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def C0(self): return self._C0</code></pre>
</details>
</dd>
<dt id="layer.layer.Cunit"><code class="name">var <span class="ident">Cunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Cunit(self): return self._Cunit</code></pre>
</details>
</dd>
<dt id="layer.layer.D"><code class="name">var <span class="ident">D</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def D(self):
    Dtmp = self.Dmodel()
    if Dtmp is not None:
        return np.full_like(self._D, Dtmp)
    else:
        return self._D</code></pre>
</details>
</dd>
<dt id="layer.layer.Dmodel"><code class="name">var <span class="ident">Dmodel</span></code></dt>
<dd>
<div class="desc"><p>Return a callable function that evaluates D with updated parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Dmodel(self):
    &#34;&#34;&#34;Return a callable function that evaluates D with updated parameters.&#34;&#34;&#34;
    if not isinstance(self._substance,migrant) or self._substance.Deval() is None:
        return lambda **kwargs: None  # Return a function that always returns None
    template = self._substance.Dtemplate.copy()
    template.update()
    def func(**kwargs):
        D = np.empty_like(self._D)
        for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
            template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
            # inherit eventual user parameters
            D[i] = self._substance.D.evaluate(**dict(template, **kwargs))
        return D
    return func</code></pre>
</details>
</dd>
<dt id="layer.layer.Dunit"><code class="name">var <span class="ident">Dunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Dunit(self): return self._Dunit</code></pre>
</details>
</dd>
<dt id="layer.layer.Foscale"><code class="name">var <span class="ident">Foscale</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Foscale(self): return self.D[self.referencelayer]/self.lreferencelayer**2</code></pre>
</details>
</dd>
<dt id="layer.layer.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def T(self): return self._T</code></pre>
</details>
</dd>
<dt id="layer.layer.TK"><code class="name">var <span class="ident">TK</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def TK(self): return self._T+T0K</code></pre>
</details>
</dd>
<dt id="layer.layer.TKunit"><code class="name">var <span class="ident">TKunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def TKunit(self): return &#34;K&#34;</code></pre>
</details>
</dd>
<dt id="layer.layer.Tunit"><code class="name">var <span class="ident">Tunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tunit(self): return self._Tunit</code></pre>
</details>
</dd>
<dt id="layer.layer.code"><code class="name">var <span class="ident">code</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def code(self): return self._code</code></pre>
</details>
</dd>
<dt id="layer.layer.concentration"><code class="name">var <span class="ident">concentration</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def concentration(self): return sum(self.l*self.C0)/self.thickness</code></pre>
</details>
</dd>
<dt id="layer.layer.hashlayer"><code class="name">var <span class="ident">hashlayer</span></code></dt>
<dd>
<div class="desc"><p>hash layer (layer-by-layer) method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def hashlayer(self):
    &#34;&#34;&#34; hash layer (layer-by-layer) method &#34;&#34;&#34;
    return [hash((self._name[n],
                  self._type[n],
                  self._material[n],
                  self._l[n],
                  self._D[n],
                  self.k[n],
                  self._C0[n],
                  self._rho[n]))
            for n in range(self._nlayer)
            ]</code></pre>
</details>
</dd>
<dt id="layer.layer.k"><code class="name">var <span class="ident">k</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def k(self):
    ktmp = self.kmodel()
    if ktmp:
        return np.full_like(self._D, ktmp)
    else:
        return self._k</code></pre>
</details>
</dd>
<dt id="layer.layer.kmodel"><code class="name">var <span class="ident">kmodel</span></code></dt>
<dd>
<div class="desc"><p>Return a callable function that evaluates k with updated parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kmodel(self):
    &#34;&#34;&#34;Return a callable function that evaluates k with updated parameters.&#34;&#34;&#34;
    if not isinstance(self._substance,migrant) or self._substance.keval() is None:
        return lambda **kwargs: None  # Return a function that always returns None
    template = self._substance.ktemplate.copy()
    template.update()
    def func(**kwargs):
        k = np.empty_like(self._k)
        for (i,),T in np.ndenumerate(self.T.ravel()): # loop over all layers via T
            template.update(polymer=self.layerclass_history[i],T=T) # updated layer properties
            # inherit eventual user parameters
            k[i] = self._substance.k.evaluate(**dict(template, **kwargs))
        return k
    return func</code></pre>
</details>
</dd>
<dt id="layer.layer.kunit"><code class="name">var <span class="ident">kunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def kunit(self): return self._kunit</code></pre>
</details>
</dd>
<dt id="layer.layer.l"><code class="name">var <span class="ident">l</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def l(self): return self._l</code></pre>
</details>
</dd>
<dt id="layer.layer.lag"><code class="name">var <span class="ident">lag</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lag(self): return self.l**2/(6*self.D)</code></pre>
</details>
</dd>
<dt id="layer.layer.layerclass"><code class="name">var <span class="ident">layerclass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def layerclass(self): return type(self).__name__</code></pre>
</details>
</dd>
<dt id="layer.layer.layerclass_history"><code class="name">var <span class="ident">layerclass_history</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def layerclass_history(self):
    return self._layerclass_history if self._layerclass_history != [] else [self.layerclass]</code></pre>
</details>
</dd>
<dt id="layer.layer.lreferencelayer"><code class="name">var <span class="ident">lreferencelayer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lreferencelayer(self): return self.l[self.referencelayer]</code></pre>
</details>
</dd>
<dt id="layer.layer.lunit"><code class="name">var <span class="ident">lunit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lunit(self): return self._lunit</code></pre>
</details>
</dd>
<dt id="layer.layer.material"><code class="name">var <span class="ident">material</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def material(self): return self._material</code></pre>
</details>
</dd>
<dt id="layer.layer.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self): return self._nlayer</code></pre>
</details>
</dd>
<dt id="layer.layer.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self): return self._name</code></pre>
</details>
</dd>
<dt id="layer.layer.nmesh"><code class="name">var <span class="ident">nmesh</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nmesh(self): return self._nmesh</code></pre>
</details>
</dd>
<dt id="layer.layer.nmeshmin"><code class="name">var <span class="ident">nmeshmin</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nmeshmin(self): return self._nmeshmin</code></pre>
</details>
</dd>
<dt id="layer.layer.permeability"><code class="name">var <span class="ident">permeability</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def permeability(self): return self.D/(self.l*self.k)</code></pre>
</details>
</dd>
<dt id="layer.layer.pressure"><code class="name">var <span class="ident">pressure</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pressure(self): return self.k*self.C0</code></pre>
</details>
</dd>
<dt id="layer.layer.rank"><code class="name">var <span class="ident">rank</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rank(self): return np.flip(np.argsort(np.array(self.resistance))+1).tolist()</code></pre>
</details>
</dd>
<dt id="layer.layer.referencelayer"><code class="name">var <span class="ident">referencelayer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def referencelayer(self): return np.argmax(self.resistance)</code></pre>
</details>
</dd>
<dt id="layer.layer.relative_resistance"><code class="name">var <span class="ident">relative_resistance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relative_resistance(self): return self.resistance/sum(self.resistance)</code></pre>
</details>
</dd>
<dt id="layer.layer.relative_thickness"><code class="name">var <span class="ident">relative_thickness</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def relative_thickness(self): return self.l/self.thickness</code></pre>
</details>
</dd>
<dt id="layer.layer.resistance"><code class="name">var <span class="ident">resistance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resistance(self): return self.l*self.k/self.D</code></pre>
</details>
</dd>
<dt id="layer.layer.rho"><code class="name">var <span class="ident">rho</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rho(self): return self._rho</code></pre>
</details>
</dd>
<dt id="layer.layer.rhounit"><code class="name">var <span class="ident">rhounit</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rhounit(self): return self._rhounit</code></pre>
</details>
</dd>
<dt id="layer.layer.substance"><code class="name">var <span class="ident">substance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def substance(self): return self._substance</code></pre>
</details>
</dd>
<dt id="layer.layer.thickness"><code class="name">var <span class="ident">thickness</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def thickness(self): return sum(self.l)</code></pre>
</details>
</dd>
<dt id="layer.layer.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self): return self._type</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.layer.acknowledge"><code class="name flex">
<span>def <span class="ident">acknowledge</span></span>(<span>self, what=None, category=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Register inherited properties under a given category.</p>
<h2 id="parameters">Parameters:</h2>
<p>what : str or list of str or a set
The properties or attributes that have been inherited.
category : str
The category under which the properties are grouped.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acknowledge(self, what=None, category=None):
    &#34;&#34;&#34;
    Register inherited properties under a given category.

    Parameters:
    -----------
    what : str or list of str or a set
        The properties or attributes that have been inherited.
    category : str
        The category under which the properties are grouped.
    &#34;&#34;&#34;
    if category is None or what is None:
        raise ValueError(&#34;Both &#39;what&#39; and &#39;category&#39; must be provided.&#34;)
    if isinstance(what, str):
        what = {what}  # Convert string to a set
    elif isinstance(what, list):
        what = set(what)  # Convert list to a set for uniqueness
    elif not isinstance(what,set):
        raise TypeError(&#34;&#39;what&#39; must be a string, a list, or a set of strings.&#34;)
    if category not in self._hasbeeninherited:
        self._hasbeeninherited[category] = set()
    self._hasbeeninherited[category].update(what)</code></pre>
</details>
</dd>
<dt id="layer.layer.checknumvalue"><code class="name flex">
<span>def <span class="ident">checknumvalue</span></span>(<span>self, value, ExpectedUnits=None)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a validate value to set properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checknumvalue(self,value,ExpectedUnits=None):
    &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
    if isinstance(value,tuple):
        value = check_units(value,ExpectedUnits=ExpectedUnits)
    if isinstance(value,int): value = float(value)
    if isinstance(value,float): value = np.array([value])
    if isinstance(value,list): value = np.array(value)
    if len(value)&gt;self._nlayer:
        value = value[:self._nlayer]
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the extra value(s) has been removed&#39;)
    elif len(value)&lt;self._nlayer:
        value = np.concatenate((value,value[-1:]*np.ones(self._nlayer-len(value))))
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the last value has been repeated&#39;)
    return value</code></pre>
</details>
</dd>
<dt id="layer.layer.checktextvalue"><code class="name flex">
<span>def <span class="ident">checktextvalue</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a validate value to set properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checktextvalue(self,value):
    &#34;&#34;&#34; returns a validate value to set properties &#34;&#34;&#34;
    if not isinstance(value,list): value = [value]
    if len(value)&gt;self._nlayer:
        value = value[:self._nlayer]
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the extra entry(ies) has been removed&#39;)
    elif len(value)&lt;self._nlayer:
        value = value + value[-1:]*(self._nlayer-len(value))
        if self.verbosity&gt;1 and self.verbose:
            print(&#39;dimension mismatch, the last entry has been repeated&#39;)
    return value</code></pre>
</details>
</dd>
<dt id="layer.layer.contact"><code class="name flex">
<span>def <span class="ident">contact</span></span>(<span>self, medium, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contact(self,medium,**kwargs):
    return self.migration(medium,**kwargs)</code></pre>
</details>
</dd>
<dt id="layer.layer.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a deep copy of the current layer instance.</p>
<p>Returns:
- layer: A new layer instance identical to the original.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self,**kwargs):
    &#34;&#34;&#34;
    Creates a deep copy of the current layer instance.

    Returns:
    - layer: A new layer instance identical to the original.
    &#34;&#34;&#34;
    return duplicate(self).update(**kwargs)</code></pre>
</details>
</dd>
<dt id="layer.layer.mesh"><code class="name flex">
<span>def <span class="ident">mesh</span></span>(<span>self, nmesh=None, nmeshmin=None)</span>
</code></dt>
<dd>
<div class="desc"><p>nmesh() generates mesh based on nmesh and nmeshmin, nmesh(nmesh=value,nmeshmin=value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mesh(self,nmesh=None,nmeshmin=None):
    &#34;&#34;&#34; nmesh() generates mesh based on nmesh and nmeshmin, nmesh(nmesh=value,nmeshmin=value) &#34;&#34;&#34;
    if nmesh==None: nmesh = self.nmesh
    if nmeshmin==None: nmeshmin = self.nmeshmin
    if nmeshmin&gt;nmesh: nmeshmin,nmesh = nmesh, nmeshmin
    # X = mesh distribution (number of nodes per layer)
    X = np.ones(self._nlayer)
    for i in range(1,self._nlayer):
       X[i] = X[i-1]*(self.permeability[i-1]*self.l[i])/(self.permeability[i]*self.l[i-1])
    X = np.maximum(nmeshmin,np.ceil(nmesh*X/sum(X)))
    X = np.round((X/sum(X))*nmesh).astype(int)
    # do the mesh
    x0 = 0
    mymesh = []
    for i in range(self._nlayer):
        mymesh.append(mesh(self.l[i]/self.l[self.referencelayer],X[i],x0=x0,index=i))
        x0 += self.l[i]
    return mymesh</code></pre>
</details>
</dd>
<dt id="layer.layer.migration"><code class="name flex">
<span>def <span class="ident">migration</span></span>(<span>self, medium, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def migration(self,medium,**kwargs):
    from patankar.migration import senspatankar
    sim = senspatankar(self,medium,**kwargs)
    medium.lastsimulation = sim # store the last simulation result in medium
    medium.lastinput = self # store the last input (self)
    sim.savestate(self,medium) # store store the inputs in sim for chaining
    return sim</code></pre>
</details>
</dd>
<dt id="layer.layer.simplify"><code class="name flex">
<span>def <span class="ident">simplify</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>merge continuous layers of the same type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simplify(self):
    &#34;&#34;&#34; merge continuous layers of the same type &#34;&#34;&#34;
    nlayer = self._nlayer
    if nlayer&gt;1:
       res = self[0]
       ires = 0
       ireshash = res.hashlayer[0]
       for i in range(1,nlayer):
           if self.hashlayer[i]==ireshash:
               res.l[ires] = res.l[ires]+self.l[i]
           else:
               res = res + self[i]
               ires = ires+1
               ireshash = self.hashlayer[i]
    else:
         res = self.copy()
    return res</code></pre>
</details>
</dd>
<dt id="layer.layer.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>split layers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self):
    &#34;&#34;&#34; split layers &#34;&#34;&#34;
    out = ()
    if self._nlayer&gt;0:
        for i in range(self._nlayer):
            out = out + (self[i],) # (,) special syntax for tuple singleton
    return out</code></pre>
</details>
</dd>
<dt id="layer.layer.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update layer parameters following strict validation rules.</p>
<p>Rules:
1) key should be listed in self._defaults
2) for some keys, synonyms are acceptable as reported in self._synonyms
3) values cannot be None if they were not None in _defaults
4) values should be str if they were initially str, idem with bool
5) values which were numeric (int, float, np.ndarray) should remain numeric.
6) lists are acceptable as numeric arrays
7) all numerical (float, np.ndarray, list) except int must be converted into numpy arrays.
Values which were int in _defaults must remain int and an error should be raised
if a float value is proposed.
8) keys listed in _parametersWithUnits can be assigned with tuples (value, "unit").
They will be converted automatically with check_units(value).
9) for parameters with a default value None, any value is acceptable
10) A clear error message should be displayed for any bad value showing the
current value of the parameter and its default value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update layer parameters following strict validation rules.

    Rules:
    1) key should be listed in self._defaults
    2) for some keys, synonyms are acceptable as reported in self._synonyms
    3) values cannot be None if they were not None in _defaults
    4) values should be str if they were initially str, idem with bool
    5) values which were numeric (int, float, np.ndarray) should remain numeric.
    6) lists are acceptable as numeric arrays
    7) all numerical (float, np.ndarray, list) except int must be converted into numpy arrays.
       Values which were int in _defaults must remain int and an error should be raised
       if a float value is proposed.
    8) keys listed in _parametersWithUnits can be assigned with tuples (value, &#34;unit&#34;).
       They will be converted automatically with check_units(value).
    9) for parameters with a default value None, any value is acceptable
    10) A clear error message should be displayed for any bad value showing the
        current value of the parameter and its default value.
    &#34;&#34;&#34;

    if not kwargs:  # shortcut
        return self # for chaining

    param_counts = {key: 0 for key in self._defaults}  # Track how many times each param is set

    def resolve_key(key):
        &#34;&#34;&#34;Resolve key considering synonyms and check for duplicates.&#34;&#34;&#34;
        for main_key, synonyms in self._synonyms.items():
            if key == main_key or key in synonyms:
                param_counts[main_key] += 1
                return main_key
        param_counts[key] += 1
        return key

    def validate_value(key, value):
        &#34;&#34;&#34;Validate and process the value according to the rules.&#34;&#34;&#34;
        default_value = self._defaults[key]

        # Rule 3: values cannot be None if they were not None in _defaults
        if value is None and default_value is not None:
            raise ValueError(f&#34;Invalid value for &#39;{key}&#39;: None is not allowed. &#34;
                             f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

        # Rule 9: If default is None, any value is acceptable
        if default_value is None:
            return value

        # Rule 4 &amp; 5: Ensure type consistency (str, bool, or numeric types)
        if isinstance(default_value, str) and not isinstance(value, str):
            raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected str, got {type(value).__name__}. &#34;
                            f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
        if isinstance(default_value, bool) and not isinstance(value, bool):
            raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected bool, got {type(value).__name__}. &#34;
                            f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

        # Rule 6 &amp; 7: Convert numeric types properly
        if isinstance(default_value, (int, float, np.ndarray)):
            if isinstance(value, list):
                value = np.array(value)

            if isinstance(default_value, int):
                if isinstance(value, float) or (isinstance(value, np.ndarray) and np.issubdtype(value.dtype, np.floating)):
                    raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got float. &#34;
                                    f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)
                if isinstance(value, (int, np.integer)):
                    return int(value)  # Ensure it remains an int
                raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected integer, got {type(value).__name__}. &#34;
                                f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

            if isinstance(value, (int, float, list, np.ndarray)):
                return np.array(value, dtype=float)  # Convert everything to np.array for floats

            raise TypeError(f&#34;Invalid type for &#39;{key}&#39;: Expected numeric, got {type(value).__name__}. &#34;
                            f&#34;Current: {getattr(self, key)}, Default: {default_value}&#34;)

        # Rule 8: Convert units if applicable
        if key in self._parametersWithUnits and isinstance(value, tuple):
            value, unit = value
            converted_value, _ = check_units((value, unit), ExpectedUnits=self._parametersWithUnits[key])
            return converted_value

        return value

    # Apply updates while tracking parameter occurrences
    for key, value in kwargs.items():
        resolved_key = resolve_key(key)

        if resolved_key not in self._defaults:
            raise KeyError(f&#34;Invalid key &#39;{key}&#39;. Allowed keys: {list(self._defaults.keys())}.&#34;)

        try:
            validated_value = validate_value(resolved_key, value)
            setattr(self, resolved_key, validated_value)
        except (TypeError, ValueError) as e:
            raise ValueError(f&#34;Error updating &#39;{key}&#39;: {e}&#34;)

    # Ensure that no parameter was set multiple times due to synonyms
    duplicate_keys = [k for k, v in param_counts.items() if v &gt; 1]
    if duplicate_keys:
        raise ValueError(f&#34;Duplicate assignment detected for parameters: {duplicate_keys}. &#34;
                         &#34;Use only one synonym per parameter.&#34;)

    return self # to enable chaining</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="layer.mesh"><code class="flex name class">
<span>class <span class="ident">mesh</span></span>
<span>(</span><span>l, n, x0=0, index=None)</span>
</code></dt>
<dd>
<div class="desc"><p>simple nodes class for finite-volume methods</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class mesh():
    &#34;&#34;&#34; simple nodes class for finite-volume methods &#34;&#34;&#34;
    def __init__(self,l,n,x0=0,index=None):
       self.x0 = x0
       self.l = l
       self.n = n
       de = dw = l/(2*n)
       self.de = np.ones(n)*de
       self.dw = np.ones(n)*dw
       self.xmesh = np.linspace(0+dw,l-de,n) # nodes positions
       self.w = self.xmesh - dw
       self.e = self.xmesh + de
       self.index = np.full(n, int(index), dtype=np.int32)

    def __repr__(self):
        print(f&#34;-- mesh object (layer index={self.index[0]}) --&#34;)
        print(&#34;%25s = %0.4g&#34; % (&#34;start at x0&#34;, self.x0))
        print(&#34;%25s = %0.4g&#34; % (&#34;domain length l&#34;, self.l))
        print(&#34;%25s = %0.4g&#34; % (&#34;number of nodes n&#34;, self.n))
        print(&#34;%25s = %0.4g&#34; % (&#34;dw&#34;, self.dw[0]))
        print(&#34;%25s = %0.4g&#34; % (&#34;de&#34;, self.de[0]))
        return &#34;mesh%d=[%0.4g %0.4g]&#34; % \
            (self.n,self.x0+self.xmesh[0],self.x0+self.xmesh[-1])</code></pre>
</details>
</dd>
<dt id="layer.migrant"><code class="flex name class">
<span>class <span class="ident">migrant</span></span>
<span>(</span><span>name=None, M=None, logP=None, Dmodel='Piringer', Dtemplate={'polymer': 'LLDPE', 'M': 50, 'T': 40}, kmodel=None, ktemplate={}, db=&lt;patankar.loadpubchem.CompoundIndex object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>A class representing a migrating chemical substance.</p>
<p>It can be initialized in three main ways:</p>
<p>1) Case (a) - By a textual name/CAS only (for a real compound search):</p>
<hr>
<p>Example:
m = migrant(name="anisole", db=my_compound_index)
# or
m = migrant(name="anisole", db=my_compound_index, M=None)
In this mode:
• A lookup is performed using db.find(name), which may return one or more records.
• If multiple records match, data from each record is merged:
- compound
= The text used in the query (e.g. "anisole")
- name
= Concatenation of all distinct names from the search results
- CAS
= Concatenation of all CAS numbers from the search results
- M
= The minimum of all found molecular weights, stored in self.M (a numpy array also keeps the full set)
- formula
= The first formula
- logP
= All logP values concatenated into a numpy array (self.logP_array).
The main attribute self.logP will be the same array or you may pick a single representative.</p>
<p>2) Case (b) - By numeric molecular weight(s) alone (generic substance):</p>
<hr>
<p>Example:
m = migrant(M=200)
m = migrant(M=[100, 500])
# Possibly a range
In this mode:
• No search is performed.
• name = "generic" (unless you override it).
• compound = "single molecular weight" if 1 entry in M, or
"list of molecular weights ranging from X to Y" if multiple.
• CAS = None
• M
= the minimum of all provided M values (also stored in a numpy array)
• logP = None by default, or can be supplied explicitly as an array</p>
<p>3) Case (c) - Name + numeric M/logP =&gt; Surrogate / hypothetical:</p>
<hr>
<p>Example:
m = migrant(name="mySurrogate", M=[200, 250], logP=[2.5, 3.0])
or
m = migrant(name="surrogate", M=200)
In this mode:
• No lookup is performed. This is a “fake” compound not found in PubChem.
• compound = "single molecular weight" or
"list of molecular weights ranging from X to Y" if multiple.
• name = whatever user provides
• CAS = None
• M
= min of the provided M array, stored in a numpy array
• logP = user-provided array or single float, stored in a numpy array</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>compound</code></strong> :&ensp;<code>str</code></dt>
<dd>For case (a) =&gt; the search text;
For case (b,c) =&gt; textual description of the numeric M array.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>For case (a) =&gt; aggregated list of all found names (string-joined);
For case (b) =&gt; "generic" or user-supplied name;
For case (c) =&gt; user-supplied name.</dd>
<dt><strong><code>CAS</code></strong> :&ensp;<code>list</code> or <code>None</code></dt>
<dd>For case (a) =&gt; aggregated CAS from search results;
For case (b,c) =&gt; None.</dd>
<dt><strong><code>M</code></strong> :&ensp;<code>float</code></dt>
<dd>The <em>minimum</em> M from either the search results or the user-supplied array.</dd>
<dt><strong><code>M_array</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>The full array of all M values found or provided.</dd>
<dt><strong><code>logP</code></strong> :&ensp;<code>float</code> or <code>numpy.ndarray</code> or <code>None</code></dt>
<dd>For case (a) =&gt; an array of all logP from the search results (or None if not found);
For case (b) =&gt; None or user-supplied value/array;
For case (c) =&gt; user-supplied value/array.</dd>
</dl>
<p>Create a new migrant instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>
<ul>
<li>A textual name for the substance to be looked up in PubChem (case a),
or a custom name for a surrogate (case c).</li>
<li>If None, and M is given, we treat it as a numeric-only initialization (case b).</li>
</ul>
</dd>
<dt><strong><code>M</code></strong> :&ensp;<code>float</code> or <code>list/ndarray</code> of <code>float</code> or <code>None</code></dt>
<dd>
<ul>
<li>For case (a): If provided as None, we do a PubChem search by name.</li>
<li>For case (b): The numeric molecular weight(s). No search is performed if name is None.</li>
<li>For case (c): Combined name and numeric M =&gt; a surrogate with no search.</li>
</ul>
</dd>
<dt><strong><code>logP</code></strong> :&ensp;<code>float</code> or <code>list/ndarray</code> of <code>float</code> or <code>None</code></dt>
<dd>
<ul>
<li>For case (a): Typically None. If the PubChem search returns logP, it’s stored automatically.</li>
<li>For case (b,c): user can supply. If given, stored in self.logP as a numpy array.</li>
</ul>
</dd>
<dt><strong><code>db</code></strong> :&ensp;<code>instance</code> of <code>CompoundIndex</code> or <code>similar</code>, optional</dt>
<dd>
<ul>
<li>If you want to perform a PubChem search (case a) automatically, pass an instance.</li>
<li>If omitted or None, no search is attempted, even if name is given.</li>
</ul>
</dd>
</dl>
<h2 id="advanced-parameters">Advanced Parameters</h2>
<p>Property models from MigrationPropertyModels can be directly attached to the substance.
Based on the current version of migration.py two models are proposed:
- Set a diffusivity model using
- Dmodel="model name"
default ="Piringer"
- Dtemplate=template dict coding for the key:value parameters
(e.g, to bed used Diringer(key1=value1&hellip;))
note: the template needs to be valid (do not use None)
default = {"polymer":None, "M":None, "T":None}
- Set a Henri-like model using
- kmodel="model name"
default =None
- ktemplate=template dict coding for the key:value parameters
default = {}
other models could be implemented in the future, read the module property.py for details.</p>
<p>Example of usage of Dpiringer
m = migrant(name='limonene')
# without the helper function
Dvalue = m.D.evaluate(**dict(m.Dtemplate,polymer="LDPE",T=60))
# with the helper function
Dvalue = m.Deval(polymer="LDPE",T=60)</p>
<h2 id="raises">Raises</h2>
<p>ValueError if insufficient arguments are provided for any scenario.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class migrant:
    &#34;&#34;&#34;
    A class representing a migrating chemical substance.

    It can be initialized in three main ways:

    1) Case (a) - By a textual name/CAS only (for a real compound search):
       ---------------------------------------------------------
       Example:
           m = migrant(name=&#34;anisole&#34;, db=my_compound_index)
           # or
           m = migrant(name=&#34;anisole&#34;, db=my_compound_index, M=None)
       In this mode:
         • A lookup is performed using db.find(name), which may return one or more records.
         • If multiple records match, data from each record is merged:
             - compound  = The text used in the query (e.g. &#34;anisole&#34;)
             - name      = Concatenation of all distinct names from the search results
             - CAS       = Concatenation of all CAS numbers from the search results
             - M         = The minimum of all found molecular weights, stored in self.M (a numpy array also keeps the full set)
             - formula   = The first formula
             - logP      = All logP values concatenated into a numpy array (self.logP_array).
                           The main attribute self.logP will be the same array or you may pick a single representative.

    2) Case (b) - By numeric molecular weight(s) alone (generic substance):
       ---------------------------------------------------------
       Example:
           m = migrant(M=200)
           m = migrant(M=[100, 500])  # Possibly a range
       In this mode:
         • No search is performed.
         • name = &#34;generic&#34; (unless you override it).
         • compound = &#34;single molecular weight&#34; if 1 entry in M, or
                      &#34;list of molecular weights ranging from X to Y&#34; if multiple.
         • CAS = None
         • M   = the minimum of all provided M values (also stored in a numpy array)
         • logP = None by default, or can be supplied explicitly as an array

    3) Case (c) - Name + numeric M/logP =&gt; Surrogate / hypothetical:
       ---------------------------------------------------------
       Example:
           m = migrant(name=&#34;mySurrogate&#34;, M=[200, 250], logP=[2.5, 3.0])
         or
           m = migrant(name=&#34;surrogate&#34;, M=200)
       In this mode:
         • No lookup is performed. This is a “fake” compound not found in PubChem.
         • compound = &#34;single molecular weight&#34; or
                      &#34;list of molecular weights ranging from X to Y&#34; if multiple.
         • name = whatever user provides
         • CAS = None
         • M   = min of the provided M array, stored in a numpy array
         • logP = user-provided array or single float, stored in a numpy array

    Attributes
    ----------
    compound : str
        For case (a) =&gt; the search text;
        For case (b,c) =&gt; textual description of the numeric M array.
    name : str or list
        For case (a) =&gt; aggregated list of all found names (string-joined);
        For case (b) =&gt; &#34;generic&#34; or user-supplied name;
        For case (c) =&gt; user-supplied name.
    CAS : list or None
        For case (a) =&gt; aggregated CAS from search results;
        For case (b,c) =&gt; None.
    M : float
        The *minimum* M from either the search results or the user-supplied array.
    M_array : numpy.ndarray
        The full array of all M values found or provided.
    logP : float or numpy.ndarray or None
        For case (a) =&gt; an array of all logP from the search results (or None if not found);
        For case (b) =&gt; None or user-supplied value/array;
        For case (c) =&gt; user-supplied value/array.
    &#34;&#34;&#34;

    # class attribute, maximum width
    _maxdisplay = 40

    def __init__(self, name=None, M=None, logP=None,
                 Dmodel = &#34;Piringer&#34;,
                 Dtemplate = {&#34;polymer&#34;:&#34;LLDPE&#34;, &#34;M&#34;:50, &#34;T&#34;:40}, # do not use None
                 kmodel = None,
                 ktemplate = {},
                 db=dbdefault):
        &#34;&#34;&#34;
        Create a new migrant instance.

        Parameters
        ----------
        name : str or None
            - A textual name for the substance to be looked up in PubChem (case a),
              or a custom name for a surrogate (case c).
            - If None, and M is given, we treat it as a numeric-only initialization (case b).
        M : float or list/ndarray of float or None
            - For case (a): If provided as None, we do a PubChem search by name.
            - For case (b): The numeric molecular weight(s). No search is performed if name is None.
            - For case (c): Combined name and numeric M =&gt; a surrogate with no search.
        logP : float or list/ndarray of float or None
            - For case (a): Typically None. If the PubChem search returns logP, it’s stored automatically.
            - For case (b,c): user can supply. If given, stored in self.logP as a numpy array.
        db : instance of CompoundIndex or similar, optional
            - If you want to perform a PubChem search (case a) automatically, pass an instance.
            - If omitted or None, no search is attempted, even if name is given.

        Advanced Parameters
        -------------------
        Property models from MigrationPropertyModels can be directly attached to the substance.
        Based on the current version of migration.py two models are proposed:
            - Set a diffusivity model using
                    - Dmodel=&#34;model name&#34;
                      default =&#34;Piringer&#34;
                    - Dtemplate=template dict coding for the key:value parameters
                      (e.g, to bed used Diringer(key1=value1...))
                      note: the template needs to be valid (do not use None)
                      default = {&#34;polymer&#34;:None, &#34;M&#34;:None, &#34;T&#34;:None}
            - Set a Henri-like model using
                    - kmodel=&#34;model name&#34;
                      default =None
                    - ktemplate=template dict coding for the key:value parameters
                      default = {}
            other models could be implemented in the future, read the module property.py for details.

        Example of usage of Dpiringer
            m = migrant(name=&#39;limonene&#39;)
            # without the helper function
            Dvalue = m.D.evaluate(**dict(m.Dtemplate,polymer=&#34;LDPE&#34;,T=60))
            # with the helper function
            Dvalue = m.Deval(polymer=&#34;LDPE&#34;,T=60)

        Raises
        ------
        ValueError if insufficient arguments are provided for any scenario.
        &#34;&#34;&#34;

        # local import
        # import implicity property migration models (e.g., Dpiringer)
        from patankar.property import MigrationPropertyModels, MigrationPropertyModel_validator

        self.compound = None   # str
        self.name = None       # str or list
        self.CAS = None        # list or None
        self.M = None          # float
        self.M_array = None    # np.ndarray
        self.logP = None       # float / np.ndarray / None

        # special case
        if name==M==None:
            name = &#39;toluene&#39;

        # Convert M to a numpy array if given
        if M is not None:
            if isinstance(M, (float, int)):
                M_array = np.array([float(M)], dtype=float)
            else:
                # Convert to array
                M_array = np.array(M, dtype=float)
        else:
            M_array = None

        # Similarly, convert logP to array if provided
        if logP is not None:
            if isinstance(logP, (float, int)):
                logP_array = np.array([float(logP)], dtype=float)
            else:
                logP_array = np.array(logP, dtype=float)
        else:
            logP_array = None

        # Case (a): name is provided, M=None =&gt; real compound lookup
        if (name is not None) and (M is None):
            if db is None:
                raise ValueError(&#34;A db instance is required for searching by name when M is None.&#34;)

            df = db.find(name, output_format=&#34;simple&#34;)
            if df.empty:
                # No record found
                self.compound = name
                self.name = [name]
                self.CAS = []
                self.M_array = np.array([], dtype=float)
                self.M = None
                self.formula = None
                self.logP = None
            else:
                # Possibly multiple matching rows
                self.compound = name

                all_names = []
                all_cas = []
                all_m = []
                all_formulas = []
                all_logP = []

                for _, row in df.iterrows():
                    # Gather a list/set of names
                    row_names = row.get(&#34;name&#34;, [])
                    if isinstance(row_names, str):
                        row_names = [row_names]
                    row_syns = row.get(&#34;synonyms&#34;, [])
                    combined_names = set(row_names) | set(row_syns)
                    all_names.extend(list(combined_names))

                    # CAS
                    row_cas = row.get(&#34;CAS&#34;, [])
                    if row_cas:
                        all_cas.extend(row_cas)

                    # M
                    row_m = row.get(&#34;M&#34;, None)
                    if row_m is not None:
                        try:
                            all_m.append(float(row_m))
                        except:
                            all_m.append(np.nan)
                    else:
                        all_m.append(np.nan)

                    # logP
                    row_logp = row.get(&#34;logP&#34;, None)
                    if row_logp not in (None, &#34;&#34;):
                        try:
                            all_logP.append(float(row_logp))
                        except:
                            all_logP.append(np.nan)
                    else:
                        all_logP.append(np.nan)

                    # formula (as a string)
                    row_formula = row.get(&#34;formula&#34;, None)
                    # Even if None, we append so the index lines up with M
                    all_formulas.append(row_formula)

                # Convert to arrays
                arr_m = np.array(all_m, dtype=float)
                arr_logp = np.array(all_logP, dtype=float)

                # Some dedup / cleaning
                unique_names = list(set(all_names))
                unique_cas = list(set(all_cas))

                # Store results in the migrant object
                self.name = unique_names
                self.CAS = unique_cas if unique_cas else None
                self.M_array = arr_m
                # Minimum M
                if np.isnan(arr_m).all():
                    self.M = None
                    self.formula = None
                else:
                    idx_min = np.nanargmin(arr_m)    # index of min M
                    self.M = arr_m[idx_min]         # pick that M
                    self.formula = all_formulas[idx_min]  # pick formula from same record

                # Valid logP
                valid_logp = arr_logp[~np.isnan(arr_logp)]
                if valid_logp.size &gt; 0:
                    self.logP = valid_logp  # or store as a list/mean/etc.
                else:
                    self.logP = None

        # Case (b): name is None, M is provided =&gt; generic substance
        # ----------------------------------------------------------------
        elif (name is None) and (M_array is not None):
            # No search performed
            if M_array.size == 1:
                self.compound = &#34;single molecular weight&#34;
            else:
                self.compound = (f&#34;list of molecular weights ranging from &#34;
                                 f&#34;{float(np.min(M_array))} to {float(np.max(M_array))}&#34;)

            # name =&gt; &#34;generic&#34; or if user explicitly set name=..., handle it here
            self.name = &#34;generic&#34;  # from instructions
            self.CAS = None
            self.M_array = M_array
            self.M = float(np.min(M_array))
            self.formula = None
            self.logP = logP_array  # user-supplied or None

        # Case (c): name is not None and M is provided =&gt; surrogate
        # ----------------------------------------------------------------
        elif (name is not None) and (M_array is not None):
            # No search is done, it doesn&#39;t exist in PubChem
            if M_array.size == 1:
                self.compound = &#34;single molecular weight&#34;
            else:
                self.compound = (f&#34;list of molecular weights ranging from &#34;
                                 f&#34;{float(np.min(M_array))} to {float(np.max(M_array))}&#34;)

            self.name = name
            self.CAS = None
            self.M_array = M_array
            self.M = float(np.min(M_array))
            self.formula = None
            self.logP = logP_array

        else:
            # If none of these scenarios apply, user gave incomplete or conflicting args
            raise ValueError(&#34;Invalid arguments. Provide either name for search (case a), &#34;
                             &#34;or M for a generic (case b), or both for a surrogate (case c).&#34;)


        # Model validation and paramameterization
        # ----------------------------------------

        # Diffusivity model
        if Dmodel is not None:
            if not isinstance(Dmodel,str):
                raise TypeError(f&#34;Dmodel should be str not a {type(Dmodel).__name__}&#34;)
            if Dmodel not in MigrationPropertyModels[&#34;D&#34;]:
                raise ValueError(f&#39;The diffusivity model &#34;{Dmodel}&#34; does not exist&#39;)
            Dmodelclass = MigrationPropertyModels[&#34;D&#34;][Dmodel]
            if not MigrationPropertyModel_validator(Dmodelclass,Dmodel,&#34;D&#34;):
                raise TypeError(f&#39;The diffusivity model &#34;{Dmodel}&#34; is corrupted&#39;)
            if Dtemplate is None:
                Dtemplate = {}
            if not isinstance(Dtemplate,dict):
                raise TypeError(f&#34;Dtemplate should be a dict not a {type(Dtemplate).__name__}&#34;)
            self.D  = Dmodelclass
            self.Dtemplate = Dtemplate.copy()
            self.Dtemplate.update(M=self.M,logP=self.logP)
        else:
            self.D = None
            self.Dtemplate = None

        # Henri-like model
        if kmodel is not None:
            if not isinstance(kmodel,str):
                raise TypeError(f&#34;kmodel should be str not a {type(kmodel).__name__}&#34;)
            if kmodel not in MigrationPropertyModels[&#34;k&#34;]:
                raise ValueError(f&#39;The Henri-like model &#34;{kmodel}&#34; does not exist&#39;)
            kmodelclass = MigrationPropertyModels[&#34;k&#34;][kmodel]
            if not MigrationPropertyModel_validator(kmodelclass,Dmodel,&#34;k&#34;):
                raise TypeError(f&#39;The Henri-like model &#34;{kmodel}&#34; is corrupted&#39;)
            if ktemplate is None:
                ktemplate = {}
            if not isinstance(ktemplate,dict):
                raise TypeError(f&#34;ktemplate should be a dict not a {type(ktemplate).__name__}&#34;)
            self.k  = kmodelclass
            self.ktemplate = ktemplate.copy()
            self.ktemplate.update(M=self.M,logP=self.logP)
        else:
            self.k = None
            self.ktemplate = None

    # helper property to combine D and Dtemplate
    @property
    def Deval(self):
        &#34;&#34;&#34;Return a callable function that evaluates D with updated parameters.&#34;&#34;&#34;
        if self.D is None:
            return lambda **kwargs: None  # Return a function that always returns None
        def func(**kwargs):
            updated_template = dict(self.Dtemplate, **kwargs)
            return self.D.evaluate(**updated_template)
        return func

    # helper property to combine k and ktemplate
    @property
    def keval(self):
        &#34;&#34;&#34;Return a callable function that evaluates k with updated parameters.&#34;&#34;&#34;
        if self.k is None:
            return lambda **kwargs: None  # Return a function that always returns None
        def func(**kwargs):
            updated_template = dict(self.ktemplate, **kwargs)
            return self.k.evaluate(**updated_template)
        return func



    def __repr__(self):
        &#34;&#34;&#34;Formatted string representation summarizing key attributes.&#34;&#34;&#34;
        # Define header
        info = [f&#34;&lt;{self.__class__.__name__} object&gt;&#34;]
        # Collect attributes
        attributes = {
            &#34;Compound&#34;: self.compound,
            &#34;Name&#34;: self.name,
            &#34;CAS&#34;: self.CAS,
            &#34;M (min)&#34;: self.M,
            &#34;M_array&#34;: self.M_array if self.M_array is not None else &#34;N/A&#34;,
            &#34;formula&#34;: self.formula,
            &#34;logP&#34;: self.logP
        }
        # Determine column width based on longest attribute name
        key_width = max(len(k) for k in attributes.keys()) + 2  # Add padding
        # Format attributes with indentation
        for key, value in attributes.items():
            formatted_key = f&#34;{key}:&#34;.rjust(key_width)
            formatted_value = self.dispmax(value)
            info.append(f&#34;  {formatted_key} {formatted_value}&#34;)
        # Print formatted representation
        repr_str = &#34;\n&#34;.join(info)
        print(repr_str)
        # Return a short summary for interactive use
        return str(self)

    def __str__(self):
        &#34;&#34;&#34;Formatted string representing the migrant&#34;&#34;&#34;
        onename = self.name[0] if isinstance(self.name,list) else self.name
        return f&#34;&lt;{self.__class__.__name__}: {self.dispmax(onename,16)} - M={self.M} g/mol&gt;&#34;

    def dispmax(self,content,maxwidth=None):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        maxwidth = self._maxdisplay if maxwidth is None else min(maxwidth,self._maxdisplay)
        if len(strcontent)&gt;maxwidth:
            nchar = round(maxwidth/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="layer.migrant.Deval"><code class="name">var <span class="ident">Deval</span></code></dt>
<dd>
<div class="desc"><p>Return a callable function that evaluates D with updated parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Deval(self):
    &#34;&#34;&#34;Return a callable function that evaluates D with updated parameters.&#34;&#34;&#34;
    if self.D is None:
        return lambda **kwargs: None  # Return a function that always returns None
    def func(**kwargs):
        updated_template = dict(self.Dtemplate, **kwargs)
        return self.D.evaluate(**updated_template)
    return func</code></pre>
</details>
</dd>
<dt id="layer.migrant.keval"><code class="name">var <span class="ident">keval</span></code></dt>
<dd>
<div class="desc"><p>Return a callable function that evaluates k with updated parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def keval(self):
    &#34;&#34;&#34;Return a callable function that evaluates k with updated parameters.&#34;&#34;&#34;
    if self.k is None:
        return lambda **kwargs: None  # Return a function that always returns None
    def func(**kwargs):
        updated_template = dict(self.ktemplate, **kwargs)
        return self.k.evaluate(**updated_template)
    return func</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.migrant.dispmax"><code class="name flex">
<span>def <span class="ident">dispmax</span></span>(<span>self, content, maxwidth=None)</span>
</code></dt>
<dd>
<div class="desc"><p>optimize display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispmax(self,content,maxwidth=None):
    &#34;&#34;&#34; optimize display &#34;&#34;&#34;
    strcontent = str(content)
    maxwidth = self._maxdisplay if maxwidth is None else min(maxwidth,self._maxdisplay)
    if len(strcontent)&gt;maxwidth:
        nchar = round(maxwidth/2)
        return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
    else:
        return content</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="layer.oPP"><code class="flex name class">
<span>class <span class="ident">oPP</span></span>
<span>(</span><span>l=4e-05, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in oPP', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for bioriented polypropylene oPP </p>
<p>oPP layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class oPP(layer):
    &#34;&#34;&#34; extended pantankar.layer for bioriented polypropylene oPP &#34;&#34;&#34;
    def __init__(self, l=40e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in oPP&#34;,**extra):
        &#34;&#34;&#34; oPP layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;bioriented polypropylene&#34;,
            layercode=&#34;oPP&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of bioriented PP: density(T in K)
        Typically close to isotactic PP around ~910 kg/m^3.
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 910 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of bioriented PP &#34;&#34;&#34;
        return 0, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.oPP.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of bioriented PP</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of bioriented PP &#34;&#34;&#34;
    return 0, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.oPP.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of bioriented PP: density(T in K)
Typically close to isotactic PP around ~910 kg/m^3.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of bioriented PP: density(T in K)
    Typically close to isotactic PP around ~910 kg/m^3.
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 910 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 7e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.plasticizedPVC"><code class="flex name class">
<span>class <span class="ident">plasticizedPVC</span></span>
<span>(</span><span>l=0.0002, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in plasticized PVC', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for plasticized PVC </p>
<p>plasticized PVC layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class plasticizedPVC(layer):
    &#34;&#34;&#34; extended pantankar.layer for plasticized PVC &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in plasticized PVC&#34;,**extra):
        &#34;&#34;&#34; plasticized PVC layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;plasticized PVC&#34;,
            layercode=&#34;pPVC&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of plasticized PVC: ~1300 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1300 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of plasticized PVC &#34;&#34;&#34;
        return -40, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.plasticizedPVC.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of plasticized PVC</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of plasticized PVC &#34;&#34;&#34;
    return -40, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.plasticizedPVC.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of plasticized PVC: ~1300 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of plasticized PVC: ~1300 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1300 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.rPET"><code class="flex name class">
<span>class <span class="ident">rPET</span></span>
<span>(</span><span>l=0.0002, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in rPET', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for PET in its rubbery state (above ~76°C) </p>
<p>rubbery PET layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class rPET(layer):
    &#34;&#34;&#34; extended pantankar.layer for PET in its rubbery state (above ~76°C) &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in rPET&#34;,**extra):
        &#34;&#34;&#34; rubbery PET layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;rubbery PET&#34;,
            layercode=&#34;rPET&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of rubbery PET: ~1350 kg/m^3
        but with a different expansion slope possible, if needed
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1350 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 1e-4), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; approximate glass transition temperature of PET &#34;&#34;&#34;
        return 76, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.rPET.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>approximate glass transition temperature of PET</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; approximate glass transition temperature of PET &#34;&#34;&#34;
    return 76, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.rPET.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of rubbery PET: ~1350 kg/m^3
but with a different expansion slope possible, if needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of rubbery PET: ~1350 kg/m^3
    but with a different expansion slope possible, if needed
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1350 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 1e-4), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="layer.rigidPVC"><code class="flex name class">
<span>class <span class="ident">rigidPVC</span></span>
<span>(</span><span>l=0.0002, D=1e-14, T=None, k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None, layername='layer in rigid PVC', **extra)</span>
</code></dt>
<dd>
<div class="desc"><p>extended pantankar.layer for rigid PVC </p>
<p>rigid PVC layer constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class rigidPVC(layer):
    &#34;&#34;&#34; extended pantankar.layer for rigid PVC &#34;&#34;&#34;
    def __init__(self, l=200e-6, D=1e-14, T=None,
                 k=None, C0=None, lunit=None, Dunit=None, kunit=None, Cunit=None,
                 layername=&#34;layer in rigid PVC&#34;,**extra):
        &#34;&#34;&#34; rigid PVC layer constructor &#34;&#34;&#34;
        super().__init__(
            l=l, D=D, k=k, C0=C0, T=T,
            lunit=lunit, Dunit=Dunit, kunit=kunit, Cunit=Cunit,
            layername=layername,
            layertype=&#34;polymer&#34;,
            layermaterial=&#34;rigid PVC&#34;,
            layercode=&#34;PVC&#34;,
            **extra
        )
    def density(self, T=None):
        &#34;&#34;&#34;
        density of rigid PVC: ~1400 kg/m^3
        &#34;&#34;&#34;
        T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
        return 1400 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;

    @property
    def Tg(self):
        &#34;&#34;&#34; glass transition temperature of rigid PVC &#34;&#34;&#34;
        return 80, &#34;degC&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="layer.layer" href="#layer.layer">layer</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="layer.rigidPVC.Tg"><code class="name">var <span class="ident">Tg</span></code></dt>
<dd>
<div class="desc"><p>glass transition temperature of rigid PVC</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Tg(self):
    &#34;&#34;&#34; glass transition temperature of rigid PVC &#34;&#34;&#34;
    return 80, &#34;degC&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="layer.rigidPVC.density"><code class="name flex">
<span>def <span class="ident">density</span></span>(<span>self, T=None)</span>
</code></dt>
<dd>
<div class="desc"><p>density of rigid PVC: ~1400 kg/m^3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def density(self, T=None):
    &#34;&#34;&#34;
    density of rigid PVC: ~1400 kg/m^3
    &#34;&#34;&#34;
    T = self.T if T is None else check_units(T, None, &#34;degC&#34;)[0]
    return 1400 * (1 - 3*(T - layer._defaults[&#34;Td&#34;]) * 5e-5), &#34;kg/m**3&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="layer.layer" href="#layer.layer">layer</a></b></code>:
<ul class="hlist">
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="layer.check_units" href="#layer.check_units">check_units</a></code></li>
<li><code><a title="layer.fixSIbase" href="#layer.fixSIbase">fixSIbase</a></code></li>
<li><code><a title="layer.help_layer" href="#layer.help_layer">help_layer</a></code></li>
<li><code><a title="layer.list_layer_subclasses" href="#layer.list_layer_subclasses">list_layer_subclasses</a></code></li>
<li><code><a title="layer.toSI" href="#layer.toSI">toSI</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="layer.AdhesiveAcrylate" href="#layer.AdhesiveAcrylate">AdhesiveAcrylate</a></code></h4>
<ul class="">
<li><code><a title="layer.AdhesiveAcrylate.Tg" href="#layer.AdhesiveAcrylate.Tg">Tg</a></code></li>
<li><code><a title="layer.AdhesiveAcrylate.density" href="#layer.AdhesiveAcrylate.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.AdhesiveEVA" href="#layer.AdhesiveEVA">AdhesiveEVA</a></code></h4>
<ul class="">
<li><code><a title="layer.AdhesiveEVA.Tg" href="#layer.AdhesiveEVA.Tg">Tg</a></code></li>
<li><code><a title="layer.AdhesiveEVA.density" href="#layer.AdhesiveEVA.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.AdhesiveNaturalRubber" href="#layer.AdhesiveNaturalRubber">AdhesiveNaturalRubber</a></code></h4>
<ul class="">
<li><code><a title="layer.AdhesiveNaturalRubber.Tg" href="#layer.AdhesiveNaturalRubber.Tg">Tg</a></code></li>
<li><code><a title="layer.AdhesiveNaturalRubber.density" href="#layer.AdhesiveNaturalRubber.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.AdhesivePU" href="#layer.AdhesivePU">AdhesivePU</a></code></h4>
<ul class="">
<li><code><a title="layer.AdhesivePU.Tg" href="#layer.AdhesivePU.Tg">Tg</a></code></li>
<li><code><a title="layer.AdhesivePU.density" href="#layer.AdhesivePU.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.AdhesivePVAC" href="#layer.AdhesivePVAC">AdhesivePVAC</a></code></h4>
<ul class="">
<li><code><a title="layer.AdhesivePVAC.Tg" href="#layer.AdhesivePVAC.Tg">Tg</a></code></li>
<li><code><a title="layer.AdhesivePVAC.density" href="#layer.AdhesivePVAC.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.AdhesiveSyntheticRubber" href="#layer.AdhesiveSyntheticRubber">AdhesiveSyntheticRubber</a></code></h4>
<ul class="">
<li><code><a title="layer.AdhesiveSyntheticRubber.Tg" href="#layer.AdhesiveSyntheticRubber.Tg">Tg</a></code></li>
<li><code><a title="layer.AdhesiveSyntheticRubber.density" href="#layer.AdhesiveSyntheticRubber.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.AdhesiveVAE" href="#layer.AdhesiveVAE">AdhesiveVAE</a></code></h4>
<ul class="">
<li><code><a title="layer.AdhesiveVAE.Tg" href="#layer.AdhesiveVAE.Tg">Tg</a></code></li>
<li><code><a title="layer.AdhesiveVAE.density" href="#layer.AdhesiveVAE.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.Cardboard" href="#layer.Cardboard">Cardboard</a></code></h4>
<ul class="">
<li><code><a title="layer.Cardboard.Tg" href="#layer.Cardboard.Tg">Tg</a></code></li>
<li><code><a title="layer.Cardboard.density" href="#layer.Cardboard.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.HDPE" href="#layer.HDPE">HDPE</a></code></h4>
<ul class="">
<li><code><a title="layer.HDPE.Tg" href="#layer.HDPE.Tg">Tg</a></code></li>
<li><code><a title="layer.HDPE.density" href="#layer.HDPE.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.HIPS" href="#layer.HIPS">HIPS</a></code></h4>
<ul class="">
<li><code><a title="layer.HIPS.Tg" href="#layer.HIPS.Tg">Tg</a></code></li>
<li><code><a title="layer.HIPS.density" href="#layer.HIPS.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.LDPE" href="#layer.LDPE">LDPE</a></code></h4>
<ul class="">
<li><code><a title="layer.LDPE.Tg" href="#layer.LDPE.Tg">Tg</a></code></li>
<li><code><a title="layer.LDPE.density" href="#layer.LDPE.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.LLDPE" href="#layer.LLDPE">LLDPE</a></code></h4>
<ul class="">
<li><code><a title="layer.LLDPE.Tg" href="#layer.LLDPE.Tg">Tg</a></code></li>
<li><code><a title="layer.LLDPE.density" href="#layer.LLDPE.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.PA6" href="#layer.PA6">PA6</a></code></h4>
<ul class="">
<li><code><a title="layer.PA6.Tg" href="#layer.PA6.Tg">Tg</a></code></li>
<li><code><a title="layer.PA6.density" href="#layer.PA6.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.PA66" href="#layer.PA66">PA66</a></code></h4>
<ul class="">
<li><code><a title="layer.PA66.Tg" href="#layer.PA66.Tg">Tg</a></code></li>
<li><code><a title="layer.PA66.density" href="#layer.PA66.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.PBT" href="#layer.PBT">PBT</a></code></h4>
<ul class="">
<li><code><a title="layer.PBT.Tg" href="#layer.PBT.Tg">Tg</a></code></li>
<li><code><a title="layer.PBT.density" href="#layer.PBT.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.PEN" href="#layer.PEN">PEN</a></code></h4>
<ul class="">
<li><code><a title="layer.PEN.Tg" href="#layer.PEN.Tg">Tg</a></code></li>
<li><code><a title="layer.PEN.density" href="#layer.PEN.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.PP" href="#layer.PP">PP</a></code></h4>
<ul class="">
<li><code><a title="layer.PP.Tg" href="#layer.PP.Tg">Tg</a></code></li>
<li><code><a title="layer.PP.density" href="#layer.PP.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.PPrubber" href="#layer.PPrubber">PPrubber</a></code></h4>
<ul class="">
<li><code><a title="layer.PPrubber.Tg" href="#layer.PPrubber.Tg">Tg</a></code></li>
<li><code><a title="layer.PPrubber.density" href="#layer.PPrubber.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.PS" href="#layer.PS">PS</a></code></h4>
<ul class="">
<li><code><a title="layer.PS.Tg" href="#layer.PS.Tg">Tg</a></code></li>
<li><code><a title="layer.PS.density" href="#layer.PS.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.Paper" href="#layer.Paper">Paper</a></code></h4>
<ul class="">
<li><code><a title="layer.Paper.Tg" href="#layer.Paper.Tg">Tg</a></code></li>
<li><code><a title="layer.Paper.density" href="#layer.Paper.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.SBS" href="#layer.SBS">SBS</a></code></h4>
<ul class="">
<li><code><a title="layer.SBS.Tg" href="#layer.SBS.Tg">Tg</a></code></li>
<li><code><a title="layer.SBS.density" href="#layer.SBS.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.UnitRegistry" href="#layer.UnitRegistry">UnitRegistry</a></code></h4>
<ul class="">
<li><code><a title="layer.UnitRegistry.check" href="#layer.UnitRegistry.check">check</a></code></li>
<li><code><a title="layer.UnitRegistry.pi_theorem" href="#layer.UnitRegistry.pi_theorem">pi_theorem</a></code></li>
<li><code><a title="layer.UnitRegistry.setup_matplotlib" href="#layer.UnitRegistry.setup_matplotlib">setup_matplotlib</a></code></li>
<li><code><a title="layer.UnitRegistry.wraps" href="#layer.UnitRegistry.wraps">wraps</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.air" href="#layer.air">air</a></code></h4>
<ul class="">
<li><code><a title="layer.air.density" href="#layer.air.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.build_quantity_class.<locals>.Quantity" href="#layer.build_quantity_class.<locals>.Quantity">build_quantity_class.<locals>.Quantity</a></code></h4>
</li>
<li>
<h4><code><a title="layer.gPET" href="#layer.gPET">gPET</a></code></h4>
<ul class="">
<li><code><a title="layer.gPET.Tg" href="#layer.gPET.Tg">Tg</a></code></li>
<li><code><a title="layer.gPET.density" href="#layer.gPET.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.layer" href="#layer.layer">layer</a></code></h4>
<ul class="two-column">
<li><code><a title="layer.layer.C0" href="#layer.layer.C0">C0</a></code></li>
<li><code><a title="layer.layer.Cunit" href="#layer.layer.Cunit">Cunit</a></code></li>
<li><code><a title="layer.layer.D" href="#layer.layer.D">D</a></code></li>
<li><code><a title="layer.layer.Dmodel" href="#layer.layer.Dmodel">Dmodel</a></code></li>
<li><code><a title="layer.layer.Dunit" href="#layer.layer.Dunit">Dunit</a></code></li>
<li><code><a title="layer.layer.Foscale" href="#layer.layer.Foscale">Foscale</a></code></li>
<li><code><a title="layer.layer.T" href="#layer.layer.T">T</a></code></li>
<li><code><a title="layer.layer.TK" href="#layer.layer.TK">TK</a></code></li>
<li><code><a title="layer.layer.TKunit" href="#layer.layer.TKunit">TKunit</a></code></li>
<li><code><a title="layer.layer.Tunit" href="#layer.layer.Tunit">Tunit</a></code></li>
<li><code><a title="layer.layer.acknowledge" href="#layer.layer.acknowledge">acknowledge</a></code></li>
<li><code><a title="layer.layer.checknumvalue" href="#layer.layer.checknumvalue">checknumvalue</a></code></li>
<li><code><a title="layer.layer.checktextvalue" href="#layer.layer.checktextvalue">checktextvalue</a></code></li>
<li><code><a title="layer.layer.code" href="#layer.layer.code">code</a></code></li>
<li><code><a title="layer.layer.concentration" href="#layer.layer.concentration">concentration</a></code></li>
<li><code><a title="layer.layer.contact" href="#layer.layer.contact">contact</a></code></li>
<li><code><a title="layer.layer.copy" href="#layer.layer.copy">copy</a></code></li>
<li><code><a title="layer.layer.hashlayer" href="#layer.layer.hashlayer">hashlayer</a></code></li>
<li><code><a title="layer.layer.help" href="#layer.layer.help">help</a></code></li>
<li><code><a title="layer.layer.k" href="#layer.layer.k">k</a></code></li>
<li><code><a title="layer.layer.kmodel" href="#layer.layer.kmodel">kmodel</a></code></li>
<li><code><a title="layer.layer.kunit" href="#layer.layer.kunit">kunit</a></code></li>
<li><code><a title="layer.layer.l" href="#layer.layer.l">l</a></code></li>
<li><code><a title="layer.layer.lag" href="#layer.layer.lag">lag</a></code></li>
<li><code><a title="layer.layer.layerclass" href="#layer.layer.layerclass">layerclass</a></code></li>
<li><code><a title="layer.layer.layerclass_history" href="#layer.layer.layerclass_history">layerclass_history</a></code></li>
<li><code><a title="layer.layer.lreferencelayer" href="#layer.layer.lreferencelayer">lreferencelayer</a></code></li>
<li><code><a title="layer.layer.lunit" href="#layer.layer.lunit">lunit</a></code></li>
<li><code><a title="layer.layer.material" href="#layer.layer.material">material</a></code></li>
<li><code><a title="layer.layer.mesh" href="#layer.layer.mesh">mesh</a></code></li>
<li><code><a title="layer.layer.migration" href="#layer.layer.migration">migration</a></code></li>
<li><code><a title="layer.layer.n" href="#layer.layer.n">n</a></code></li>
<li><code><a title="layer.layer.name" href="#layer.layer.name">name</a></code></li>
<li><code><a title="layer.layer.nmesh" href="#layer.layer.nmesh">nmesh</a></code></li>
<li><code><a title="layer.layer.nmeshmin" href="#layer.layer.nmeshmin">nmeshmin</a></code></li>
<li><code><a title="layer.layer.permeability" href="#layer.layer.permeability">permeability</a></code></li>
<li><code><a title="layer.layer.pressure" href="#layer.layer.pressure">pressure</a></code></li>
<li><code><a title="layer.layer.rank" href="#layer.layer.rank">rank</a></code></li>
<li><code><a title="layer.layer.referencelayer" href="#layer.layer.referencelayer">referencelayer</a></code></li>
<li><code><a title="layer.layer.relative_resistance" href="#layer.layer.relative_resistance">relative_resistance</a></code></li>
<li><code><a title="layer.layer.relative_thickness" href="#layer.layer.relative_thickness">relative_thickness</a></code></li>
<li><code><a title="layer.layer.resistance" href="#layer.layer.resistance">resistance</a></code></li>
<li><code><a title="layer.layer.resolvename" href="#layer.layer.resolvename">resolvename</a></code></li>
<li><code><a title="layer.layer.rho" href="#layer.layer.rho">rho</a></code></li>
<li><code><a title="layer.layer.rhounit" href="#layer.layer.rhounit">rhounit</a></code></li>
<li><code><a title="layer.layer.simplify" href="#layer.layer.simplify">simplify</a></code></li>
<li><code><a title="layer.layer.split" href="#layer.layer.split">split</a></code></li>
<li><code><a title="layer.layer.substance" href="#layer.layer.substance">substance</a></code></li>
<li><code><a title="layer.layer.thickness" href="#layer.layer.thickness">thickness</a></code></li>
<li><code><a title="layer.layer.type" href="#layer.layer.type">type</a></code></li>
<li><code><a title="layer.layer.update" href="#layer.layer.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.mesh" href="#layer.mesh">mesh</a></code></h4>
</li>
<li>
<h4><code><a title="layer.migrant" href="#layer.migrant">migrant</a></code></h4>
<ul class="">
<li><code><a title="layer.migrant.Deval" href="#layer.migrant.Deval">Deval</a></code></li>
<li><code><a title="layer.migrant.dispmax" href="#layer.migrant.dispmax">dispmax</a></code></li>
<li><code><a title="layer.migrant.keval" href="#layer.migrant.keval">keval</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.oPP" href="#layer.oPP">oPP</a></code></h4>
<ul class="">
<li><code><a title="layer.oPP.Tg" href="#layer.oPP.Tg">Tg</a></code></li>
<li><code><a title="layer.oPP.density" href="#layer.oPP.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.plasticizedPVC" href="#layer.plasticizedPVC">plasticizedPVC</a></code></h4>
<ul class="">
<li><code><a title="layer.plasticizedPVC.Tg" href="#layer.plasticizedPVC.Tg">Tg</a></code></li>
<li><code><a title="layer.plasticizedPVC.density" href="#layer.plasticizedPVC.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.rPET" href="#layer.rPET">rPET</a></code></h4>
<ul class="">
<li><code><a title="layer.rPET.Tg" href="#layer.rPET.Tg">Tg</a></code></li>
<li><code><a title="layer.rPET.density" href="#layer.rPET.density">density</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="layer.rigidPVC" href="#layer.rigidPVC">rigidPVC</a></code></h4>
<ul class="">
<li><code><a title="layer.rigidPVC.Tg" href="#layer.rigidPVC.Tg">Tg</a></code></li>
<li><code><a title="layer.rigidPVC.density" href="#layer.rigidPVC.density">density</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>