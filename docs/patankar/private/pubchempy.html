<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pubchempy API documentation</title>
<meta name="description" content="PubChemPy â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pubchempy</code></h1>
</header>
<section id="section-intro">
<p>PubChemPy</p>
<p>Python interface for the PubChem PUG REST service.
<a href="https://github.com/mcs07/PubChemPy">https://github.com/mcs07/PubChemPy</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;
PubChemPy

Python interface for the PubChem PUG REST service.
https://github.com/mcs07/PubChemPy
&#34;&#34;&#34;

from __future__ import print_function
from __future__ import unicode_literals
from __future__ import division

import functools
import json
import logging
import os
import sys
import time
import warnings
#import binascii # not used fixed by Olivier Vitrac

try:
    from urllib.error import HTTPError
    from urllib.parse import quote, urlencode
    from urllib.request import urlopen
except ImportError:
    from urllib import urlencode
    from urllib2 import quote, urlopen, HTTPError

try:
    from itertools import zip_longest
except ImportError:
    from itertools import izip_longest as zip_longest



__all__ = [&#39;Assay&#39;, &#39;Atom&#39;, &#39;BadRequestError&#39;, &#39;Bond&#39;, &#39;BondType&#39;, &#39;Compound&#39;, &#39;CompoundIdType&#39;, &#39;CoordinateType&#39;, &#39;MethodNotAllowedError&#39;, &#39;NotFoundError&#39;, &#39;ProjectCategory&#39;, &#39;PubChemHTTPError&#39;, &#39;PubChemPyDeprecationWarning&#39;, &#39;PubChemPyError&#39;, &#39;ResponseParseError&#39;, &#39;ServerError&#39;, &#39;Substance&#39;, &#39;TimeoutError&#39;, &#39;UnimplementedError&#39;, &#39;compounds_to_frame&#39;, &#39;deprecated&#39;, &#39;download&#39;, &#39;get&#39;, &#39;get_aids&#39;, &#39;get_all_sources&#39;, &#39;get_assays&#39;, &#39;get_cids&#39;, &#39;get_compounds&#39;, &#39;get_json&#39;, &#39;get_properties&#39;, &#39;get_sdf&#39;, &#39;get_sids&#39;, &#39;get_substances&#39;, &#39;get_synonyms&#39;, &#39;memoized_property&#39;, &#39;request&#39;, &#39;substances_to_frame&#39;]


__author__ = &#39;Matt Swain (small fixes: Olivier Vitrac)&#39;
__email__ = &#39;m.swain@me.com, olivier.vitrac@agroparistech.fr&#39;
__version__ = &#39;1.0.4&#39;
__license__ = &#39;MIT&#39;

API_BASE = &#39;https://pubchem.ncbi.nlm.nih.gov/rest/pug&#39;

log = logging.getLogger(&#39;pubchempy&#39;)
log.addHandler(logging.NullHandler())


if sys.version_info[0] == 3:
    text_types = str, bytes
else:
    text_types = basestring # Python 2 only (normal you seen an error in Python 3) - Olivier Vitrac


class CompoundIdType(object):
    &#34;&#34;&#34;&#34;&#34;&#34;
    #: Original Deposited Compound
    DEPOSITED = 0
    #: Standardized Form of the Deposited Compound
    STANDARDIZED = 1
    #: Component of the Standardized Form
    COMPONENT = 2
    #: Neutralized Form of the Standardized Form
    NEUTRALIZED = 3
    #: Deposited Mixture Component
    MIXTURE = 4
    #: Alternate Tautomer Form of the Standardized Form
    TAUTOMER = 5
    #: Ionized pKa Form of the Standardized Form
    IONIZED = 6
    #: Unspecified or Unknown Compound Type
    UNKNOWN = 255


class BondType(object):
    SINGLE = 1
    DOUBLE = 2
    TRIPLE = 3
    QUADRUPLE = 4
    DATIVE = 5
    COMPLEX = 6
    IONIC = 7
    UNKNOWN = 255


class CoordinateType(object):
    TWO_D = 1
    THREE_D = 2
    SUBMITTED = 3
    EXPERIMENTAL = 4
    COMPUTED = 5
    STANDARDIZED = 6
    AUGMENTED = 7
    ALIGNED = 8
    COMPACT = 9
    UNITS_ANGSTROMS = 10
    UNITS_NANOMETERS = 11
    UNITS_PIXEL = 12
    UNITS_POINTS = 13
    UNITS_STDBONDS = 14
    UNITS_UNKNOWN = 255


class ProjectCategory(object):
    MLSCN = 1
    MPLCN = 2
    MLSCN_AP = 3
    MPLCN_AP = 4
    JOURNAL_ARTICLE = 5
    ASSAY_VENDOR = 6
    LITERATURE_EXTRACTED = 7
    LITERATURE_AUTHOR = 8
    LITERATURE_PUBLISHER = 9
    RNAIGI = 10
    OTHER = 255


ELEMENTS = {
    1: &#39;H&#39;,
    2: &#39;He&#39;,
    3: &#39;Li&#39;,
    4: &#39;Be&#39;,
    5: &#39;B&#39;,
    6: &#39;C&#39;,
    7: &#39;N&#39;,
    8: &#39;O&#39;,
    9: &#39;F&#39;,
    10: &#39;Ne&#39;,
    11: &#39;Na&#39;,
    12: &#39;Mg&#39;,
    13: &#39;Al&#39;,
    14: &#39;Si&#39;,
    15: &#39;P&#39;,
    16: &#39;S&#39;,
    17: &#39;Cl&#39;,
    18: &#39;Ar&#39;,
    19: &#39;K&#39;,
    20: &#39;Ca&#39;,
    21: &#39;Sc&#39;,
    22: &#39;Ti&#39;,
    23: &#39;V&#39;,
    24: &#39;Cr&#39;,
    25: &#39;Mn&#39;,
    26: &#39;Fe&#39;,
    27: &#39;Co&#39;,
    28: &#39;Ni&#39;,
    29: &#39;Cu&#39;,
    30: &#39;Zn&#39;,
    31: &#39;Ga&#39;,
    32: &#39;Ge&#39;,
    33: &#39;As&#39;,
    34: &#39;Se&#39;,
    35: &#39;Br&#39;,
    36: &#39;Kr&#39;,
    37: &#39;Rb&#39;,
    38: &#39;Sr&#39;,
    39: &#39;Y&#39;,
    40: &#39;Zr&#39;,
    41: &#39;Nb&#39;,
    42: &#39;Mo&#39;,
    43: &#39;Tc&#39;,
    44: &#39;Ru&#39;,
    45: &#39;Rh&#39;,
    46: &#39;Pd&#39;,
    47: &#39;Ag&#39;,
    48: &#39;Cd&#39;,
    49: &#39;In&#39;,
    50: &#39;Sn&#39;,
    51: &#39;Sb&#39;,
    52: &#39;Te&#39;,
    53: &#39;I&#39;,
    54: &#39;Xe&#39;,
    55: &#39;Cs&#39;,
    56: &#39;Ba&#39;,
    57: &#39;La&#39;,
    58: &#39;Ce&#39;,
    59: &#39;Pr&#39;,
    60: &#39;Nd&#39;,
    61: &#39;Pm&#39;,
    62: &#39;Sm&#39;,
    63: &#39;Eu&#39;,
    64: &#39;Gd&#39;,
    65: &#39;Tb&#39;,
    66: &#39;Dy&#39;,
    67: &#39;Ho&#39;,
    68: &#39;Er&#39;,
    69: &#39;Tm&#39;,
    70: &#39;Yb&#39;,
    71: &#39;Lu&#39;,
    72: &#39;Hf&#39;,
    73: &#39;Ta&#39;,
    74: &#39;W&#39;,
    75: &#39;Re&#39;,
    76: &#39;Os&#39;,
    77: &#39;Ir&#39;,
    78: &#39;Pt&#39;,
    79: &#39;Au&#39;,
    80: &#39;Hg&#39;,
    81: &#39;Tl&#39;,
    82: &#39;Pb&#39;,
    83: &#39;Bi&#39;,
    84: &#39;Po&#39;,
    85: &#39;At&#39;,
    86: &#39;Rn&#39;,
    87: &#39;Fr&#39;,
    88: &#39;Ra&#39;,
    89: &#39;Ac&#39;,
    90: &#39;Th&#39;,
    91: &#39;Pa&#39;,
    92: &#39;U&#39;,
    93: &#39;Np&#39;,
    94: &#39;Pu&#39;,
    95: &#39;Am&#39;,
    96: &#39;Cm&#39;,
    97: &#39;Bk&#39;,
    98: &#39;Cf&#39;,
    99: &#39;Es&#39;,
    100: &#39;Fm&#39;,
    101: &#39;Md&#39;,
    102: &#39;No&#39;,
    103: &#39;Lr&#39;,
    104: &#39;Rf&#39;,
    105: &#39;Db&#39;,
    106: &#39;Sg&#39;,
    107: &#39;Bh&#39;,
    108: &#39;Hs&#39;,
    109: &#39;Mt&#39;,
    110: &#39;Ds&#39;,
    111: &#39;Rg&#39;,
    112: &#39;Cp&#39;,
    113: &#39;ut&#39;,
    114: &#39;uq&#39;,
    115: &#39;up&#39;,
    116: &#39;uh&#39;,
    117: &#39;us&#39;,
    118: &#39;uo&#39;,
}


def request(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, operation=None, output=&#39;JSON&#39;, searchtype=None, **kwargs):
    &#34;&#34;&#34;
    Construct API request from parameters and return the response.

    Full specification at http://pubchem.ncbi.nlm.nih.gov/pug_rest/PUG_REST.html
    &#34;&#34;&#34;
    if not identifier:
        raise ValueError(&#39;identifier/cid cannot be None&#39;)
    # If identifier is a list, join with commas into string
    if isinstance(identifier, int):
        identifier = str(identifier)
    if not isinstance(identifier, text_types):
        identifier = &#39;,&#39;.join(str(x) for x in identifier)
    # Filter None values from kwargs
    kwargs = dict((k, v) for k, v in kwargs.items() if v is not None)
    # Build API URL
    urlid, postdata = None, None
    if namespace == &#39;sourceid&#39;:
        identifier = identifier.replace(&#39;/&#39;, &#39;.&#39;)
    if namespace in [&#39;listkey&#39;, &#39;formula&#39;, &#39;sourceid&#39;] \
            or searchtype == &#39;xref&#39; \
            or (searchtype and namespace == &#39;cid&#39;) or domain == &#39;sources&#39;:
        urlid = quote(identifier.encode(&#39;utf8&#39;))
    else:
        postdata = urlencode([(namespace, identifier)]).encode(&#39;utf8&#39;)
    comps = filter(None, [API_BASE, domain, searchtype, namespace, urlid, operation, output])
    apiurl = &#39;/&#39;.join(comps)
    if kwargs:
        apiurl += &#39;?%s&#39; % urlencode(kwargs)
    # Make request
    try:
        log.debug(&#39;Request URL: %s&#39;, apiurl)
        log.debug(&#39;Request data: %s&#39;, postdata)
        response = urlopen(apiurl, postdata)
        return response
    except HTTPError as e:
        raise PubChemHTTPError(e)


def get(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, operation=None, output=&#39;JSON&#39;, searchtype=None, **kwargs):
    &#34;&#34;&#34;Request wrapper that automatically handles async requests.&#34;&#34;&#34;
    if (searchtype and searchtype != &#39;xref&#39;) or namespace in [&#39;formula&#39;]:
        response = request(identifier, namespace, domain, None, &#39;JSON&#39;, searchtype, **kwargs).read()
        status = json.loads(response.decode())
        if &#39;Waiting&#39; in status and &#39;ListKey&#39; in status[&#39;Waiting&#39;]:
            identifier = status[&#39;Waiting&#39;][&#39;ListKey&#39;]
            namespace = &#39;listkey&#39;
            while &#39;Waiting&#39; in status and &#39;ListKey&#39; in status[&#39;Waiting&#39;]:
                time.sleep(2)
                response = request(identifier, namespace, domain, operation, &#39;JSON&#39;, **kwargs).read()
                status = json.loads(response.decode())
            if not output == &#39;JSON&#39;:
                response = request(identifier, namespace, domain, operation, output, searchtype, **kwargs).read()
    else:
        response = request(identifier, namespace, domain, operation, output, searchtype, **kwargs).read()
    return response


def get_json(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, operation=None, searchtype=None, **kwargs):
    &#34;&#34;&#34;Request wrapper that automatically parses JSON response and supresses NotFoundError.&#34;&#34;&#34;
    try:
        return json.loads(get(identifier, namespace, domain, operation, &#39;JSON&#39;, searchtype, **kwargs).decode())
    except NotFoundError as e:
        log.info(e)
        return None

def get_sdf(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;,operation=None, searchtype=None, **kwargs):
    &#34;&#34;&#34;Request wrapper that automatically parses SDF response and supresses NotFoundError.&#34;&#34;&#34;
    try:
        return get(identifier, namespace, domain, operation, &#39;SDF&#39;, searchtype, **kwargs).decode()
    except NotFoundError as e:
        log.info(e)
        return None

def get_compounds(identifier, namespace=&#39;cid&#39;, searchtype=None, as_dataframe=False, **kwargs):
    &#34;&#34;&#34;Retrieve the specified compound records from PubChem.

    :param identifier: The compound identifier to use as a search query.
    :param namespace: (optional) The identifier type, one of cid, name, smiles, sdf, inchi, inchikey or formula.
    :param searchtype: (optional) The advanced search type, one of substructure, superstructure or similarity.
    :param as_dataframe: (optional) Automatically extract the :class:`~pubchempy.Compound` properties into a pandas
                         :class:`~pandas.DataFrame` and return that.
    &#34;&#34;&#34;
    results = get_json(identifier, namespace, searchtype=searchtype, **kwargs)
    compounds = [Compound(r) for r in results[&#39;PC_Compounds&#39;]] if results else []
    if as_dataframe:
        return compounds_to_frame(compounds)
    return compounds


def get_substances(identifier, namespace=&#39;sid&#39;, as_dataframe=False, **kwargs):
    &#34;&#34;&#34;Retrieve the specified substance records from PubChem.

    :param identifier: The substance identifier to use as a search query.
    :param namespace: (optional) The identifier type, one of sid, name or sourceid/&lt;source name&gt;.
    :param as_dataframe: (optional) Automatically extract the :class:`~pubchempy.Substance` properties into a pandas
                         :class:`~pandas.DataFrame` and return that.
    &#34;&#34;&#34;
    results = get_json(identifier, namespace, &#39;substance&#39;, **kwargs)
    substances = [Substance(r) for r in results[&#39;PC_Substances&#39;]] if results else []
    if as_dataframe:
        return substances_to_frame(substances)
    return substances


def get_assays(identifier, namespace=&#39;aid&#39;, **kwargs):
    &#34;&#34;&#34;Retrieve the specified assay records from PubChem.

    :param identifier: The assay identifier to use as a search query.
    :param namespace: (optional) The identifier type.
    &#34;&#34;&#34;
    results = get_json(identifier, namespace, &#39;assay&#39;, &#39;description&#39;, **kwargs)
    return [Assay(r) for r in results[&#39;PC_AssayContainer&#39;]] if results else []


# Allows properties to optionally be specified as underscore_separated, consistent with Compound attributes
PROPERTY_MAP = {
    &#39;molecular_formula&#39;: &#39;MolecularFormula&#39;,
    &#39;molecular_weight&#39;: &#39;MolecularWeight&#39;,
    &#39;canonical_smiles&#39;: &#39;CanonicalSMILES&#39;,
    &#39;isomeric_smiles&#39;: &#39;IsomericSMILES&#39;,
    &#39;inchi&#39;: &#39;InChI&#39;,
    &#39;inchikey&#39;: &#39;InChIKey&#39;,
    &#39;iupac_name&#39;: &#39;IUPACName&#39;,
    &#39;xlogp&#39;: &#39;XLogP&#39;,
    &#39;exact_mass&#39;: &#39;ExactMass&#39;,
    &#39;monoisotopic_mass&#39;: &#39;MonoisotopicMass&#39;,
    &#39;tpsa&#39;: &#39;TPSA&#39;,
    &#39;complexity&#39;: &#39;Complexity&#39;,
    &#39;charge&#39;: &#39;Charge&#39;,
    &#39;h_bond_donor_count&#39;: &#39;HBondDonorCount&#39;,
    &#39;h_bond_acceptor_count&#39;: &#39;HBondAcceptorCount&#39;,
    &#39;rotatable_bond_count&#39;: &#39;RotatableBondCount&#39;,
    &#39;heavy_atom_count&#39;: &#39;HeavyAtomCount&#39;,
    &#39;isotope_atom_count&#39;: &#39;IsotopeAtomCount&#39;,
    &#39;atom_stereo_count&#39;: &#39;AtomStereoCount&#39;,
    &#39;defined_atom_stereo_count&#39;: &#39;DefinedAtomStereoCount&#39;,
    &#39;undefined_atom_stereo_count&#39;: &#39;UndefinedAtomStereoCount&#39;,
    &#39;bond_stereo_count&#39;: &#39;BondStereoCount&#39;,
    &#39;defined_bond_stereo_count&#39;: &#39;DefinedBondStereoCount&#39;,
    &#39;undefined_bond_stereo_count&#39;: &#39;UndefinedBondStereoCount&#39;,
    &#39;covalent_unit_count&#39;: &#39;CovalentUnitCount&#39;,
    &#39;volume_3d&#39;: &#39;Volume3D&#39;,
    &#39;conformer_rmsd_3d&#39;: &#39;ConformerModelRMSD3D&#39;,
    &#39;conformer_model_rmsd_3d&#39;: &#39;ConformerModelRMSD3D&#39;,
    &#39;x_steric_quadrupole_3d&#39;: &#39;XStericQuadrupole3D&#39;,
    &#39;y_steric_quadrupole_3d&#39;: &#39;YStericQuadrupole3D&#39;,
    &#39;z_steric_quadrupole_3d&#39;: &#39;ZStericQuadrupole3D&#39;,
    &#39;feature_count_3d&#39;: &#39;FeatureCount3D&#39;,
    &#39;feature_acceptor_count_3d&#39;: &#39;FeatureAcceptorCount3D&#39;,
    &#39;feature_donor_count_3d&#39;: &#39;FeatureDonorCount3D&#39;,
    &#39;feature_anion_count_3d&#39;: &#39;FeatureAnionCount3D&#39;,
    &#39;feature_cation_count_3d&#39;: &#39;FeatureCationCount3D&#39;,
    &#39;feature_ring_count_3d&#39;: &#39;FeatureRingCount3D&#39;,
    &#39;feature_hydrophobe_count_3d&#39;: &#39;FeatureHydrophobeCount3D&#39;,
    &#39;effective_rotor_count_3d&#39;: &#39;EffectiveRotorCount3D&#39;,
    &#39;conformer_count_3d&#39;: &#39;ConformerCount3D&#39;,
}


def get_properties(properties, identifier, namespace=&#39;cid&#39;, searchtype=None, as_dataframe=False, **kwargs):
    &#34;&#34;&#34;Retrieve the specified properties from PubChem.

    :param identifier: The compound, substance or assay identifier to use as a search query.
    :param namespace: (optional) The identifier type.
    :param searchtype: (optional) The advanced search type, one of substructure, superstructure or similarity.
    :param as_dataframe: (optional) Automatically extract the properties into a pandas :class:`~pandas.DataFrame`.
    &#34;&#34;&#34;
    if isinstance(properties, text_types):
        properties = properties.split(&#39;,&#39;)
    properties = &#39;,&#39;.join([PROPERTY_MAP.get(p, p) for p in properties])
    properties = &#39;property/%s&#39; % properties
    results = get_json(identifier, namespace, &#39;compound&#39;, properties, searchtype=searchtype, **kwargs)
    results = results[&#39;PropertyTable&#39;][&#39;Properties&#39;] if results else []
    if as_dataframe:
        import pandas as pd
        return pd.DataFrame.from_records(results, index=&#39;CID&#39;)
    return results


def get_synonyms(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, searchtype=None, **kwargs):
    results = get_json(identifier, namespace, domain, &#39;synonyms&#39;, searchtype=searchtype, **kwargs)
    return results[&#39;InformationList&#39;][&#39;Information&#39;] if results else []


def get_cids(identifier, namespace=&#39;name&#39;, domain=&#39;compound&#39;, searchtype=None, **kwargs):
    results = get_json(identifier, namespace, domain, &#39;cids&#39;, searchtype=searchtype, **kwargs)
    if not results:
        return []
    elif &#39;IdentifierList&#39; in results:
        return results[&#39;IdentifierList&#39;][&#39;CID&#39;]
    elif &#39;InformationList&#39; in results:
        return results[&#39;InformationList&#39;][&#39;Information&#39;]


def get_sids(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, searchtype=None, **kwargs):
    results = get_json(identifier, namespace, domain, &#39;sids&#39;, searchtype=searchtype, **kwargs)
    if not results:
        return []
    elif &#39;IdentifierList&#39; in results:
        return results[&#39;IdentifierList&#39;][&#39;SID&#39;]
    elif &#39;InformationList&#39; in results:
        return results[&#39;InformationList&#39;][&#39;Information&#39;]


def get_aids(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, searchtype=None, **kwargs):
    results = get_json(identifier, namespace, domain, &#39;aids&#39;, searchtype=searchtype, **kwargs)
    if not results:
        return []
    elif &#39;IdentifierList&#39; in results:
        return results[&#39;IdentifierList&#39;][&#39;AID&#39;]
    elif &#39;InformationList&#39; in results:
        return results[&#39;InformationList&#39;][&#39;Information&#39;]


def get_all_sources(domain=&#39;substance&#39;):
    &#34;&#34;&#34;Return a list of all current depositors of substances or assays.&#34;&#34;&#34;
    results = json.loads(get(domain, None, &#39;sources&#39;).decode())
    return results[&#39;InformationList&#39;][&#39;SourceName&#39;]


def download(outformat, path, identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, operation=None, searchtype=None,
             overwrite=False, **kwargs):
    &#34;&#34;&#34;Format can be  XML, ASNT/B, JSON, SDF, CSV, PNG, TXT.&#34;&#34;&#34;
    response = get(identifier, namespace, domain, operation, outformat, searchtype, **kwargs)
    if not overwrite and os.path.isfile(path):
        raise IOError(&#34;%s already exists. Use &#39;overwrite=True&#39; to overwrite it.&#34; % path)
    with open(path, &#39;wb&#39;) as f:
        f.write(response)


def memoized_property(fget):
    &#34;&#34;&#34;Decorator to create memoized properties.

    Used to cache :class:`~pubchempy.Compound` and :class:`~pubchempy.Substance` properties that require an additional
    request.
    &#34;&#34;&#34;
    attr_name = &#39;_{0}&#39;.format(fget.__name__)

    @functools.wraps(fget)
    def fget_memoized(self):
        if not hasattr(self, attr_name):
            setattr(self, attr_name, fget(self))
        return getattr(self, attr_name)
    return property(fget_memoized)


def deprecated(message=None):
    &#34;&#34;&#34;Decorator to mark functions as deprecated. A warning will be emitted when the function is used.&#34;&#34;&#34;
    def deco(func):
        @functools.wraps(func)
        def wrapped(*args, **kwargs):
            warnings.warn(
                message or &#39;Call to deprecated function {}&#39;.format(func.__name__),
                category=PubChemPyDeprecationWarning,
                stacklevel=2
            )
            return func(*args, **kwargs)
        return wrapped
    return deco


class Atom(object):
    &#34;&#34;&#34;Class to represent an atom in a :class:`~pubchempy.Compound`.&#34;&#34;&#34;

    def __init__(self, aid, number, x=None, y=None, z=None, charge=0):
        &#34;&#34;&#34;Initialize with an atom ID, atomic number, coordinates and optional change.

        :param int aid: Atom ID
        :param int number: Atomic number
        :param float x: X coordinate.
        :param float y: Y coordinate.
        :param float z: (optional) Z coordinate.
        :param int charge: (optional) Formal charge on atom.
        &#34;&#34;&#34;
        self.aid = aid
        &#34;&#34;&#34;The atom ID within the owning Compound.&#34;&#34;&#34;
        self.number = number
        &#34;&#34;&#34;The atomic number for this atom.&#34;&#34;&#34;
        self.x = x
        &#34;&#34;&#34;The x coordinate for this atom.&#34;&#34;&#34;
        self.y = y
        &#34;&#34;&#34;The y coordinate for this atom.&#34;&#34;&#34;
        self.z = z
        &#34;&#34;&#34;The z coordinate for this atom. Will be ``None`` in 2D Compound records.&#34;&#34;&#34;
        self.charge = charge
        &#34;&#34;&#34;The formal charge on this atom.&#34;&#34;&#34;

    def __repr__(self):
        return &#39;Atom(%s, %s)&#39; % (self.aid, self.element)

    def __eq__(self, other):
        return (isinstance(other, type(self)) and self.aid == other.aid and self.element == other.element and
                self.x == other.x and self.y == other.y and self.z == other.z and self.charge == other.charge)

    @deprecated(&#39;Dictionary style access to Atom attributes is deprecated&#39;)
    def __getitem__(self, prop):
        &#34;&#34;&#34;Allow dict-style access to attributes to ease transition from when atoms were dicts.&#34;&#34;&#34;
        if prop in {&#39;element&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;charge&#39;}:
            return getattr(self, prop)
        raise KeyError(prop)

    @deprecated(&#39;Dictionary style access to Atom attributes is deprecated&#39;)
    def __setitem__(self, prop, val):
        &#34;&#34;&#34;Allow dict-style setting of attributes to ease transition from when atoms were dicts.&#34;&#34;&#34;
        setattr(self, prop, val)

    @deprecated(&#39;Dictionary style access to Atom attributes is deprecated&#39;)
    def __contains__(self, prop):
        &#34;&#34;&#34;Allow dict-style checking of attributes to ease transition from when atoms were dicts.&#34;&#34;&#34;
        if prop in {&#39;element&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;charge&#39;}:
            return getattr(self, prop) is not None
        return False

    @property
    def element(self):
        &#34;&#34;&#34;The element symbol for this atom.&#34;&#34;&#34;
        return ELEMENTS.get(self.number, None)

    def to_dict(self):
        &#34;&#34;&#34;Return a dictionary containing Atom data.&#34;&#34;&#34;
        data = {&#39;aid&#39;: self.aid, &#39;number&#39;: self.number, &#39;element&#39;: self.element}
        for coord in {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;}:
            if getattr(self, coord) is not None:
                data[coord] = getattr(self, coord)
        if self.charge != 0: # self.charge is not 0: (fixed Olivier Vitrac)
            data[&#39;charge&#39;] = self.charge
        return data

    def set_coordinates(self, x, y, z=None):
        &#34;&#34;&#34;Set all coordinate dimensions at once.&#34;&#34;&#34;
        self.x = x
        self.y = y
        self.z = z

    @property
    def coordinate_type(self):
        &#34;&#34;&#34;Whether this atom has 2D or 3D coordinates.&#34;&#34;&#34;
        return &#39;2d&#39; if self.z is None else &#39;3d&#39;


class Bond(object):
    &#34;&#34;&#34;Class to represent a bond between two atoms in a :class:`~pubchempy.Compound`.&#34;&#34;&#34;

    def __init__(self, aid1, aid2, order=BondType.SINGLE, style=None):
        &#34;&#34;&#34;Initialize with begin and end atom IDs, bond order and bond style.

        :param int aid1: Begin atom ID.
        :param int aid2: End atom ID.
        :param int order: Bond order.
        &#34;&#34;&#34;
        self.aid1 = aid1
        &#34;&#34;&#34;ID of the begin atom of this bond.&#34;&#34;&#34;
        self.aid2 = aid2
        &#34;&#34;&#34;ID of the end atom of this bond.&#34;&#34;&#34;
        self.order = order
        &#34;&#34;&#34;Bond order.&#34;&#34;&#34;
        self.style = style
        &#34;&#34;&#34;Bond style annotation.&#34;&#34;&#34;

    def __repr__(self):
        return &#39;Bond(%s, %s, %s)&#39; % (self.aid1, self.aid2, self.order)

    def __eq__(self, other):
        return (isinstance(other, type(self)) and self.aid1 == other.aid1 and self.aid2 == other.aid2 and
                self.order == other.order and self.style == other.style)

    @deprecated(&#39;Dictionary style access to Bond attributes is deprecated&#39;)
    def __getitem__(self, prop):
        &#34;&#34;&#34;Allow dict-style access to attributes to ease transition from when bonds were dicts.&#34;&#34;&#34;
        if prop in {&#39;order&#39;, &#39;style&#39;}:
            return getattr(self, prop)
        raise KeyError(prop)

    @deprecated(&#39;Dictionary style access to Bond attributes is deprecated&#39;)
    def __setitem__(self, prop, val):
        &#34;&#34;&#34;Allow dict-style setting of attributes to ease transition from when bonds were dicts.&#34;&#34;&#34;
        setattr(self, prop, val)

    @deprecated(&#39;Dictionary style access to Atom attributes is deprecated&#39;)
    def __contains__(self, prop):
        &#34;&#34;&#34;Allow dict-style checking of attributes to ease transition from when bonds were dicts.&#34;&#34;&#34;
        if prop in {&#39;order&#39;, &#39;style&#39;}:
            return getattr(self, prop) is not None
        return False

    @deprecated(&#39;Dictionary style access to Atom attributes is deprecated&#39;)
    def __delitem__(self, prop):
        &#34;&#34;&#34;Delete the property prop from the wrapped object.&#34;&#34;&#34;
        if not hasattr(self.__wrapped, prop):
            raise KeyError(prop)
        delattr(self.__wrapped, prop)

    def to_dict(self):
        &#34;&#34;&#34;Return a dictionary containing Bond data.&#34;&#34;&#34;
        data = {&#39;aid1&#39;: self.aid1, &#39;aid2&#39;: self.aid2, &#39;order&#39;: self.order}
        if self.style is not None:
            data[&#39;style&#39;] = self.style
        return data


class Compound(object):
    &#34;&#34;&#34;Corresponds to a single record from the PubChem Compound database.

    The PubChem Compound database is constructed from the Substance database using a standardization and deduplication
    process. Each Compound is uniquely identified by a CID.
    &#34;&#34;&#34;
    def __init__(self, record):
        &#34;&#34;&#34;Initialize with a record dict from the PubChem PUG REST service.

        For most users, the ``from_cid()`` class method is probably a better way of creating Compounds.

        :param dict record: A compound record returned by the PubChem PUG REST service.
        &#34;&#34;&#34;
        self._record = None
        self._atoms = {}
        self._bonds = {}
        self.record = record

    @property
    def record(self):
        &#34;&#34;&#34;The raw compound record returned by the PubChem PUG REST service.&#34;&#34;&#34;
        return self._record

    @record.setter
    def record(self, record):
        self._record = record
        log.debug(&#39;Created %s&#39; % self)
        self._setup_atoms()
        self._setup_bonds()

    def _setup_atoms(self):
        &#34;&#34;&#34;Derive Atom objects from the record.&#34;&#34;&#34;
        # Delete existing atoms
        self._atoms = {}
        # Create atoms
        aids = self.record[&#39;atoms&#39;][&#39;aid&#39;]
        elements = self.record[&#39;atoms&#39;][&#39;element&#39;]
        if not len(aids) == len(elements):
            raise ResponseParseError(&#39;Error parsing atom elements&#39;)
        for aid, element in zip(aids, elements):
            self._atoms[aid] = Atom(aid=aid, number=element)
        # Add coordinates
        if &#39;coords&#39; in self.record:
            coord_ids = self.record[&#39;coords&#39;][0][&#39;aid&#39;]
            xs = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0][&#39;x&#39;]
            ys = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0][&#39;y&#39;]
            zs = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0].get(&#39;z&#39;, [])
            if not len(coord_ids) == len(xs) == len(ys) == len(self._atoms) or (zs and not len(zs) == len(coord_ids)):
                raise ResponseParseError(&#39;Error parsing atom coordinates&#39;)
            for aid, x, y, z in zip_longest(coord_ids, xs, ys, zs):
                self._atoms[aid].set_coordinates(x, y, z)
        # Add charges
        if &#39;charge&#39; in self.record[&#39;atoms&#39;]:
            for charge in self.record[&#39;atoms&#39;][&#39;charge&#39;]:
                self._atoms[charge[&#39;aid&#39;]].charge = charge[&#39;value&#39;]

    def _setup_bonds(self):
        &#34;&#34;&#34;Derive Bond objects from the record.&#34;&#34;&#34;
        self._bonds = {}
        if &#39;bonds&#39; not in self.record:
            return
        # Create bonds
        aid1s = self.record[&#39;bonds&#39;][&#39;aid1&#39;]
        aid2s = self.record[&#39;bonds&#39;][&#39;aid2&#39;]
        orders = self.record[&#39;bonds&#39;][&#39;order&#39;]
        if not len(aid1s) == len(aid2s) == len(orders):
            raise ResponseParseError(&#39;Error parsing bonds&#39;)
        for aid1, aid2, order in zip(aid1s, aid2s, orders):
            self._bonds[frozenset((aid1, aid2))] = Bond(aid1=aid1, aid2=aid2, order=order)
        # Add styles
        if &#39;coords&#39; in self.record and &#39;style&#39; in self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]:
            aid1s = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0][&#39;style&#39;][&#39;aid1&#39;]
            aid2s = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0][&#39;style&#39;][&#39;aid2&#39;]
            styles = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0][&#39;style&#39;][&#39;annotation&#39;]
            for aid1, aid2, style in zip(aid1s, aid2s, styles):
                self._bonds[frozenset((aid1, aid2))].style = style

    @classmethod
    def from_cid(cls, cid, **kwargs):
        &#34;&#34;&#34;Retrieve the Compound record for the specified CID.

        Usage::

            c = Compound.from_cid(6819)

        :param int cid: The PubChem Compound Identifier (CID).
        &#34;&#34;&#34;
        record = json.loads(request(cid, **kwargs).read().decode())[&#39;PC_Compounds&#39;][0]
        return cls(record)

    def __repr__(self):
        return &#39;Compound(%s)&#39; % self.cid if self.cid else &#39;Compound()&#39;

    def __eq__(self, other):
        return isinstance(other, type(self)) and self.record == other.record

    def to_dict(self, properties=None):
        &#34;&#34;&#34;Return a dictionary containing Compound data. Optionally specify a list of the desired properties.

        synonyms, aids and sids are not included unless explicitly specified using the properties parameter. This is
        because they each require an extra request.
        &#34;&#34;&#34;
        if not properties:
            skip = {&#39;aids&#39;, &#39;sids&#39;, &#39;synonyms&#39;}
            properties = [p for p in dir(Compound) if isinstance(getattr(Compound, p), property) and p not in skip]
        return {p: [i.to_dict() for i in getattr(self, p)] if p in {&#39;atoms&#39;, &#39;bonds&#39;} else getattr(self, p) for p in properties}

    def to_series(self, properties=None):
        &#34;&#34;&#34;Return a pandas :class:`~pandas.Series` containing Compound data. Optionally specify a list of the desired
        properties.

        synonyms, aids and sids are not included unless explicitly specified using the properties parameter. This is
        because they each require an extra request.
        &#34;&#34;&#34;
        import pandas as pd
        return pd.Series(self.to_dict(properties))

    @property
    def cid(self):
        &#34;&#34;&#34;The PubChem Compound Identifier (CID).

        .. note::

            When searching using a SMILES or InChI query that is not present in the PubChem Compound database, an
            automatically generated record may be returned that contains properties that have been calculated on the
            fly. These records will not have a CID property.
        &#34;&#34;&#34;
        if &#39;id&#39; in self.record and &#39;id&#39; in self.record[&#39;id&#39;] and &#39;cid&#39; in self.record[&#39;id&#39;][&#39;id&#39;]:
            return self.record[&#39;id&#39;][&#39;id&#39;][&#39;cid&#39;]

    @property
    def elements(self):
        &#34;&#34;&#34;List of element symbols for atoms in this Compound.&#34;&#34;&#34;
        return [a.element for a in self.atoms]

    @property
    def atoms(self):
        &#34;&#34;&#34;List of :class:`Atoms &lt;pubchempy.Atom&gt;` in this Compound.&#34;&#34;&#34;
        return sorted(self._atoms.values(), key=lambda x: x.aid)

    @property
    def bonds(self):
        &#34;&#34;&#34;List of :class:`Bonds &lt;pubchempy.Bond&gt;` between :class:`Atoms &lt;pubchempy.Atom&gt;` in this Compound.&#34;&#34;&#34;
        return sorted(self._bonds.values(), key=lambda x: (x.aid1, x.aid2))

    @memoized_property
    def synonyms(self):
        &#34;&#34;&#34;A ranked list of all the names associated with this Compound.

        Requires an extra request. Result is cached.
        &#34;&#34;&#34;
        if self.cid:
            results = get_json(self.cid, operation=&#39;synonyms&#39;)
            return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;Synonym&#39;] if results else []

    @memoized_property
    def sids(self):
        &#34;&#34;&#34;Requires an extra request. Result is cached.&#34;&#34;&#34;
        if self.cid:
            results = get_json(self.cid, operation=&#39;sids&#39;)
            return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;SID&#39;] if results else []

    @memoized_property
    def aids(self):
        &#34;&#34;&#34;Requires an extra request. Result is cached.&#34;&#34;&#34;
        if self.cid:
            results = get_json(self.cid, operation=&#39;aids&#39;)
            return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;AID&#39;] if results else []

    @property
    def coordinate_type(self):
        if CoordinateType.TWO_D in self.record[&#39;coords&#39;][0][&#39;type&#39;]:
            return &#39;2d&#39;
        elif CoordinateType.THREE_D in self.record[&#39;coords&#39;][0][&#39;type&#39;]:
            return &#39;3d&#39;

    @property
    def charge(self):
        &#34;&#34;&#34;Formal charge on this Compound.&#34;&#34;&#34;
        return self.record[&#39;charge&#39;] if &#39;charge&#39; in self.record else 0

    @property
    def molecular_formula(self):
        &#34;&#34;&#34;Molecular formula.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;Molecular Formula&#39;}, self.record[&#39;props&#39;])

    @property
    def molecular_weight(self):
        &#34;&#34;&#34;Molecular Weight.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;Molecular Weight&#39;}, self.record[&#39;props&#39;])

    @property
    def canonical_smiles(self):
        &#34;&#34;&#34;Canonical SMILES, with no stereochemistry information.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;SMILES&#39;, &#39;name&#39;: &#39;Canonical&#39;}, self.record[&#39;props&#39;])

    @property
    def isomeric_smiles(self):
        &#34;&#34;&#34;Isomeric SMILES.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;SMILES&#39;, &#39;name&#39;: &#39;Isomeric&#39;}, self.record[&#39;props&#39;])

    @property
    def inchi(self):
        &#34;&#34;&#34;InChI string.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;InChI&#39;, &#39;name&#39;: &#39;Standard&#39;}, self.record[&#39;props&#39;])

    @property
    def inchikey(self):
        &#34;&#34;&#34;InChIKey.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;InChIKey&#39;, &#39;name&#39;: &#39;Standard&#39;}, self.record[&#39;props&#39;])

    @property
    def iupac_name(self):
        &#34;&#34;&#34;Preferred IUPAC name.&#34;&#34;&#34;
        # Note: Allowed, CAS-like Style, Preferred, Systematic, Traditional are available in full record
        return _parse_prop({&#39;label&#39;: &#39;IUPAC Name&#39;, &#39;name&#39;: &#39;Preferred&#39;}, self.record[&#39;props&#39;])

    @property
    def xlogp(self):
        &#34;&#34;&#34;XLogP.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;Log P&#39;}, self.record[&#39;props&#39;])

    @property
    def exact_mass(self):
        &#34;&#34;&#34;Exact mass.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;Mass&#39;, &#39;name&#39;: &#39;Exact&#39;}, self.record[&#39;props&#39;])

    @property
    def monoisotopic_mass(self):
        &#34;&#34;&#34;Monoisotopic mass.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;Weight&#39;, &#39;name&#39;: &#39;MonoIsotopic&#39;}, self.record[&#39;props&#39;])

    @property
    def tpsa(self):
        &#34;&#34;&#34;Topological Polar Surface Area.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_TPSA&#39;}, self.record[&#39;props&#39;])

    @property
    def complexity(self):
        &#34;&#34;&#34;Complexity.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_COMPLEXITY&#39;}, self.record[&#39;props&#39;])

    @property
    def h_bond_donor_count(self):
        &#34;&#34;&#34;Hydrogen bond donor count.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_NHDONORS&#39;}, self.record[&#39;props&#39;])

    @property
    def h_bond_acceptor_count(self):
        &#34;&#34;&#34;Hydrogen bond acceptor count.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_NHACCEPTORS&#39;}, self.record[&#39;props&#39;])

    @property
    def rotatable_bond_count(self):
        &#34;&#34;&#34;Rotatable bond count.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_NROTBONDS&#39;}, self.record[&#39;props&#39;])

    @property
    def fingerprint(self):
        &#34;&#34;&#34;Raw padded and hex-encoded fingerprint, as returned by the PUG REST API.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_SCREEN&#39;}, self.record[&#39;props&#39;])

    @property
    def cactvs_fingerprint(self):
        &#34;&#34;&#34;PubChem CACTVS fingerprint.

        Each bit in the fingerprint represents the presence or absence of one of 881 chemical substructures.

        More information at ftp://ftp.ncbi.nlm.nih.gov/pubchem/specifications/pubchem_fingerprints.txt
        &#34;&#34;&#34;
        # Skip first 4 bytes (contain length of fingerprint) and last 7 bits (padding) then re-pad to 881 bits
        return &#39;{0:020b}&#39;.format(int(self.fingerprint[8:], 16))[:-7].zfill(881)

    @property
    def heavy_atom_count(self):
        &#34;&#34;&#34;Heavy atom count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;heavy_atom&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;heavy_atom&#39;]

    @property
    def isotope_atom_count(self):
        &#34;&#34;&#34;Isotope atom count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;isotope_atom&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;isotope_atom&#39;]

    @property
    def atom_stereo_count(self):
        &#34;&#34;&#34;Atom stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;atom_chiral&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;atom_chiral&#39;]

    @property
    def defined_atom_stereo_count(self):
        &#34;&#34;&#34;Defined atom stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;atom_chiral_def&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;atom_chiral_def&#39;]

    @property
    def undefined_atom_stereo_count(self):
        &#34;&#34;&#34;Undefined atom stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;atom_chiral_undef&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;atom_chiral_undef&#39;]

    @property
    def bond_stereo_count(self):
        &#34;&#34;&#34;Bond stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;bond_chiral&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;bond_chiral&#39;]

    @property
    def defined_bond_stereo_count(self):
        &#34;&#34;&#34;Defined bond stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;bond_chiral_def&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;bond_chiral_def&#39;]

    @property
    def undefined_bond_stereo_count(self):
        &#34;&#34;&#34;Undefined bond stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;bond_chiral_undef&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;bond_chiral_undef&#39;]

    @property
    def covalent_unit_count(self):
        &#34;&#34;&#34;Covalently-bonded unit count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;covalent_unit&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;covalent_unit&#39;]

    @property
    def volume_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Shape&#39;, &#39;name&#39;: &#39;Volume&#39;}, conf[&#39;data&#39;])

    @property
    def multipoles_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Shape&#39;, &#39;name&#39;: &#39;Multipoles&#39;}, conf[&#39;data&#39;])

    @property
    def conformer_rmsd_3d(self):
        coords = self.record[&#39;coords&#39;][0]
        if &#39;data&#39; in coords:
            return _parse_prop({&#39;label&#39;: &#39;Conformer&#39;, &#39;name&#39;: &#39;RMSD&#39;}, coords[&#39;data&#39;])

    @property
    def effective_rotor_count_3d(self):
        return _parse_prop({&#39;label&#39;: &#39;Count&#39;, &#39;name&#39;: &#39;Effective Rotor&#39;}, self.record[&#39;props&#39;])

    @property
    def pharmacophore_features_3d(self):
        return _parse_prop({&#39;label&#39;: &#39;Features&#39;, &#39;name&#39;: &#39;Pharmacophore&#39;}, self.record[&#39;props&#39;])

    @property
    def mmff94_partial_charges_3d(self):
        return _parse_prop({&#39;label&#39;: &#39;Charge&#39;, &#39;name&#39;: &#39;MMFF94 Partial&#39;}, self.record[&#39;props&#39;])

    @property
    def mmff94_energy_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Energy&#39;, &#39;name&#39;: &#39;MMFF94 NoEstat&#39;}, conf[&#39;data&#39;])

    @property
    def conformer_id_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Conformer&#39;, &#39;name&#39;: &#39;ID&#39;}, conf[&#39;data&#39;])

    @property
    def shape_selfoverlap_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Shape&#39;, &#39;name&#39;: &#39;Self Overlap&#39;}, conf[&#39;data&#39;])

    @property
    def feature_selfoverlap_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Feature&#39;, &#39;name&#39;: &#39;Self Overlap&#39;}, conf[&#39;data&#39;])

    @property
    def shape_fingerprint_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Fingerprint&#39;, &#39;name&#39;: &#39;Shape&#39;}, conf[&#39;data&#39;])


def _parse_prop(search, proplist):
    &#34;&#34;&#34;Extract property value from record using the given urn search filter.&#34;&#34;&#34;
    props = [i for i in proplist if all(item in i[&#39;urn&#39;].items() for item in search.items())]
    if len(props) &gt; 0:
        return props[0][&#39;value&#39;][list(props[0][&#39;value&#39;].keys())[0]]


class Substance(object):
    &#34;&#34;&#34;Corresponds to a single record from the PubChem Substance database.

    The PubChem Substance database contains all chemical records deposited in PubChem in their most raw form, before
    any significant processing is applied. As a result, it contains duplicates, mixtures, and some records that don&#39;t
    make chemical sense. This means that Substance records contain fewer calculated properties, however they do have
    additional information about the original source that deposited the record.

    The PubChem Compound database is constructed from the Substance database using a standardization and deduplication
    process. Hence each Compound may be derived from a number of different Substances.
    &#34;&#34;&#34;

    @classmethod
    def from_sid(cls, sid):
        &#34;&#34;&#34;Retrieve the Substance record for the specified SID.

        :param int sid: The PubChem Substance Identifier (SID).
        &#34;&#34;&#34;
        record = json.loads(request(sid, &#39;sid&#39;, &#39;substance&#39;).read().decode())[&#39;PC_Substances&#39;][0]
        return cls(record)

    def __init__(self, record):
        self.record = record
        &#34;&#34;&#34;A dictionary containing the full Substance record that all other properties are obtained from.&#34;&#34;&#34;

    def __repr__(self):
        return &#39;Substance(%s)&#39; % self.sid if self.sid else &#39;Substance()&#39;

    def __eq__(self, other):
        return isinstance(other, type(self)) and self.record == other.record

    def to_dict(self, properties=None):
        &#34;&#34;&#34;Return a dictionary containing Substance data.

        If the properties parameter is not specified, everything except cids and aids is included. This is because the
        aids and cids properties each require an extra request to retrieve.

        :param properties: (optional) A list of the desired properties.
        &#34;&#34;&#34;
        if not properties:
            skip = {&#39;deposited_compound&#39;, &#39;standardized_compound&#39;, &#39;cids&#39;, &#39;aids&#39;}
            properties = [p for p in dir(Substance) if isinstance(getattr(Substance, p), property) and p not in skip]
        return {p: getattr(self, p) for p in properties}

    def to_series(self, properties=None):
        &#34;&#34;&#34;Return a pandas :class:`~pandas.Series` containing Substance data.

        If the properties parameter is not specified, everything except cids and aids is included. This is because the
        aids and cids properties each require an extra request to retrieve.

        :param properties: (optional) A list of the desired properties.
        &#34;&#34;&#34;
        import pandas as pd
        return pd.Series(self.to_dict(properties))

    @property
    def sid(self):
        &#34;&#34;&#34;The PubChem Substance Idenfitier (SID).&#34;&#34;&#34;
        return self.record[&#39;sid&#39;][&#39;id&#39;]

    @property
    def synonyms(self):
        &#34;&#34;&#34;A ranked list of all the names associated with this Substance.&#34;&#34;&#34;
        if &#39;synonyms&#39; in self.record:
            return self.record[&#39;synonyms&#39;]

    @property
    def source_name(self):
        &#34;&#34;&#34;The name of the PubChem depositor that was the source of this Substance.&#34;&#34;&#34;
        return self.record[&#39;source&#39;][&#39;db&#39;][&#39;name&#39;]

    @property
    def source_id(self):
        &#34;&#34;&#34;Unique ID for this Substance within those from the same PubChem depositor source.&#34;&#34;&#34;
        return self.record[&#39;source&#39;][&#39;db&#39;][&#39;source_id&#39;][&#39;str&#39;]

    @property
    def standardized_cid(self):
        &#34;&#34;&#34;The CID of the Compound that was produced when this Substance was standardized.

        May not exist if this Substance was not standardizable.
        &#34;&#34;&#34;
        for c in self.record[&#39;compound&#39;]:
            if c[&#39;id&#39;][&#39;type&#39;] == CompoundIdType.STANDARDIZED:
                return c[&#39;id&#39;][&#39;id&#39;][&#39;cid&#39;]

    @memoized_property
    def standardized_compound(self):
        &#34;&#34;&#34;Return the :class:`~pubchempy.Compound` that was produced when this Substance was standardized.

        Requires an extra request. Result is cached.
        &#34;&#34;&#34;
        for c in self.record[&#39;compound&#39;]:
            if c[&#39;id&#39;][&#39;type&#39;] == CompoundIdType.STANDARDIZED:
                return Compound.from_cid(c[&#39;id&#39;][&#39;id&#39;][&#39;cid&#39;])

    @property
    def deposited_compound(self):
        &#34;&#34;&#34;Return a :class:`~pubchempy.Compound` produced from the unstandardized Substance record as deposited.

        The resulting :class:`~pubchempy.Compound` will not have a ``cid`` and will be missing most properties.
        &#34;&#34;&#34;
        for c in self.record[&#39;compound&#39;]:
            if c[&#39;id&#39;][&#39;type&#39;] == CompoundIdType.DEPOSITED:
                return Compound(c)

    @memoized_property
    def cids(self):
        &#34;&#34;&#34;A list of all CIDs for Compounds that were produced when this Substance was standardized.

        Requires an extra request. Result is cached.&#34;&#34;&#34;
        results = get_json(self.sid, &#39;sid&#39;, &#39;substance&#39;, &#39;cids&#39;)
        return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;CID&#39;] if results else []

    @memoized_property
    def aids(self):
        &#34;&#34;&#34;A list of all AIDs for Assays associated with this Substance.

        Requires an extra request. Result is cached.&#34;&#34;&#34;
        results = get_json(self.sid, &#39;sid&#39;, &#39;substance&#39;, &#39;aids&#39;)
        return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;AID&#39;] if results else []


class Assay(object):

    @classmethod
    def from_aid(cls, aid):
        &#34;&#34;&#34;Retrieve the Assay record for the specified AID.

        :param int aid: The PubChem Assay Identifier (AID).
        &#34;&#34;&#34;
        record = json.loads(request(aid, &#39;aid&#39;, &#39;assay&#39;, &#39;description&#39;).read().decode())[&#39;PC_AssayContainer&#39;][0]
        return cls(record)

    def __init__(self, record):
        self.record = record
        &#34;&#34;&#34;A dictionary containing the full Assay record that all other properties are obtained from.&#34;&#34;&#34;

    def __repr__(self):
        return &#39;Assay(%s)&#39; % self.aid if self.aid else &#39;Assay()&#39;

    def __eq__(self, other):
        return isinstance(other, type(self)) and self.record == other.record

    def to_dict(self, properties=None):
        &#34;&#34;&#34;Return a dictionary containing Assay data.

        If the properties parameter is not specified, everything is included.

        :param properties: (optional) A list of the desired properties.
        &#34;&#34;&#34;
        if not properties:
            properties = [p for p in dir(Assay) if isinstance(getattr(Assay, p), property)]
        return {p: getattr(self, p) for p in properties}

    @property
    def aid(self):
        &#34;&#34;&#34;The PubChem Substance Idenfitier (SID).&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;aid&#39;][&#39;id&#39;]

    @property
    def name(self):
        &#34;&#34;&#34;The short assay name, used for display purposes.&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;name&#39;]

    @property
    def description(self):
        &#34;&#34;&#34;Description&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;description&#39;]

    @property
    def project_category(self):
        &#34;&#34;&#34;A category to distinguish projects funded through MLSCN, MLPCN or from literature.

        Possible values include mlscn, mlpcn, mlscn-ap, mlpcn-ap, literature-extracted, literature-author,
        literature-publisher, rnaigi.
        &#34;&#34;&#34;
        if &#39;project_category&#39; in self.record[&#39;assay&#39;][&#39;descr&#39;]:
            return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;project_category&#39;]

    @property
    def comments(self):
        &#34;&#34;&#34;Comments and additional information.&#34;&#34;&#34;
        return [comment for comment in self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;comment&#39;] if comment]

    @property
    def results(self):
        &#34;&#34;&#34;A list of dictionaries containing details of the results from this Assay.&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;results&#39;]

    @property
    def target(self):
        &#34;&#34;&#34;A list of dictionaries containing details of the Assay targets.&#34;&#34;&#34;
        if &#39;target&#39; in self.record[&#39;assay&#39;][&#39;descr&#39;]:
            return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;target&#39;]

    @property
    def revision(self):
        &#34;&#34;&#34;Revision identifier for textual description.&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;revision&#39;]

    @property
    def aid_version(self):
        &#34;&#34;&#34;Incremented when the original depositor updates the record.&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;aid&#39;][&#39;version&#39;]


def compounds_to_frame(compounds, properties=None):
    &#34;&#34;&#34;Construct a pandas :class:`~pandas.DataFrame` from a list of :class:`~pubchempy.Compound` objects.

    Optionally specify a list of the desired :class:`~pubchempy.Compound` properties.
    &#34;&#34;&#34;
    import pandas as pd
    if isinstance(compounds, Compound):
        compounds = [compounds]
    properties = set(properties) | set([&#39;cid&#39;]) if properties else None
    return pd.DataFrame.from_records([c.to_dict(properties) for c in compounds], index=&#39;cid&#39;)


def substances_to_frame(substances, properties=None):
    &#34;&#34;&#34;Construct a pandas :class:`~pandas.DataFrame` from a list of :class:`~pubchempy.Substance` objects.

    Optionally specify a list of the desired :class:`~pubchempy.Substance` properties.
    &#34;&#34;&#34;
    import pandas as pd
    if isinstance(substances, Substance):
        substances = [substances]
    properties = set(properties) | set([&#39;sid&#39;]) if properties else None
    return pd.DataFrame.from_records([s.to_dict(properties) for s in substances], index=&#39;sid&#39;)


# def add_columns_to_frame(dataframe, id_col, id_namespace, add_cols):
#     &#34;&#34;&#34;&#34;&#34;&#34;
#     # Existing dataframe with some identifier column
#     # But consider what to do if the identifier column is an index?
#     # What about having the Compound/Substance object as a column?


class PubChemPyDeprecationWarning(Warning):
    &#34;&#34;&#34;Warning category for deprecated features.&#34;&#34;&#34;
    pass


class PubChemPyError(Exception):
    &#34;&#34;&#34;Base class for all PubChemPy exceptions.&#34;&#34;&#34;
    pass


class ResponseParseError(PubChemPyError):
    &#34;&#34;&#34;PubChem response is uninterpretable.&#34;&#34;&#34;
    pass


class PubChemHTTPError(PubChemPyError):
    &#34;&#34;&#34;Generic error class to handle all HTTP error codes.&#34;&#34;&#34;
    def __init__(self, e):
        self.code = e.code
        self.msg = e.reason
        try:
            self.msg += &#39;: %s&#39; % json.loads(e.read().decode())[&#39;Fault&#39;][&#39;Details&#39;][0]
        except (ValueError, IndexError, KeyError):
            pass
        if self.code == 400:
            raise BadRequestError(self.msg)
        elif self.code == 404:
            raise NotFoundError(self.msg)
        elif self.code == 405:
            raise MethodNotAllowedError(self.msg)
        elif self.code == 504:
            raise TimeoutError(self.msg)
        elif self.code == 501:
            raise UnimplementedError(self.msg)
        elif self.code == 500:
            raise ServerError(self.msg)

    def __str__(self):
        return repr(self.msg)


class BadRequestError(PubChemHTTPError):
    &#34;&#34;&#34;Request is improperly formed (syntax error in the URL, POST body, etc.).&#34;&#34;&#34;
    def __init__(self, msg=&#39;Request is improperly formed&#39;):
        self.msg = msg


class NotFoundError(PubChemHTTPError):
    &#34;&#34;&#34;The input record was not found (e.g. invalid CID).&#34;&#34;&#34;
    def __init__(self, msg=&#39;The input record was not found&#39;):
        self.msg = msg


class MethodNotAllowedError(PubChemHTTPError):
    &#34;&#34;&#34;Request not allowed (such as invalid MIME type in the HTTP Accept header).&#34;&#34;&#34;
    def __init__(self, msg=&#39;Request not allowed&#39;):
        self.msg = msg


class TimeoutError(PubChemHTTPError):
    &#34;&#34;&#34;The request timed out, from server overload or too broad a request.

    See :ref:`Avoiding TimeoutError &lt;avoiding_timeouterror&gt;` for more information.
    &#34;&#34;&#34;
    def __init__(self, msg=&#39;The request timed out&#39;):
        self.msg = msg


class UnimplementedError(PubChemHTTPError):
    &#34;&#34;&#34;The requested operation has not (yet) been implemented by the server.&#34;&#34;&#34;
    def __init__(self, msg=&#39;The requested operation has not been implemented&#39;):
        self.msg = msg


class ServerError(PubChemHTTPError):
    &#34;&#34;&#34;Some problem on the server side (such as a database server down, etc.).&#34;&#34;&#34;
    def __init__(self, msg=&#39;Some problem on the server side&#39;):
        self.msg = msg


if __name__ == &#39;__main__&#39;:
    print(__version__)

    #from private.pubchempy import get_compounds
    import re

    # Simple example

    cas_pattern = re.compile(r&#39;^\d{1,7}-\d{2}-\d$&#39;)
    matches = get_compounds(&#39;anisole&#39;, &#39;name&#39;)
    nmatches = len(matches)
    if nmatches&gt;0:
        synonyms = matches[0].synonyms
        cas_list = [syn.strip() for syn in synonyms if cas_pattern.match(syn.strip())]
        record = {
         &#39;CID&#39;: matches[0].cid,
        &#39;name&#39;: matches[0].iupac_name,
    &#39;synonyms&#39;: synonyms,
         &#39;CAS&#39;: cas_list,
           &#39;M&#39;: matches[0].molecular_weight,
     &#39;formula&#39;: matches[0].molecular_formula,
      &#39;SMILES&#39;: matches[0].canonical_smiles,
       &#39;InChi&#39;: matches[0].inchi,
    &#39;InChiKey&#39;: matches[0].inchikey,
        &#39;logP&#39;: matches[0].xlogp,
       # &#39;raw&#39; : matches[0], # we store all info as raw
       &#39;date&#39; : &#34;add here the date of the record&#34;
       }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pubchempy.compounds_to_frame"><code class="name flex">
<span>def <span class="ident">compounds_to_frame</span></span>(<span>compounds, properties=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a pandas :class:<code>~pandas.DataFrame</code> from a list of :class:<code>~pubchempy.Compound</code> objects.</p>
<p>Optionally specify a list of the desired :class:<code>~pubchempy.Compound</code> properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compounds_to_frame(compounds, properties=None):
    &#34;&#34;&#34;Construct a pandas :class:`~pandas.DataFrame` from a list of :class:`~pubchempy.Compound` objects.

    Optionally specify a list of the desired :class:`~pubchempy.Compound` properties.
    &#34;&#34;&#34;
    import pandas as pd
    if isinstance(compounds, Compound):
        compounds = [compounds]
    properties = set(properties) | set([&#39;cid&#39;]) if properties else None
    return pd.DataFrame.from_records([c.to_dict(properties) for c in compounds], index=&#39;cid&#39;)</code></pre>
</details>
</dd>
<dt id="pubchempy.deprecated"><code class="name flex">
<span>def <span class="ident">deprecated</span></span>(<span>message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to mark functions as deprecated. A warning will be emitted when the function is used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deprecated(message=None):
    &#34;&#34;&#34;Decorator to mark functions as deprecated. A warning will be emitted when the function is used.&#34;&#34;&#34;
    def deco(func):
        @functools.wraps(func)
        def wrapped(*args, **kwargs):
            warnings.warn(
                message or &#39;Call to deprecated function {}&#39;.format(func.__name__),
                category=PubChemPyDeprecationWarning,
                stacklevel=2
            )
            return func(*args, **kwargs)
        return wrapped
    return deco</code></pre>
</details>
</dd>
<dt id="pubchempy.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>outformat, path, identifier, namespace='cid', domain='compound', operation=None, searchtype=None, overwrite=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Format can be
XML, ASNT/B, JSON, SDF, CSV, PNG, TXT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(outformat, path, identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, operation=None, searchtype=None,
             overwrite=False, **kwargs):
    &#34;&#34;&#34;Format can be  XML, ASNT/B, JSON, SDF, CSV, PNG, TXT.&#34;&#34;&#34;
    response = get(identifier, namespace, domain, operation, outformat, searchtype, **kwargs)
    if not overwrite and os.path.isfile(path):
        raise IOError(&#34;%s already exists. Use &#39;overwrite=True&#39; to overwrite it.&#34; % path)
    with open(path, &#39;wb&#39;) as f:
        f.write(response)</code></pre>
</details>
</dd>
<dt id="pubchempy.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>identifier, namespace='cid', domain='compound', operation=None, output='JSON', searchtype=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Request wrapper that automatically handles async requests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, operation=None, output=&#39;JSON&#39;, searchtype=None, **kwargs):
    &#34;&#34;&#34;Request wrapper that automatically handles async requests.&#34;&#34;&#34;
    if (searchtype and searchtype != &#39;xref&#39;) or namespace in [&#39;formula&#39;]:
        response = request(identifier, namespace, domain, None, &#39;JSON&#39;, searchtype, **kwargs).read()
        status = json.loads(response.decode())
        if &#39;Waiting&#39; in status and &#39;ListKey&#39; in status[&#39;Waiting&#39;]:
            identifier = status[&#39;Waiting&#39;][&#39;ListKey&#39;]
            namespace = &#39;listkey&#39;
            while &#39;Waiting&#39; in status and &#39;ListKey&#39; in status[&#39;Waiting&#39;]:
                time.sleep(2)
                response = request(identifier, namespace, domain, operation, &#39;JSON&#39;, **kwargs).read()
                status = json.loads(response.decode())
            if not output == &#39;JSON&#39;:
                response = request(identifier, namespace, domain, operation, output, searchtype, **kwargs).read()
    else:
        response = request(identifier, namespace, domain, operation, output, searchtype, **kwargs).read()
    return response</code></pre>
</details>
</dd>
<dt id="pubchempy.get_aids"><code class="name flex">
<span>def <span class="ident">get_aids</span></span>(<span>identifier, namespace='cid', domain='compound', searchtype=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_aids(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, searchtype=None, **kwargs):
    results = get_json(identifier, namespace, domain, &#39;aids&#39;, searchtype=searchtype, **kwargs)
    if not results:
        return []
    elif &#39;IdentifierList&#39; in results:
        return results[&#39;IdentifierList&#39;][&#39;AID&#39;]
    elif &#39;InformationList&#39; in results:
        return results[&#39;InformationList&#39;][&#39;Information&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.get_all_sources"><code class="name flex">
<span>def <span class="ident">get_all_sources</span></span>(<span>domain='substance')</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of all current depositors of substances or assays.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_sources(domain=&#39;substance&#39;):
    &#34;&#34;&#34;Return a list of all current depositors of substances or assays.&#34;&#34;&#34;
    results = json.loads(get(domain, None, &#39;sources&#39;).decode())
    return results[&#39;InformationList&#39;][&#39;SourceName&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.get_assays"><code class="name flex">
<span>def <span class="ident">get_assays</span></span>(<span>identifier, namespace='aid', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the specified assay records from PubChem.</p>
<p>:param identifier: The assay identifier to use as a search query.
:param namespace: (optional) The identifier type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_assays(identifier, namespace=&#39;aid&#39;, **kwargs):
    &#34;&#34;&#34;Retrieve the specified assay records from PubChem.

    :param identifier: The assay identifier to use as a search query.
    :param namespace: (optional) The identifier type.
    &#34;&#34;&#34;
    results = get_json(identifier, namespace, &#39;assay&#39;, &#39;description&#39;, **kwargs)
    return [Assay(r) for r in results[&#39;PC_AssayContainer&#39;]] if results else []</code></pre>
</details>
</dd>
<dt id="pubchempy.get_cids"><code class="name flex">
<span>def <span class="ident">get_cids</span></span>(<span>identifier, namespace='name', domain='compound', searchtype=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cids(identifier, namespace=&#39;name&#39;, domain=&#39;compound&#39;, searchtype=None, **kwargs):
    results = get_json(identifier, namespace, domain, &#39;cids&#39;, searchtype=searchtype, **kwargs)
    if not results:
        return []
    elif &#39;IdentifierList&#39; in results:
        return results[&#39;IdentifierList&#39;][&#39;CID&#39;]
    elif &#39;InformationList&#39; in results:
        return results[&#39;InformationList&#39;][&#39;Information&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.get_compounds"><code class="name flex">
<span>def <span class="ident">get_compounds</span></span>(<span>identifier, namespace='cid', searchtype=None, as_dataframe=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the specified compound records from PubChem.</p>
<p>:param identifier: The compound identifier to use as a search query.
:param namespace: (optional) The identifier type, one of cid, name, smiles, sdf, inchi, inchikey or formula.
:param searchtype: (optional) The advanced search type, one of substructure, superstructure or similarity.
:param as_dataframe: (optional) Automatically extract the :class:<code>~pubchempy.Compound</code> properties into a pandas
:class:<code>~pandas.DataFrame</code> and return that.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_compounds(identifier, namespace=&#39;cid&#39;, searchtype=None, as_dataframe=False, **kwargs):
    &#34;&#34;&#34;Retrieve the specified compound records from PubChem.

    :param identifier: The compound identifier to use as a search query.
    :param namespace: (optional) The identifier type, one of cid, name, smiles, sdf, inchi, inchikey or formula.
    :param searchtype: (optional) The advanced search type, one of substructure, superstructure or similarity.
    :param as_dataframe: (optional) Automatically extract the :class:`~pubchempy.Compound` properties into a pandas
                         :class:`~pandas.DataFrame` and return that.
    &#34;&#34;&#34;
    results = get_json(identifier, namespace, searchtype=searchtype, **kwargs)
    compounds = [Compound(r) for r in results[&#39;PC_Compounds&#39;]] if results else []
    if as_dataframe:
        return compounds_to_frame(compounds)
    return compounds</code></pre>
</details>
</dd>
<dt id="pubchempy.get_json"><code class="name flex">
<span>def <span class="ident">get_json</span></span>(<span>identifier, namespace='cid', domain='compound', operation=None, searchtype=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Request wrapper that automatically parses JSON response and supresses NotFoundError.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_json(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, operation=None, searchtype=None, **kwargs):
    &#34;&#34;&#34;Request wrapper that automatically parses JSON response and supresses NotFoundError.&#34;&#34;&#34;
    try:
        return json.loads(get(identifier, namespace, domain, operation, &#39;JSON&#39;, searchtype, **kwargs).decode())
    except NotFoundError as e:
        log.info(e)
        return None</code></pre>
</details>
</dd>
<dt id="pubchempy.get_properties"><code class="name flex">
<span>def <span class="ident">get_properties</span></span>(<span>properties, identifier, namespace='cid', searchtype=None, as_dataframe=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the specified properties from PubChem.</p>
<p>:param identifier: The compound, substance or assay identifier to use as a search query.
:param namespace: (optional) The identifier type.
:param searchtype: (optional) The advanced search type, one of substructure, superstructure or similarity.
:param as_dataframe: (optional) Automatically extract the properties into a pandas :class:<code>~pandas.DataFrame</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_properties(properties, identifier, namespace=&#39;cid&#39;, searchtype=None, as_dataframe=False, **kwargs):
    &#34;&#34;&#34;Retrieve the specified properties from PubChem.

    :param identifier: The compound, substance or assay identifier to use as a search query.
    :param namespace: (optional) The identifier type.
    :param searchtype: (optional) The advanced search type, one of substructure, superstructure or similarity.
    :param as_dataframe: (optional) Automatically extract the properties into a pandas :class:`~pandas.DataFrame`.
    &#34;&#34;&#34;
    if isinstance(properties, text_types):
        properties = properties.split(&#39;,&#39;)
    properties = &#39;,&#39;.join([PROPERTY_MAP.get(p, p) for p in properties])
    properties = &#39;property/%s&#39; % properties
    results = get_json(identifier, namespace, &#39;compound&#39;, properties, searchtype=searchtype, **kwargs)
    results = results[&#39;PropertyTable&#39;][&#39;Properties&#39;] if results else []
    if as_dataframe:
        import pandas as pd
        return pd.DataFrame.from_records(results, index=&#39;CID&#39;)
    return results</code></pre>
</details>
</dd>
<dt id="pubchempy.get_sdf"><code class="name flex">
<span>def <span class="ident">get_sdf</span></span>(<span>identifier, namespace='cid', domain='compound', operation=None, searchtype=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Request wrapper that automatically parses SDF response and supresses NotFoundError.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sdf(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;,operation=None, searchtype=None, **kwargs):
    &#34;&#34;&#34;Request wrapper that automatically parses SDF response and supresses NotFoundError.&#34;&#34;&#34;
    try:
        return get(identifier, namespace, domain, operation, &#39;SDF&#39;, searchtype, **kwargs).decode()
    except NotFoundError as e:
        log.info(e)
        return None</code></pre>
</details>
</dd>
<dt id="pubchempy.get_sids"><code class="name flex">
<span>def <span class="ident">get_sids</span></span>(<span>identifier, namespace='cid', domain='compound', searchtype=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sids(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, searchtype=None, **kwargs):
    results = get_json(identifier, namespace, domain, &#39;sids&#39;, searchtype=searchtype, **kwargs)
    if not results:
        return []
    elif &#39;IdentifierList&#39; in results:
        return results[&#39;IdentifierList&#39;][&#39;SID&#39;]
    elif &#39;InformationList&#39; in results:
        return results[&#39;InformationList&#39;][&#39;Information&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.get_substances"><code class="name flex">
<span>def <span class="ident">get_substances</span></span>(<span>identifier, namespace='sid', as_dataframe=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the specified substance records from PubChem.</p>
<p>:param identifier: The substance identifier to use as a search query.
:param namespace: (optional) The identifier type, one of sid, name or sourceid/<source name>.
:param as_dataframe: (optional) Automatically extract the :class:<code>~pubchempy.Substance</code> properties into a pandas
:class:<code>~pandas.DataFrame</code> and return that.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_substances(identifier, namespace=&#39;sid&#39;, as_dataframe=False, **kwargs):
    &#34;&#34;&#34;Retrieve the specified substance records from PubChem.

    :param identifier: The substance identifier to use as a search query.
    :param namespace: (optional) The identifier type, one of sid, name or sourceid/&lt;source name&gt;.
    :param as_dataframe: (optional) Automatically extract the :class:`~pubchempy.Substance` properties into a pandas
                         :class:`~pandas.DataFrame` and return that.
    &#34;&#34;&#34;
    results = get_json(identifier, namespace, &#39;substance&#39;, **kwargs)
    substances = [Substance(r) for r in results[&#39;PC_Substances&#39;]] if results else []
    if as_dataframe:
        return substances_to_frame(substances)
    return substances</code></pre>
</details>
</dd>
<dt id="pubchempy.get_synonyms"><code class="name flex">
<span>def <span class="ident">get_synonyms</span></span>(<span>identifier, namespace='cid', domain='compound', searchtype=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_synonyms(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, searchtype=None, **kwargs):
    results = get_json(identifier, namespace, domain, &#39;synonyms&#39;, searchtype=searchtype, **kwargs)
    return results[&#39;InformationList&#39;][&#39;Information&#39;] if results else []</code></pre>
</details>
</dd>
<dt id="pubchempy.memoized_property"><code class="name flex">
<span>def <span class="ident">memoized_property</span></span>(<span>fget)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator to create memoized properties.</p>
<p>Used to cache :class:<code>~pubchempy.Compound</code> and :class:<code>~pubchempy.Substance</code> properties that require an additional
request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memoized_property(fget):
    &#34;&#34;&#34;Decorator to create memoized properties.

    Used to cache :class:`~pubchempy.Compound` and :class:`~pubchempy.Substance` properties that require an additional
    request.
    &#34;&#34;&#34;
    attr_name = &#39;_{0}&#39;.format(fget.__name__)

    @functools.wraps(fget)
    def fget_memoized(self):
        if not hasattr(self, attr_name):
            setattr(self, attr_name, fget(self))
        return getattr(self, attr_name)
    return property(fget_memoized)</code></pre>
</details>
</dd>
<dt id="pubchempy.request"><code class="name flex">
<span>def <span class="ident">request</span></span>(<span>identifier, namespace='cid', domain='compound', operation=None, output='JSON', searchtype=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct API request from parameters and return the response.</p>
<p>Full specification at <a href="http://pubchem.ncbi.nlm.nih.gov/pug_rest/PUG_REST.html">http://pubchem.ncbi.nlm.nih.gov/pug_rest/PUG_REST.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request(identifier, namespace=&#39;cid&#39;, domain=&#39;compound&#39;, operation=None, output=&#39;JSON&#39;, searchtype=None, **kwargs):
    &#34;&#34;&#34;
    Construct API request from parameters and return the response.

    Full specification at http://pubchem.ncbi.nlm.nih.gov/pug_rest/PUG_REST.html
    &#34;&#34;&#34;
    if not identifier:
        raise ValueError(&#39;identifier/cid cannot be None&#39;)
    # If identifier is a list, join with commas into string
    if isinstance(identifier, int):
        identifier = str(identifier)
    if not isinstance(identifier, text_types):
        identifier = &#39;,&#39;.join(str(x) for x in identifier)
    # Filter None values from kwargs
    kwargs = dict((k, v) for k, v in kwargs.items() if v is not None)
    # Build API URL
    urlid, postdata = None, None
    if namespace == &#39;sourceid&#39;:
        identifier = identifier.replace(&#39;/&#39;, &#39;.&#39;)
    if namespace in [&#39;listkey&#39;, &#39;formula&#39;, &#39;sourceid&#39;] \
            or searchtype == &#39;xref&#39; \
            or (searchtype and namespace == &#39;cid&#39;) or domain == &#39;sources&#39;:
        urlid = quote(identifier.encode(&#39;utf8&#39;))
    else:
        postdata = urlencode([(namespace, identifier)]).encode(&#39;utf8&#39;)
    comps = filter(None, [API_BASE, domain, searchtype, namespace, urlid, operation, output])
    apiurl = &#39;/&#39;.join(comps)
    if kwargs:
        apiurl += &#39;?%s&#39; % urlencode(kwargs)
    # Make request
    try:
        log.debug(&#39;Request URL: %s&#39;, apiurl)
        log.debug(&#39;Request data: %s&#39;, postdata)
        response = urlopen(apiurl, postdata)
        return response
    except HTTPError as e:
        raise PubChemHTTPError(e)</code></pre>
</details>
</dd>
<dt id="pubchempy.substances_to_frame"><code class="name flex">
<span>def <span class="ident">substances_to_frame</span></span>(<span>substances, properties=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a pandas :class:<code>~pandas.DataFrame</code> from a list of :class:<code>~pubchempy.Substance</code> objects.</p>
<p>Optionally specify a list of the desired :class:<code>~pubchempy.Substance</code> properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def substances_to_frame(substances, properties=None):
    &#34;&#34;&#34;Construct a pandas :class:`~pandas.DataFrame` from a list of :class:`~pubchempy.Substance` objects.

    Optionally specify a list of the desired :class:`~pubchempy.Substance` properties.
    &#34;&#34;&#34;
    import pandas as pd
    if isinstance(substances, Substance):
        substances = [substances]
    properties = set(properties) | set([&#39;sid&#39;]) if properties else None
    return pd.DataFrame.from_records([s.to_dict(properties) for s in substances], index=&#39;sid&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pubchempy.Assay"><code class="flex name class">
<span>class <span class="ident">Assay</span></span>
<span>(</span><span>record)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Assay(object):

    @classmethod
    def from_aid(cls, aid):
        &#34;&#34;&#34;Retrieve the Assay record for the specified AID.

        :param int aid: The PubChem Assay Identifier (AID).
        &#34;&#34;&#34;
        record = json.loads(request(aid, &#39;aid&#39;, &#39;assay&#39;, &#39;description&#39;).read().decode())[&#39;PC_AssayContainer&#39;][0]
        return cls(record)

    def __init__(self, record):
        self.record = record
        &#34;&#34;&#34;A dictionary containing the full Assay record that all other properties are obtained from.&#34;&#34;&#34;

    def __repr__(self):
        return &#39;Assay(%s)&#39; % self.aid if self.aid else &#39;Assay()&#39;

    def __eq__(self, other):
        return isinstance(other, type(self)) and self.record == other.record

    def to_dict(self, properties=None):
        &#34;&#34;&#34;Return a dictionary containing Assay data.

        If the properties parameter is not specified, everything is included.

        :param properties: (optional) A list of the desired properties.
        &#34;&#34;&#34;
        if not properties:
            properties = [p for p in dir(Assay) if isinstance(getattr(Assay, p), property)]
        return {p: getattr(self, p) for p in properties}

    @property
    def aid(self):
        &#34;&#34;&#34;The PubChem Substance Idenfitier (SID).&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;aid&#39;][&#39;id&#39;]

    @property
    def name(self):
        &#34;&#34;&#34;The short assay name, used for display purposes.&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;name&#39;]

    @property
    def description(self):
        &#34;&#34;&#34;Description&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;description&#39;]

    @property
    def project_category(self):
        &#34;&#34;&#34;A category to distinguish projects funded through MLSCN, MLPCN or from literature.

        Possible values include mlscn, mlpcn, mlscn-ap, mlpcn-ap, literature-extracted, literature-author,
        literature-publisher, rnaigi.
        &#34;&#34;&#34;
        if &#39;project_category&#39; in self.record[&#39;assay&#39;][&#39;descr&#39;]:
            return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;project_category&#39;]

    @property
    def comments(self):
        &#34;&#34;&#34;Comments and additional information.&#34;&#34;&#34;
        return [comment for comment in self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;comment&#39;] if comment]

    @property
    def results(self):
        &#34;&#34;&#34;A list of dictionaries containing details of the results from this Assay.&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;results&#39;]

    @property
    def target(self):
        &#34;&#34;&#34;A list of dictionaries containing details of the Assay targets.&#34;&#34;&#34;
        if &#39;target&#39; in self.record[&#39;assay&#39;][&#39;descr&#39;]:
            return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;target&#39;]

    @property
    def revision(self):
        &#34;&#34;&#34;Revision identifier for textual description.&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;revision&#39;]

    @property
    def aid_version(self):
        &#34;&#34;&#34;Incremented when the original depositor updates the record.&#34;&#34;&#34;
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;aid&#39;][&#39;version&#39;]</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pubchempy.Assay.from_aid"><code class="name flex">
<span>def <span class="ident">from_aid</span></span>(<span>aid)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the Assay record for the specified AID.</p>
<p>:param int aid: The PubChem Assay Identifier (AID).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_aid(cls, aid):
    &#34;&#34;&#34;Retrieve the Assay record for the specified AID.

    :param int aid: The PubChem Assay Identifier (AID).
    &#34;&#34;&#34;
    record = json.loads(request(aid, &#39;aid&#39;, &#39;assay&#39;, &#39;description&#39;).read().decode())[&#39;PC_AssayContainer&#39;][0]
    return cls(record)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pubchempy.Assay.aid"><code class="name">var <span class="ident">aid</span></code></dt>
<dd>
<div class="desc"><p>The PubChem Substance Idenfitier (SID).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def aid(self):
    &#34;&#34;&#34;The PubChem Substance Idenfitier (SID).&#34;&#34;&#34;
    return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;aid&#39;][&#39;id&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Assay.aid_version"><code class="name">var <span class="ident">aid_version</span></code></dt>
<dd>
<div class="desc"><p>Incremented when the original depositor updates the record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def aid_version(self):
    &#34;&#34;&#34;Incremented when the original depositor updates the record.&#34;&#34;&#34;
    return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;aid&#39;][&#39;version&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Assay.comments"><code class="name">var <span class="ident">comments</span></code></dt>
<dd>
<div class="desc"><p>Comments and additional information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def comments(self):
    &#34;&#34;&#34;Comments and additional information.&#34;&#34;&#34;
    return [comment for comment in self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;comment&#39;] if comment]</code></pre>
</details>
</dd>
<dt id="pubchempy.Assay.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"><p>Description</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def description(self):
    &#34;&#34;&#34;Description&#34;&#34;&#34;
    return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;description&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Assay.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>The short assay name, used for display purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;The short assay name, used for display purposes.&#34;&#34;&#34;
    return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;name&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Assay.project_category"><code class="name">var <span class="ident">project_category</span></code></dt>
<dd>
<div class="desc"><p>A category to distinguish projects funded through MLSCN, MLPCN or from literature.</p>
<p>Possible values include mlscn, mlpcn, mlscn-ap, mlpcn-ap, literature-extracted, literature-author,
literature-publisher, rnaigi.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def project_category(self):
    &#34;&#34;&#34;A category to distinguish projects funded through MLSCN, MLPCN or from literature.

    Possible values include mlscn, mlpcn, mlscn-ap, mlpcn-ap, literature-extracted, literature-author,
    literature-publisher, rnaigi.
    &#34;&#34;&#34;
    if &#39;project_category&#39; in self.record[&#39;assay&#39;][&#39;descr&#39;]:
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;project_category&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Assay.record"><code class="name">var <span class="ident">record</span></code></dt>
<dd>
<div class="desc"><p>A dictionary containing the full Assay record that all other properties are obtained from.</p></div>
</dd>
<dt id="pubchempy.Assay.results"><code class="name">var <span class="ident">results</span></code></dt>
<dd>
<div class="desc"><p>A list of dictionaries containing details of the results from this Assay.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def results(self):
    &#34;&#34;&#34;A list of dictionaries containing details of the results from this Assay.&#34;&#34;&#34;
    return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;results&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Assay.revision"><code class="name">var <span class="ident">revision</span></code></dt>
<dd>
<div class="desc"><p>Revision identifier for textual description.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def revision(self):
    &#34;&#34;&#34;Revision identifier for textual description.&#34;&#34;&#34;
    return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;revision&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Assay.target"><code class="name">var <span class="ident">target</span></code></dt>
<dd>
<div class="desc"><p>A list of dictionaries containing details of the Assay targets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def target(self):
    &#34;&#34;&#34;A list of dictionaries containing details of the Assay targets.&#34;&#34;&#34;
    if &#39;target&#39; in self.record[&#39;assay&#39;][&#39;descr&#39;]:
        return self.record[&#39;assay&#39;][&#39;descr&#39;][&#39;target&#39;]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pubchempy.Assay.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, properties=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary containing Assay data.</p>
<p>If the properties parameter is not specified, everything is included.</p>
<p>:param properties: (optional) A list of the desired properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, properties=None):
    &#34;&#34;&#34;Return a dictionary containing Assay data.

    If the properties parameter is not specified, everything is included.

    :param properties: (optional) A list of the desired properties.
    &#34;&#34;&#34;
    if not properties:
        properties = [p for p in dir(Assay) if isinstance(getattr(Assay, p), property)]
    return {p: getattr(self, p) for p in properties}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pubchempy.Atom"><code class="flex name class">
<span>class <span class="ident">Atom</span></span>
<span>(</span><span>aid, number, x=None, y=None, z=None, charge=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent an atom in a :class:<code>~pubchempy.Compound</code>.</p>
<p>Initialize with an atom ID, atomic number, coordinates and optional change.</p>
<p>:param int aid: Atom ID
:param int number: Atomic number
:param float x: X coordinate.
:param float y: Y coordinate.
:param float z: (optional) Z coordinate.
:param int charge: (optional) Formal charge on atom.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Atom(object):
    &#34;&#34;&#34;Class to represent an atom in a :class:`~pubchempy.Compound`.&#34;&#34;&#34;

    def __init__(self, aid, number, x=None, y=None, z=None, charge=0):
        &#34;&#34;&#34;Initialize with an atom ID, atomic number, coordinates and optional change.

        :param int aid: Atom ID
        :param int number: Atomic number
        :param float x: X coordinate.
        :param float y: Y coordinate.
        :param float z: (optional) Z coordinate.
        :param int charge: (optional) Formal charge on atom.
        &#34;&#34;&#34;
        self.aid = aid
        &#34;&#34;&#34;The atom ID within the owning Compound.&#34;&#34;&#34;
        self.number = number
        &#34;&#34;&#34;The atomic number for this atom.&#34;&#34;&#34;
        self.x = x
        &#34;&#34;&#34;The x coordinate for this atom.&#34;&#34;&#34;
        self.y = y
        &#34;&#34;&#34;The y coordinate for this atom.&#34;&#34;&#34;
        self.z = z
        &#34;&#34;&#34;The z coordinate for this atom. Will be ``None`` in 2D Compound records.&#34;&#34;&#34;
        self.charge = charge
        &#34;&#34;&#34;The formal charge on this atom.&#34;&#34;&#34;

    def __repr__(self):
        return &#39;Atom(%s, %s)&#39; % (self.aid, self.element)

    def __eq__(self, other):
        return (isinstance(other, type(self)) and self.aid == other.aid and self.element == other.element and
                self.x == other.x and self.y == other.y and self.z == other.z and self.charge == other.charge)

    @deprecated(&#39;Dictionary style access to Atom attributes is deprecated&#39;)
    def __getitem__(self, prop):
        &#34;&#34;&#34;Allow dict-style access to attributes to ease transition from when atoms were dicts.&#34;&#34;&#34;
        if prop in {&#39;element&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;charge&#39;}:
            return getattr(self, prop)
        raise KeyError(prop)

    @deprecated(&#39;Dictionary style access to Atom attributes is deprecated&#39;)
    def __setitem__(self, prop, val):
        &#34;&#34;&#34;Allow dict-style setting of attributes to ease transition from when atoms were dicts.&#34;&#34;&#34;
        setattr(self, prop, val)

    @deprecated(&#39;Dictionary style access to Atom attributes is deprecated&#39;)
    def __contains__(self, prop):
        &#34;&#34;&#34;Allow dict-style checking of attributes to ease transition from when atoms were dicts.&#34;&#34;&#34;
        if prop in {&#39;element&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;charge&#39;}:
            return getattr(self, prop) is not None
        return False

    @property
    def element(self):
        &#34;&#34;&#34;The element symbol for this atom.&#34;&#34;&#34;
        return ELEMENTS.get(self.number, None)

    def to_dict(self):
        &#34;&#34;&#34;Return a dictionary containing Atom data.&#34;&#34;&#34;
        data = {&#39;aid&#39;: self.aid, &#39;number&#39;: self.number, &#39;element&#39;: self.element}
        for coord in {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;}:
            if getattr(self, coord) is not None:
                data[coord] = getattr(self, coord)
        if self.charge != 0: # self.charge is not 0: (fixed Olivier Vitrac)
            data[&#39;charge&#39;] = self.charge
        return data

    def set_coordinates(self, x, y, z=None):
        &#34;&#34;&#34;Set all coordinate dimensions at once.&#34;&#34;&#34;
        self.x = x
        self.y = y
        self.z = z

    @property
    def coordinate_type(self):
        &#34;&#34;&#34;Whether this atom has 2D or 3D coordinates.&#34;&#34;&#34;
        return &#39;2d&#39; if self.z is None else &#39;3d&#39;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pubchempy.Atom.aid"><code class="name">var <span class="ident">aid</span></code></dt>
<dd>
<div class="desc"><p>The atom ID within the owning Compound.</p></div>
</dd>
<dt id="pubchempy.Atom.charge"><code class="name">var <span class="ident">charge</span></code></dt>
<dd>
<div class="desc"><p>The formal charge on this atom.</p></div>
</dd>
<dt id="pubchempy.Atom.coordinate_type"><code class="name">var <span class="ident">coordinate_type</span></code></dt>
<dd>
<div class="desc"><p>Whether this atom has 2D or 3D coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coordinate_type(self):
    &#34;&#34;&#34;Whether this atom has 2D or 3D coordinates.&#34;&#34;&#34;
    return &#39;2d&#39; if self.z is None else &#39;3d&#39;</code></pre>
</details>
</dd>
<dt id="pubchempy.Atom.element"><code class="name">var <span class="ident">element</span></code></dt>
<dd>
<div class="desc"><p>The element symbol for this atom.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def element(self):
    &#34;&#34;&#34;The element symbol for this atom.&#34;&#34;&#34;
    return ELEMENTS.get(self.number, None)</code></pre>
</details>
</dd>
<dt id="pubchempy.Atom.number"><code class="name">var <span class="ident">number</span></code></dt>
<dd>
<div class="desc"><p>The atomic number for this atom.</p></div>
</dd>
<dt id="pubchempy.Atom.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p>The x coordinate for this atom.</p></div>
</dd>
<dt id="pubchempy.Atom.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>The y coordinate for this atom.</p></div>
</dd>
<dt id="pubchempy.Atom.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<div class="desc"><p>The z coordinate for this atom. Will be <code>None</code> in 2D Compound records.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pubchempy.Atom.set_coordinates"><code class="name flex">
<span>def <span class="ident">set_coordinates</span></span>(<span>self, x, y, z=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all coordinate dimensions at once.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_coordinates(self, x, y, z=None):
    &#34;&#34;&#34;Set all coordinate dimensions at once.&#34;&#34;&#34;
    self.x = x
    self.y = y
    self.z = z</code></pre>
</details>
</dd>
<dt id="pubchempy.Atom.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary containing Atom data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    &#34;&#34;&#34;Return a dictionary containing Atom data.&#34;&#34;&#34;
    data = {&#39;aid&#39;: self.aid, &#39;number&#39;: self.number, &#39;element&#39;: self.element}
    for coord in {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;}:
        if getattr(self, coord) is not None:
            data[coord] = getattr(self, coord)
    if self.charge != 0: # self.charge is not 0: (fixed Olivier Vitrac)
        data[&#39;charge&#39;] = self.charge
    return data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pubchempy.BadRequestError"><code class="flex name class">
<span>class <span class="ident">BadRequestError</span></span>
<span>(</span><span>msg='Request is improperly formed')</span>
</code></dt>
<dd>
<div class="desc"><p>Request is improperly formed (syntax error in the URL, POST body, etc.).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BadRequestError(PubChemHTTPError):
    &#34;&#34;&#34;Request is improperly formed (syntax error in the URL, POST body, etc.).&#34;&#34;&#34;
    def __init__(self, msg=&#39;Request is improperly formed&#39;):
        self.msg = msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pubchempy.PubChemHTTPError" href="#pubchempy.PubChemHTTPError">PubChemHTTPError</a></li>
<li><a title="pubchempy.PubChemPyError" href="#pubchempy.PubChemPyError">PubChemPyError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pubchempy.Bond"><code class="flex name class">
<span>class <span class="ident">Bond</span></span>
<span>(</span><span>aid1, aid2, order=1, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent a bond between two atoms in a :class:<code>~pubchempy.Compound</code>.</p>
<p>Initialize with begin and end atom IDs, bond order and bond style.</p>
<p>:param int aid1: Begin atom ID.
:param int aid2: End atom ID.
:param int order: Bond order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bond(object):
    &#34;&#34;&#34;Class to represent a bond between two atoms in a :class:`~pubchempy.Compound`.&#34;&#34;&#34;

    def __init__(self, aid1, aid2, order=BondType.SINGLE, style=None):
        &#34;&#34;&#34;Initialize with begin and end atom IDs, bond order and bond style.

        :param int aid1: Begin atom ID.
        :param int aid2: End atom ID.
        :param int order: Bond order.
        &#34;&#34;&#34;
        self.aid1 = aid1
        &#34;&#34;&#34;ID of the begin atom of this bond.&#34;&#34;&#34;
        self.aid2 = aid2
        &#34;&#34;&#34;ID of the end atom of this bond.&#34;&#34;&#34;
        self.order = order
        &#34;&#34;&#34;Bond order.&#34;&#34;&#34;
        self.style = style
        &#34;&#34;&#34;Bond style annotation.&#34;&#34;&#34;

    def __repr__(self):
        return &#39;Bond(%s, %s, %s)&#39; % (self.aid1, self.aid2, self.order)

    def __eq__(self, other):
        return (isinstance(other, type(self)) and self.aid1 == other.aid1 and self.aid2 == other.aid2 and
                self.order == other.order and self.style == other.style)

    @deprecated(&#39;Dictionary style access to Bond attributes is deprecated&#39;)
    def __getitem__(self, prop):
        &#34;&#34;&#34;Allow dict-style access to attributes to ease transition from when bonds were dicts.&#34;&#34;&#34;
        if prop in {&#39;order&#39;, &#39;style&#39;}:
            return getattr(self, prop)
        raise KeyError(prop)

    @deprecated(&#39;Dictionary style access to Bond attributes is deprecated&#39;)
    def __setitem__(self, prop, val):
        &#34;&#34;&#34;Allow dict-style setting of attributes to ease transition from when bonds were dicts.&#34;&#34;&#34;
        setattr(self, prop, val)

    @deprecated(&#39;Dictionary style access to Atom attributes is deprecated&#39;)
    def __contains__(self, prop):
        &#34;&#34;&#34;Allow dict-style checking of attributes to ease transition from when bonds were dicts.&#34;&#34;&#34;
        if prop in {&#39;order&#39;, &#39;style&#39;}:
            return getattr(self, prop) is not None
        return False

    @deprecated(&#39;Dictionary style access to Atom attributes is deprecated&#39;)
    def __delitem__(self, prop):
        &#34;&#34;&#34;Delete the property prop from the wrapped object.&#34;&#34;&#34;
        if not hasattr(self.__wrapped, prop):
            raise KeyError(prop)
        delattr(self.__wrapped, prop)

    def to_dict(self):
        &#34;&#34;&#34;Return a dictionary containing Bond data.&#34;&#34;&#34;
        data = {&#39;aid1&#39;: self.aid1, &#39;aid2&#39;: self.aid2, &#39;order&#39;: self.order}
        if self.style is not None:
            data[&#39;style&#39;] = self.style
        return data</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pubchempy.Bond.aid1"><code class="name">var <span class="ident">aid1</span></code></dt>
<dd>
<div class="desc"><p>ID of the begin atom of this bond.</p></div>
</dd>
<dt id="pubchempy.Bond.aid2"><code class="name">var <span class="ident">aid2</span></code></dt>
<dd>
<div class="desc"><p>ID of the end atom of this bond.</p></div>
</dd>
<dt id="pubchempy.Bond.order"><code class="name">var <span class="ident">order</span></code></dt>
<dd>
<div class="desc"><p>Bond order.</p></div>
</dd>
<dt id="pubchempy.Bond.style"><code class="name">var <span class="ident">style</span></code></dt>
<dd>
<div class="desc"><p>Bond style annotation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pubchempy.Bond.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary containing Bond data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self):
    &#34;&#34;&#34;Return a dictionary containing Bond data.&#34;&#34;&#34;
    data = {&#39;aid1&#39;: self.aid1, &#39;aid2&#39;: self.aid2, &#39;order&#39;: self.order}
    if self.style is not None:
        data[&#39;style&#39;] = self.style
    return data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pubchempy.BondType"><code class="flex name class">
<span>class <span class="ident">BondType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BondType(object):
    SINGLE = 1
    DOUBLE = 2
    TRIPLE = 3
    QUADRUPLE = 4
    DATIVE = 5
    COMPLEX = 6
    IONIC = 7
    UNKNOWN = 255</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pubchempy.BondType.COMPLEX"><code class="name">var <span class="ident">COMPLEX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.BondType.DATIVE"><code class="name">var <span class="ident">DATIVE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.BondType.DOUBLE"><code class="name">var <span class="ident">DOUBLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.BondType.IONIC"><code class="name">var <span class="ident">IONIC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.BondType.QUADRUPLE"><code class="name">var <span class="ident">QUADRUPLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.BondType.SINGLE"><code class="name">var <span class="ident">SINGLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.BondType.TRIPLE"><code class="name">var <span class="ident">TRIPLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.BondType.UNKNOWN"><code class="name">var <span class="ident">UNKNOWN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pubchempy.Compound"><code class="flex name class">
<span>class <span class="ident">Compound</span></span>
<span>(</span><span>record)</span>
</code></dt>
<dd>
<div class="desc"><p>Corresponds to a single record from the PubChem Compound database.</p>
<p>The PubChem Compound database is constructed from the Substance database using a standardization and deduplication
process. Each Compound is uniquely identified by a CID.</p>
<p>Initialize with a record dict from the PubChem PUG REST service.</p>
<p>For most users, the <code>from_cid()</code> class method is probably a better way of creating Compounds.</p>
<p>:param dict record: A compound record returned by the PubChem PUG REST service.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Compound(object):
    &#34;&#34;&#34;Corresponds to a single record from the PubChem Compound database.

    The PubChem Compound database is constructed from the Substance database using a standardization and deduplication
    process. Each Compound is uniquely identified by a CID.
    &#34;&#34;&#34;
    def __init__(self, record):
        &#34;&#34;&#34;Initialize with a record dict from the PubChem PUG REST service.

        For most users, the ``from_cid()`` class method is probably a better way of creating Compounds.

        :param dict record: A compound record returned by the PubChem PUG REST service.
        &#34;&#34;&#34;
        self._record = None
        self._atoms = {}
        self._bonds = {}
        self.record = record

    @property
    def record(self):
        &#34;&#34;&#34;The raw compound record returned by the PubChem PUG REST service.&#34;&#34;&#34;
        return self._record

    @record.setter
    def record(self, record):
        self._record = record
        log.debug(&#39;Created %s&#39; % self)
        self._setup_atoms()
        self._setup_bonds()

    def _setup_atoms(self):
        &#34;&#34;&#34;Derive Atom objects from the record.&#34;&#34;&#34;
        # Delete existing atoms
        self._atoms = {}
        # Create atoms
        aids = self.record[&#39;atoms&#39;][&#39;aid&#39;]
        elements = self.record[&#39;atoms&#39;][&#39;element&#39;]
        if not len(aids) == len(elements):
            raise ResponseParseError(&#39;Error parsing atom elements&#39;)
        for aid, element in zip(aids, elements):
            self._atoms[aid] = Atom(aid=aid, number=element)
        # Add coordinates
        if &#39;coords&#39; in self.record:
            coord_ids = self.record[&#39;coords&#39;][0][&#39;aid&#39;]
            xs = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0][&#39;x&#39;]
            ys = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0][&#39;y&#39;]
            zs = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0].get(&#39;z&#39;, [])
            if not len(coord_ids) == len(xs) == len(ys) == len(self._atoms) or (zs and not len(zs) == len(coord_ids)):
                raise ResponseParseError(&#39;Error parsing atom coordinates&#39;)
            for aid, x, y, z in zip_longest(coord_ids, xs, ys, zs):
                self._atoms[aid].set_coordinates(x, y, z)
        # Add charges
        if &#39;charge&#39; in self.record[&#39;atoms&#39;]:
            for charge in self.record[&#39;atoms&#39;][&#39;charge&#39;]:
                self._atoms[charge[&#39;aid&#39;]].charge = charge[&#39;value&#39;]

    def _setup_bonds(self):
        &#34;&#34;&#34;Derive Bond objects from the record.&#34;&#34;&#34;
        self._bonds = {}
        if &#39;bonds&#39; not in self.record:
            return
        # Create bonds
        aid1s = self.record[&#39;bonds&#39;][&#39;aid1&#39;]
        aid2s = self.record[&#39;bonds&#39;][&#39;aid2&#39;]
        orders = self.record[&#39;bonds&#39;][&#39;order&#39;]
        if not len(aid1s) == len(aid2s) == len(orders):
            raise ResponseParseError(&#39;Error parsing bonds&#39;)
        for aid1, aid2, order in zip(aid1s, aid2s, orders):
            self._bonds[frozenset((aid1, aid2))] = Bond(aid1=aid1, aid2=aid2, order=order)
        # Add styles
        if &#39;coords&#39; in self.record and &#39;style&#39; in self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]:
            aid1s = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0][&#39;style&#39;][&#39;aid1&#39;]
            aid2s = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0][&#39;style&#39;][&#39;aid2&#39;]
            styles = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0][&#39;style&#39;][&#39;annotation&#39;]
            for aid1, aid2, style in zip(aid1s, aid2s, styles):
                self._bonds[frozenset((aid1, aid2))].style = style

    @classmethod
    def from_cid(cls, cid, **kwargs):
        &#34;&#34;&#34;Retrieve the Compound record for the specified CID.

        Usage::

            c = Compound.from_cid(6819)

        :param int cid: The PubChem Compound Identifier (CID).
        &#34;&#34;&#34;
        record = json.loads(request(cid, **kwargs).read().decode())[&#39;PC_Compounds&#39;][0]
        return cls(record)

    def __repr__(self):
        return &#39;Compound(%s)&#39; % self.cid if self.cid else &#39;Compound()&#39;

    def __eq__(self, other):
        return isinstance(other, type(self)) and self.record == other.record

    def to_dict(self, properties=None):
        &#34;&#34;&#34;Return a dictionary containing Compound data. Optionally specify a list of the desired properties.

        synonyms, aids and sids are not included unless explicitly specified using the properties parameter. This is
        because they each require an extra request.
        &#34;&#34;&#34;
        if not properties:
            skip = {&#39;aids&#39;, &#39;sids&#39;, &#39;synonyms&#39;}
            properties = [p for p in dir(Compound) if isinstance(getattr(Compound, p), property) and p not in skip]
        return {p: [i.to_dict() for i in getattr(self, p)] if p in {&#39;atoms&#39;, &#39;bonds&#39;} else getattr(self, p) for p in properties}

    def to_series(self, properties=None):
        &#34;&#34;&#34;Return a pandas :class:`~pandas.Series` containing Compound data. Optionally specify a list of the desired
        properties.

        synonyms, aids and sids are not included unless explicitly specified using the properties parameter. This is
        because they each require an extra request.
        &#34;&#34;&#34;
        import pandas as pd
        return pd.Series(self.to_dict(properties))

    @property
    def cid(self):
        &#34;&#34;&#34;The PubChem Compound Identifier (CID).

        .. note::

            When searching using a SMILES or InChI query that is not present in the PubChem Compound database, an
            automatically generated record may be returned that contains properties that have been calculated on the
            fly. These records will not have a CID property.
        &#34;&#34;&#34;
        if &#39;id&#39; in self.record and &#39;id&#39; in self.record[&#39;id&#39;] and &#39;cid&#39; in self.record[&#39;id&#39;][&#39;id&#39;]:
            return self.record[&#39;id&#39;][&#39;id&#39;][&#39;cid&#39;]

    @property
    def elements(self):
        &#34;&#34;&#34;List of element symbols for atoms in this Compound.&#34;&#34;&#34;
        return [a.element for a in self.atoms]

    @property
    def atoms(self):
        &#34;&#34;&#34;List of :class:`Atoms &lt;pubchempy.Atom&gt;` in this Compound.&#34;&#34;&#34;
        return sorted(self._atoms.values(), key=lambda x: x.aid)

    @property
    def bonds(self):
        &#34;&#34;&#34;List of :class:`Bonds &lt;pubchempy.Bond&gt;` between :class:`Atoms &lt;pubchempy.Atom&gt;` in this Compound.&#34;&#34;&#34;
        return sorted(self._bonds.values(), key=lambda x: (x.aid1, x.aid2))

    @memoized_property
    def synonyms(self):
        &#34;&#34;&#34;A ranked list of all the names associated with this Compound.

        Requires an extra request. Result is cached.
        &#34;&#34;&#34;
        if self.cid:
            results = get_json(self.cid, operation=&#39;synonyms&#39;)
            return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;Synonym&#39;] if results else []

    @memoized_property
    def sids(self):
        &#34;&#34;&#34;Requires an extra request. Result is cached.&#34;&#34;&#34;
        if self.cid:
            results = get_json(self.cid, operation=&#39;sids&#39;)
            return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;SID&#39;] if results else []

    @memoized_property
    def aids(self):
        &#34;&#34;&#34;Requires an extra request. Result is cached.&#34;&#34;&#34;
        if self.cid:
            results = get_json(self.cid, operation=&#39;aids&#39;)
            return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;AID&#39;] if results else []

    @property
    def coordinate_type(self):
        if CoordinateType.TWO_D in self.record[&#39;coords&#39;][0][&#39;type&#39;]:
            return &#39;2d&#39;
        elif CoordinateType.THREE_D in self.record[&#39;coords&#39;][0][&#39;type&#39;]:
            return &#39;3d&#39;

    @property
    def charge(self):
        &#34;&#34;&#34;Formal charge on this Compound.&#34;&#34;&#34;
        return self.record[&#39;charge&#39;] if &#39;charge&#39; in self.record else 0

    @property
    def molecular_formula(self):
        &#34;&#34;&#34;Molecular formula.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;Molecular Formula&#39;}, self.record[&#39;props&#39;])

    @property
    def molecular_weight(self):
        &#34;&#34;&#34;Molecular Weight.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;Molecular Weight&#39;}, self.record[&#39;props&#39;])

    @property
    def canonical_smiles(self):
        &#34;&#34;&#34;Canonical SMILES, with no stereochemistry information.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;SMILES&#39;, &#39;name&#39;: &#39;Canonical&#39;}, self.record[&#39;props&#39;])

    @property
    def isomeric_smiles(self):
        &#34;&#34;&#34;Isomeric SMILES.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;SMILES&#39;, &#39;name&#39;: &#39;Isomeric&#39;}, self.record[&#39;props&#39;])

    @property
    def inchi(self):
        &#34;&#34;&#34;InChI string.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;InChI&#39;, &#39;name&#39;: &#39;Standard&#39;}, self.record[&#39;props&#39;])

    @property
    def inchikey(self):
        &#34;&#34;&#34;InChIKey.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;InChIKey&#39;, &#39;name&#39;: &#39;Standard&#39;}, self.record[&#39;props&#39;])

    @property
    def iupac_name(self):
        &#34;&#34;&#34;Preferred IUPAC name.&#34;&#34;&#34;
        # Note: Allowed, CAS-like Style, Preferred, Systematic, Traditional are available in full record
        return _parse_prop({&#39;label&#39;: &#39;IUPAC Name&#39;, &#39;name&#39;: &#39;Preferred&#39;}, self.record[&#39;props&#39;])

    @property
    def xlogp(self):
        &#34;&#34;&#34;XLogP.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;Log P&#39;}, self.record[&#39;props&#39;])

    @property
    def exact_mass(self):
        &#34;&#34;&#34;Exact mass.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;Mass&#39;, &#39;name&#39;: &#39;Exact&#39;}, self.record[&#39;props&#39;])

    @property
    def monoisotopic_mass(self):
        &#34;&#34;&#34;Monoisotopic mass.&#34;&#34;&#34;
        return _parse_prop({&#39;label&#39;: &#39;Weight&#39;, &#39;name&#39;: &#39;MonoIsotopic&#39;}, self.record[&#39;props&#39;])

    @property
    def tpsa(self):
        &#34;&#34;&#34;Topological Polar Surface Area.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_TPSA&#39;}, self.record[&#39;props&#39;])

    @property
    def complexity(self):
        &#34;&#34;&#34;Complexity.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_COMPLEXITY&#39;}, self.record[&#39;props&#39;])

    @property
    def h_bond_donor_count(self):
        &#34;&#34;&#34;Hydrogen bond donor count.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_NHDONORS&#39;}, self.record[&#39;props&#39;])

    @property
    def h_bond_acceptor_count(self):
        &#34;&#34;&#34;Hydrogen bond acceptor count.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_NHACCEPTORS&#39;}, self.record[&#39;props&#39;])

    @property
    def rotatable_bond_count(self):
        &#34;&#34;&#34;Rotatable bond count.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_NROTBONDS&#39;}, self.record[&#39;props&#39;])

    @property
    def fingerprint(self):
        &#34;&#34;&#34;Raw padded and hex-encoded fingerprint, as returned by the PUG REST API.&#34;&#34;&#34;
        return _parse_prop({&#39;implementation&#39;: &#39;E_SCREEN&#39;}, self.record[&#39;props&#39;])

    @property
    def cactvs_fingerprint(self):
        &#34;&#34;&#34;PubChem CACTVS fingerprint.

        Each bit in the fingerprint represents the presence or absence of one of 881 chemical substructures.

        More information at ftp://ftp.ncbi.nlm.nih.gov/pubchem/specifications/pubchem_fingerprints.txt
        &#34;&#34;&#34;
        # Skip first 4 bytes (contain length of fingerprint) and last 7 bits (padding) then re-pad to 881 bits
        return &#39;{0:020b}&#39;.format(int(self.fingerprint[8:], 16))[:-7].zfill(881)

    @property
    def heavy_atom_count(self):
        &#34;&#34;&#34;Heavy atom count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;heavy_atom&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;heavy_atom&#39;]

    @property
    def isotope_atom_count(self):
        &#34;&#34;&#34;Isotope atom count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;isotope_atom&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;isotope_atom&#39;]

    @property
    def atom_stereo_count(self):
        &#34;&#34;&#34;Atom stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;atom_chiral&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;atom_chiral&#39;]

    @property
    def defined_atom_stereo_count(self):
        &#34;&#34;&#34;Defined atom stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;atom_chiral_def&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;atom_chiral_def&#39;]

    @property
    def undefined_atom_stereo_count(self):
        &#34;&#34;&#34;Undefined atom stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;atom_chiral_undef&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;atom_chiral_undef&#39;]

    @property
    def bond_stereo_count(self):
        &#34;&#34;&#34;Bond stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;bond_chiral&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;bond_chiral&#39;]

    @property
    def defined_bond_stereo_count(self):
        &#34;&#34;&#34;Defined bond stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;bond_chiral_def&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;bond_chiral_def&#39;]

    @property
    def undefined_bond_stereo_count(self):
        &#34;&#34;&#34;Undefined bond stereocenter count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;bond_chiral_undef&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;bond_chiral_undef&#39;]

    @property
    def covalent_unit_count(self):
        &#34;&#34;&#34;Covalently-bonded unit count.&#34;&#34;&#34;
        if &#39;count&#39; in self.record and &#39;covalent_unit&#39; in self.record[&#39;count&#39;]:
            return self.record[&#39;count&#39;][&#39;covalent_unit&#39;]

    @property
    def volume_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Shape&#39;, &#39;name&#39;: &#39;Volume&#39;}, conf[&#39;data&#39;])

    @property
    def multipoles_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Shape&#39;, &#39;name&#39;: &#39;Multipoles&#39;}, conf[&#39;data&#39;])

    @property
    def conformer_rmsd_3d(self):
        coords = self.record[&#39;coords&#39;][0]
        if &#39;data&#39; in coords:
            return _parse_prop({&#39;label&#39;: &#39;Conformer&#39;, &#39;name&#39;: &#39;RMSD&#39;}, coords[&#39;data&#39;])

    @property
    def effective_rotor_count_3d(self):
        return _parse_prop({&#39;label&#39;: &#39;Count&#39;, &#39;name&#39;: &#39;Effective Rotor&#39;}, self.record[&#39;props&#39;])

    @property
    def pharmacophore_features_3d(self):
        return _parse_prop({&#39;label&#39;: &#39;Features&#39;, &#39;name&#39;: &#39;Pharmacophore&#39;}, self.record[&#39;props&#39;])

    @property
    def mmff94_partial_charges_3d(self):
        return _parse_prop({&#39;label&#39;: &#39;Charge&#39;, &#39;name&#39;: &#39;MMFF94 Partial&#39;}, self.record[&#39;props&#39;])

    @property
    def mmff94_energy_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Energy&#39;, &#39;name&#39;: &#39;MMFF94 NoEstat&#39;}, conf[&#39;data&#39;])

    @property
    def conformer_id_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Conformer&#39;, &#39;name&#39;: &#39;ID&#39;}, conf[&#39;data&#39;])

    @property
    def shape_selfoverlap_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Shape&#39;, &#39;name&#39;: &#39;Self Overlap&#39;}, conf[&#39;data&#39;])

    @property
    def feature_selfoverlap_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Feature&#39;, &#39;name&#39;: &#39;Self Overlap&#39;}, conf[&#39;data&#39;])

    @property
    def shape_fingerprint_3d(self):
        conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
        if &#39;data&#39; in conf:
            return _parse_prop({&#39;label&#39;: &#39;Fingerprint&#39;, &#39;name&#39;: &#39;Shape&#39;}, conf[&#39;data&#39;])</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pubchempy.Compound.from_cid"><code class="name flex">
<span>def <span class="ident">from_cid</span></span>(<span>cid, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the Compound record for the specified CID.</p>
<p>Usage::</p>
<pre><code>c = Compound.from_cid(6819)
</code></pre>
<p>:param int cid: The PubChem Compound Identifier (CID).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_cid(cls, cid, **kwargs):
    &#34;&#34;&#34;Retrieve the Compound record for the specified CID.

    Usage::

        c = Compound.from_cid(6819)

    :param int cid: The PubChem Compound Identifier (CID).
    &#34;&#34;&#34;
    record = json.loads(request(cid, **kwargs).read().decode())[&#39;PC_Compounds&#39;][0]
    return cls(record)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pubchempy.Compound.aids"><code class="name">var <span class="ident">aids</span></code></dt>
<dd>
<div class="desc"><p>Requires an extra request. Result is cached.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@memoized_property
def aids(self):
    &#34;&#34;&#34;Requires an extra request. Result is cached.&#34;&#34;&#34;
    if self.cid:
        results = get_json(self.cid, operation=&#39;aids&#39;)
        return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;AID&#39;] if results else []</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.atom_stereo_count"><code class="name">var <span class="ident">atom_stereo_count</span></code></dt>
<dd>
<div class="desc"><p>Atom stereocenter count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def atom_stereo_count(self):
    &#34;&#34;&#34;Atom stereocenter count.&#34;&#34;&#34;
    if &#39;count&#39; in self.record and &#39;atom_chiral&#39; in self.record[&#39;count&#39;]:
        return self.record[&#39;count&#39;][&#39;atom_chiral&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.atoms"><code class="name">var <span class="ident">atoms</span></code></dt>
<dd>
<div class="desc"><p>List of :class:<code>Atoms &lt;pubchempy.Atom&gt;</code> in this Compound.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def atoms(self):
    &#34;&#34;&#34;List of :class:`Atoms &lt;pubchempy.Atom&gt;` in this Compound.&#34;&#34;&#34;
    return sorted(self._atoms.values(), key=lambda x: x.aid)</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.bond_stereo_count"><code class="name">var <span class="ident">bond_stereo_count</span></code></dt>
<dd>
<div class="desc"><p>Bond stereocenter count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bond_stereo_count(self):
    &#34;&#34;&#34;Bond stereocenter count.&#34;&#34;&#34;
    if &#39;count&#39; in self.record and &#39;bond_chiral&#39; in self.record[&#39;count&#39;]:
        return self.record[&#39;count&#39;][&#39;bond_chiral&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.bonds"><code class="name">var <span class="ident">bonds</span></code></dt>
<dd>
<div class="desc"><p>List of :class:<code>Bonds &lt;pubchempy.Bond&gt;</code> between :class:<code>Atoms &lt;pubchempy.Atom&gt;</code> in this Compound.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bonds(self):
    &#34;&#34;&#34;List of :class:`Bonds &lt;pubchempy.Bond&gt;` between :class:`Atoms &lt;pubchempy.Atom&gt;` in this Compound.&#34;&#34;&#34;
    return sorted(self._bonds.values(), key=lambda x: (x.aid1, x.aid2))</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.cactvs_fingerprint"><code class="name">var <span class="ident">cactvs_fingerprint</span></code></dt>
<dd>
<div class="desc"><p>PubChem CACTVS fingerprint.</p>
<p>Each bit in the fingerprint represents the presence or absence of one of 881 chemical substructures.</p>
<p>More information at <a href="ftp://ftp.ncbi.nlm.nih.gov/pubchem/specifications/pubchem_fingerprints.txt">ftp://ftp.ncbi.nlm.nih.gov/pubchem/specifications/pubchem_fingerprints.txt</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cactvs_fingerprint(self):
    &#34;&#34;&#34;PubChem CACTVS fingerprint.

    Each bit in the fingerprint represents the presence or absence of one of 881 chemical substructures.

    More information at ftp://ftp.ncbi.nlm.nih.gov/pubchem/specifications/pubchem_fingerprints.txt
    &#34;&#34;&#34;
    # Skip first 4 bytes (contain length of fingerprint) and last 7 bits (padding) then re-pad to 881 bits
    return &#39;{0:020b}&#39;.format(int(self.fingerprint[8:], 16))[:-7].zfill(881)</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.canonical_smiles"><code class="name">var <span class="ident">canonical_smiles</span></code></dt>
<dd>
<div class="desc"><p>Canonical SMILES, with no stereochemistry information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def canonical_smiles(self):
    &#34;&#34;&#34;Canonical SMILES, with no stereochemistry information.&#34;&#34;&#34;
    return _parse_prop({&#39;label&#39;: &#39;SMILES&#39;, &#39;name&#39;: &#39;Canonical&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.charge"><code class="name">var <span class="ident">charge</span></code></dt>
<dd>
<div class="desc"><p>Formal charge on this Compound.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def charge(self):
    &#34;&#34;&#34;Formal charge on this Compound.&#34;&#34;&#34;
    return self.record[&#39;charge&#39;] if &#39;charge&#39; in self.record else 0</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.cid"><code class="name">var <span class="ident">cid</span></code></dt>
<dd>
<div class="desc"><p>The PubChem Compound Identifier (CID).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When searching using a SMILES or InChI query that is not present in the PubChem Compound database, an
automatically generated record may be returned that contains properties that have been calculated on the
fly. These records will not have a CID property.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cid(self):
    &#34;&#34;&#34;The PubChem Compound Identifier (CID).

    .. note::

        When searching using a SMILES or InChI query that is not present in the PubChem Compound database, an
        automatically generated record may be returned that contains properties that have been calculated on the
        fly. These records will not have a CID property.
    &#34;&#34;&#34;
    if &#39;id&#39; in self.record and &#39;id&#39; in self.record[&#39;id&#39;] and &#39;cid&#39; in self.record[&#39;id&#39;][&#39;id&#39;]:
        return self.record[&#39;id&#39;][&#39;id&#39;][&#39;cid&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.complexity"><code class="name">var <span class="ident">complexity</span></code></dt>
<dd>
<div class="desc"><p>Complexity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def complexity(self):
    &#34;&#34;&#34;Complexity.&#34;&#34;&#34;
    return _parse_prop({&#39;implementation&#39;: &#39;E_COMPLEXITY&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.conformer_id_3d"><code class="name">var <span class="ident">conformer_id_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def conformer_id_3d(self):
    conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
    if &#39;data&#39; in conf:
        return _parse_prop({&#39;label&#39;: &#39;Conformer&#39;, &#39;name&#39;: &#39;ID&#39;}, conf[&#39;data&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.conformer_rmsd_3d"><code class="name">var <span class="ident">conformer_rmsd_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def conformer_rmsd_3d(self):
    coords = self.record[&#39;coords&#39;][0]
    if &#39;data&#39; in coords:
        return _parse_prop({&#39;label&#39;: &#39;Conformer&#39;, &#39;name&#39;: &#39;RMSD&#39;}, coords[&#39;data&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.coordinate_type"><code class="name">var <span class="ident">coordinate_type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coordinate_type(self):
    if CoordinateType.TWO_D in self.record[&#39;coords&#39;][0][&#39;type&#39;]:
        return &#39;2d&#39;
    elif CoordinateType.THREE_D in self.record[&#39;coords&#39;][0][&#39;type&#39;]:
        return &#39;3d&#39;</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.covalent_unit_count"><code class="name">var <span class="ident">covalent_unit_count</span></code></dt>
<dd>
<div class="desc"><p>Covalently-bonded unit count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def covalent_unit_count(self):
    &#34;&#34;&#34;Covalently-bonded unit count.&#34;&#34;&#34;
    if &#39;count&#39; in self.record and &#39;covalent_unit&#39; in self.record[&#39;count&#39;]:
        return self.record[&#39;count&#39;][&#39;covalent_unit&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.defined_atom_stereo_count"><code class="name">var <span class="ident">defined_atom_stereo_count</span></code></dt>
<dd>
<div class="desc"><p>Defined atom stereocenter count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def defined_atom_stereo_count(self):
    &#34;&#34;&#34;Defined atom stereocenter count.&#34;&#34;&#34;
    if &#39;count&#39; in self.record and &#39;atom_chiral_def&#39; in self.record[&#39;count&#39;]:
        return self.record[&#39;count&#39;][&#39;atom_chiral_def&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.defined_bond_stereo_count"><code class="name">var <span class="ident">defined_bond_stereo_count</span></code></dt>
<dd>
<div class="desc"><p>Defined bond stereocenter count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def defined_bond_stereo_count(self):
    &#34;&#34;&#34;Defined bond stereocenter count.&#34;&#34;&#34;
    if &#39;count&#39; in self.record and &#39;bond_chiral_def&#39; in self.record[&#39;count&#39;]:
        return self.record[&#39;count&#39;][&#39;bond_chiral_def&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.effective_rotor_count_3d"><code class="name">var <span class="ident">effective_rotor_count_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def effective_rotor_count_3d(self):
    return _parse_prop({&#39;label&#39;: &#39;Count&#39;, &#39;name&#39;: &#39;Effective Rotor&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.elements"><code class="name">var <span class="ident">elements</span></code></dt>
<dd>
<div class="desc"><p>List of element symbols for atoms in this Compound.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def elements(self):
    &#34;&#34;&#34;List of element symbols for atoms in this Compound.&#34;&#34;&#34;
    return [a.element for a in self.atoms]</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.exact_mass"><code class="name">var <span class="ident">exact_mass</span></code></dt>
<dd>
<div class="desc"><p>Exact mass.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exact_mass(self):
    &#34;&#34;&#34;Exact mass.&#34;&#34;&#34;
    return _parse_prop({&#39;label&#39;: &#39;Mass&#39;, &#39;name&#39;: &#39;Exact&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.feature_selfoverlap_3d"><code class="name">var <span class="ident">feature_selfoverlap_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def feature_selfoverlap_3d(self):
    conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
    if &#39;data&#39; in conf:
        return _parse_prop({&#39;label&#39;: &#39;Feature&#39;, &#39;name&#39;: &#39;Self Overlap&#39;}, conf[&#39;data&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.fingerprint"><code class="name">var <span class="ident">fingerprint</span></code></dt>
<dd>
<div class="desc"><p>Raw padded and hex-encoded fingerprint, as returned by the PUG REST API.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fingerprint(self):
    &#34;&#34;&#34;Raw padded and hex-encoded fingerprint, as returned by the PUG REST API.&#34;&#34;&#34;
    return _parse_prop({&#39;implementation&#39;: &#39;E_SCREEN&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.h_bond_acceptor_count"><code class="name">var <span class="ident">h_bond_acceptor_count</span></code></dt>
<dd>
<div class="desc"><p>Hydrogen bond acceptor count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def h_bond_acceptor_count(self):
    &#34;&#34;&#34;Hydrogen bond acceptor count.&#34;&#34;&#34;
    return _parse_prop({&#39;implementation&#39;: &#39;E_NHACCEPTORS&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.h_bond_donor_count"><code class="name">var <span class="ident">h_bond_donor_count</span></code></dt>
<dd>
<div class="desc"><p>Hydrogen bond donor count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def h_bond_donor_count(self):
    &#34;&#34;&#34;Hydrogen bond donor count.&#34;&#34;&#34;
    return _parse_prop({&#39;implementation&#39;: &#39;E_NHDONORS&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.heavy_atom_count"><code class="name">var <span class="ident">heavy_atom_count</span></code></dt>
<dd>
<div class="desc"><p>Heavy atom count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def heavy_atom_count(self):
    &#34;&#34;&#34;Heavy atom count.&#34;&#34;&#34;
    if &#39;count&#39; in self.record and &#39;heavy_atom&#39; in self.record[&#39;count&#39;]:
        return self.record[&#39;count&#39;][&#39;heavy_atom&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.inchi"><code class="name">var <span class="ident">inchi</span></code></dt>
<dd>
<div class="desc"><p>InChI string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inchi(self):
    &#34;&#34;&#34;InChI string.&#34;&#34;&#34;
    return _parse_prop({&#39;label&#39;: &#39;InChI&#39;, &#39;name&#39;: &#39;Standard&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.inchikey"><code class="name">var <span class="ident">inchikey</span></code></dt>
<dd>
<div class="desc"><p>InChIKey.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inchikey(self):
    &#34;&#34;&#34;InChIKey.&#34;&#34;&#34;
    return _parse_prop({&#39;label&#39;: &#39;InChIKey&#39;, &#39;name&#39;: &#39;Standard&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.isomeric_smiles"><code class="name">var <span class="ident">isomeric_smiles</span></code></dt>
<dd>
<div class="desc"><p>Isomeric SMILES.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isomeric_smiles(self):
    &#34;&#34;&#34;Isomeric SMILES.&#34;&#34;&#34;
    return _parse_prop({&#39;label&#39;: &#39;SMILES&#39;, &#39;name&#39;: &#39;Isomeric&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.isotope_atom_count"><code class="name">var <span class="ident">isotope_atom_count</span></code></dt>
<dd>
<div class="desc"><p>Isotope atom count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isotope_atom_count(self):
    &#34;&#34;&#34;Isotope atom count.&#34;&#34;&#34;
    if &#39;count&#39; in self.record and &#39;isotope_atom&#39; in self.record[&#39;count&#39;]:
        return self.record[&#39;count&#39;][&#39;isotope_atom&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.iupac_name"><code class="name">var <span class="ident">iupac_name</span></code></dt>
<dd>
<div class="desc"><p>Preferred IUPAC name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def iupac_name(self):
    &#34;&#34;&#34;Preferred IUPAC name.&#34;&#34;&#34;
    # Note: Allowed, CAS-like Style, Preferred, Systematic, Traditional are available in full record
    return _parse_prop({&#39;label&#39;: &#39;IUPAC Name&#39;, &#39;name&#39;: &#39;Preferred&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.mmff94_energy_3d"><code class="name">var <span class="ident">mmff94_energy_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mmff94_energy_3d(self):
    conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
    if &#39;data&#39; in conf:
        return _parse_prop({&#39;label&#39;: &#39;Energy&#39;, &#39;name&#39;: &#39;MMFF94 NoEstat&#39;}, conf[&#39;data&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.mmff94_partial_charges_3d"><code class="name">var <span class="ident">mmff94_partial_charges_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mmff94_partial_charges_3d(self):
    return _parse_prop({&#39;label&#39;: &#39;Charge&#39;, &#39;name&#39;: &#39;MMFF94 Partial&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.molecular_formula"><code class="name">var <span class="ident">molecular_formula</span></code></dt>
<dd>
<div class="desc"><p>Molecular formula.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def molecular_formula(self):
    &#34;&#34;&#34;Molecular formula.&#34;&#34;&#34;
    return _parse_prop({&#39;label&#39;: &#39;Molecular Formula&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.molecular_weight"><code class="name">var <span class="ident">molecular_weight</span></code></dt>
<dd>
<div class="desc"><p>Molecular Weight.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def molecular_weight(self):
    &#34;&#34;&#34;Molecular Weight.&#34;&#34;&#34;
    return _parse_prop({&#39;label&#39;: &#39;Molecular Weight&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.monoisotopic_mass"><code class="name">var <span class="ident">monoisotopic_mass</span></code></dt>
<dd>
<div class="desc"><p>Monoisotopic mass.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def monoisotopic_mass(self):
    &#34;&#34;&#34;Monoisotopic mass.&#34;&#34;&#34;
    return _parse_prop({&#39;label&#39;: &#39;Weight&#39;, &#39;name&#39;: &#39;MonoIsotopic&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.multipoles_3d"><code class="name">var <span class="ident">multipoles_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def multipoles_3d(self):
    conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
    if &#39;data&#39; in conf:
        return _parse_prop({&#39;label&#39;: &#39;Shape&#39;, &#39;name&#39;: &#39;Multipoles&#39;}, conf[&#39;data&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.pharmacophore_features_3d"><code class="name">var <span class="ident">pharmacophore_features_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pharmacophore_features_3d(self):
    return _parse_prop({&#39;label&#39;: &#39;Features&#39;, &#39;name&#39;: &#39;Pharmacophore&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.record"><code class="name">var <span class="ident">record</span></code></dt>
<dd>
<div class="desc"><p>The raw compound record returned by the PubChem PUG REST service.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def record(self):
    &#34;&#34;&#34;The raw compound record returned by the PubChem PUG REST service.&#34;&#34;&#34;
    return self._record</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.rotatable_bond_count"><code class="name">var <span class="ident">rotatable_bond_count</span></code></dt>
<dd>
<div class="desc"><p>Rotatable bond count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rotatable_bond_count(self):
    &#34;&#34;&#34;Rotatable bond count.&#34;&#34;&#34;
    return _parse_prop({&#39;implementation&#39;: &#39;E_NROTBONDS&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.shape_fingerprint_3d"><code class="name">var <span class="ident">shape_fingerprint_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape_fingerprint_3d(self):
    conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
    if &#39;data&#39; in conf:
        return _parse_prop({&#39;label&#39;: &#39;Fingerprint&#39;, &#39;name&#39;: &#39;Shape&#39;}, conf[&#39;data&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.shape_selfoverlap_3d"><code class="name">var <span class="ident">shape_selfoverlap_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape_selfoverlap_3d(self):
    conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
    if &#39;data&#39; in conf:
        return _parse_prop({&#39;label&#39;: &#39;Shape&#39;, &#39;name&#39;: &#39;Self Overlap&#39;}, conf[&#39;data&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.sids"><code class="name">var <span class="ident">sids</span></code></dt>
<dd>
<div class="desc"><p>Requires an extra request. Result is cached.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@memoized_property
def sids(self):
    &#34;&#34;&#34;Requires an extra request. Result is cached.&#34;&#34;&#34;
    if self.cid:
        results = get_json(self.cid, operation=&#39;sids&#39;)
        return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;SID&#39;] if results else []</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.synonyms"><code class="name">var <span class="ident">synonyms</span></code></dt>
<dd>
<div class="desc"><p>A ranked list of all the names associated with this Compound.</p>
<p>Requires an extra request. Result is cached.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@memoized_property
def synonyms(self):
    &#34;&#34;&#34;A ranked list of all the names associated with this Compound.

    Requires an extra request. Result is cached.
    &#34;&#34;&#34;
    if self.cid:
        results = get_json(self.cid, operation=&#39;synonyms&#39;)
        return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;Synonym&#39;] if results else []</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.tpsa"><code class="name">var <span class="ident">tpsa</span></code></dt>
<dd>
<div class="desc"><p>Topological Polar Surface Area.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tpsa(self):
    &#34;&#34;&#34;Topological Polar Surface Area.&#34;&#34;&#34;
    return _parse_prop({&#39;implementation&#39;: &#39;E_TPSA&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.undefined_atom_stereo_count"><code class="name">var <span class="ident">undefined_atom_stereo_count</span></code></dt>
<dd>
<div class="desc"><p>Undefined atom stereocenter count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def undefined_atom_stereo_count(self):
    &#34;&#34;&#34;Undefined atom stereocenter count.&#34;&#34;&#34;
    if &#39;count&#39; in self.record and &#39;atom_chiral_undef&#39; in self.record[&#39;count&#39;]:
        return self.record[&#39;count&#39;][&#39;atom_chiral_undef&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.undefined_bond_stereo_count"><code class="name">var <span class="ident">undefined_bond_stereo_count</span></code></dt>
<dd>
<div class="desc"><p>Undefined bond stereocenter count.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def undefined_bond_stereo_count(self):
    &#34;&#34;&#34;Undefined bond stereocenter count.&#34;&#34;&#34;
    if &#39;count&#39; in self.record and &#39;bond_chiral_undef&#39; in self.record[&#39;count&#39;]:
        return self.record[&#39;count&#39;][&#39;bond_chiral_undef&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.volume_3d"><code class="name">var <span class="ident">volume_3d</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume_3d(self):
    conf = self.record[&#39;coords&#39;][0][&#39;conformers&#39;][0]
    if &#39;data&#39; in conf:
        return _parse_prop({&#39;label&#39;: &#39;Shape&#39;, &#39;name&#39;: &#39;Volume&#39;}, conf[&#39;data&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.xlogp"><code class="name">var <span class="ident">xlogp</span></code></dt>
<dd>
<div class="desc"><p>XLogP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xlogp(self):
    &#34;&#34;&#34;XLogP.&#34;&#34;&#34;
    return _parse_prop({&#39;label&#39;: &#39;Log P&#39;}, self.record[&#39;props&#39;])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pubchempy.Compound.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, properties=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary containing Compound data. Optionally specify a list of the desired properties.</p>
<p>synonyms, aids and sids are not included unless explicitly specified using the properties parameter. This is
because they each require an extra request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, properties=None):
    &#34;&#34;&#34;Return a dictionary containing Compound data. Optionally specify a list of the desired properties.

    synonyms, aids and sids are not included unless explicitly specified using the properties parameter. This is
    because they each require an extra request.
    &#34;&#34;&#34;
    if not properties:
        skip = {&#39;aids&#39;, &#39;sids&#39;, &#39;synonyms&#39;}
        properties = [p for p in dir(Compound) if isinstance(getattr(Compound, p), property) and p not in skip]
    return {p: [i.to_dict() for i in getattr(self, p)] if p in {&#39;atoms&#39;, &#39;bonds&#39;} else getattr(self, p) for p in properties}</code></pre>
</details>
</dd>
<dt id="pubchempy.Compound.to_series"><code class="name flex">
<span>def <span class="ident">to_series</span></span>(<span>self, properties=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a pandas :class:<code>~pandas.Series</code> containing Compound data. Optionally specify a list of the desired
properties.</p>
<p>synonyms, aids and sids are not included unless explicitly specified using the properties parameter. This is
because they each require an extra request.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_series(self, properties=None):
    &#34;&#34;&#34;Return a pandas :class:`~pandas.Series` containing Compound data. Optionally specify a list of the desired
    properties.

    synonyms, aids and sids are not included unless explicitly specified using the properties parameter. This is
    because they each require an extra request.
    &#34;&#34;&#34;
    import pandas as pd
    return pd.Series(self.to_dict(properties))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pubchempy.CompoundIdType"><code class="flex name class">
<span>class <span class="ident">CompoundIdType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompoundIdType(object):
    &#34;&#34;&#34;&#34;&#34;&#34;
    #: Original Deposited Compound
    DEPOSITED = 0
    #: Standardized Form of the Deposited Compound
    STANDARDIZED = 1
    #: Component of the Standardized Form
    COMPONENT = 2
    #: Neutralized Form of the Standardized Form
    NEUTRALIZED = 3
    #: Deposited Mixture Component
    MIXTURE = 4
    #: Alternate Tautomer Form of the Standardized Form
    TAUTOMER = 5
    #: Ionized pKa Form of the Standardized Form
    IONIZED = 6
    #: Unspecified or Unknown Compound Type
    UNKNOWN = 255</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pubchempy.CompoundIdType.COMPONENT"><code class="name">var <span class="ident">COMPONENT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CompoundIdType.DEPOSITED"><code class="name">var <span class="ident">DEPOSITED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CompoundIdType.IONIZED"><code class="name">var <span class="ident">IONIZED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CompoundIdType.MIXTURE"><code class="name">var <span class="ident">MIXTURE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CompoundIdType.NEUTRALIZED"><code class="name">var <span class="ident">NEUTRALIZED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CompoundIdType.STANDARDIZED"><code class="name">var <span class="ident">STANDARDIZED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CompoundIdType.TAUTOMER"><code class="name">var <span class="ident">TAUTOMER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CompoundIdType.UNKNOWN"><code class="name">var <span class="ident">UNKNOWN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pubchempy.CoordinateType"><code class="flex name class">
<span>class <span class="ident">CoordinateType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CoordinateType(object):
    TWO_D = 1
    THREE_D = 2
    SUBMITTED = 3
    EXPERIMENTAL = 4
    COMPUTED = 5
    STANDARDIZED = 6
    AUGMENTED = 7
    ALIGNED = 8
    COMPACT = 9
    UNITS_ANGSTROMS = 10
    UNITS_NANOMETERS = 11
    UNITS_PIXEL = 12
    UNITS_POINTS = 13
    UNITS_STDBONDS = 14
    UNITS_UNKNOWN = 255</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pubchempy.CoordinateType.ALIGNED"><code class="name">var <span class="ident">ALIGNED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.AUGMENTED"><code class="name">var <span class="ident">AUGMENTED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.COMPACT"><code class="name">var <span class="ident">COMPACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.COMPUTED"><code class="name">var <span class="ident">COMPUTED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.EXPERIMENTAL"><code class="name">var <span class="ident">EXPERIMENTAL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.STANDARDIZED"><code class="name">var <span class="ident">STANDARDIZED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.SUBMITTED"><code class="name">var <span class="ident">SUBMITTED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.THREE_D"><code class="name">var <span class="ident">THREE_D</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.TWO_D"><code class="name">var <span class="ident">TWO_D</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.UNITS_ANGSTROMS"><code class="name">var <span class="ident">UNITS_ANGSTROMS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.UNITS_NANOMETERS"><code class="name">var <span class="ident">UNITS_NANOMETERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.UNITS_PIXEL"><code class="name">var <span class="ident">UNITS_PIXEL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.UNITS_POINTS"><code class="name">var <span class="ident">UNITS_POINTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.UNITS_STDBONDS"><code class="name">var <span class="ident">UNITS_STDBONDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.CoordinateType.UNITS_UNKNOWN"><code class="name">var <span class="ident">UNITS_UNKNOWN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pubchempy.MethodNotAllowedError"><code class="flex name class">
<span>class <span class="ident">MethodNotAllowedError</span></span>
<span>(</span><span>msg='Request not allowed')</span>
</code></dt>
<dd>
<div class="desc"><p>Request not allowed (such as invalid MIME type in the HTTP Accept header).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MethodNotAllowedError(PubChemHTTPError):
    &#34;&#34;&#34;Request not allowed (such as invalid MIME type in the HTTP Accept header).&#34;&#34;&#34;
    def __init__(self, msg=&#39;Request not allowed&#39;):
        self.msg = msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pubchempy.PubChemHTTPError" href="#pubchempy.PubChemHTTPError">PubChemHTTPError</a></li>
<li><a title="pubchempy.PubChemPyError" href="#pubchempy.PubChemPyError">PubChemPyError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pubchempy.NotFoundError"><code class="flex name class">
<span>class <span class="ident">NotFoundError</span></span>
<span>(</span><span>msg='The input record was not found')</span>
</code></dt>
<dd>
<div class="desc"><p>The input record was not found (e.g. invalid CID).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotFoundError(PubChemHTTPError):
    &#34;&#34;&#34;The input record was not found (e.g. invalid CID).&#34;&#34;&#34;
    def __init__(self, msg=&#39;The input record was not found&#39;):
        self.msg = msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pubchempy.PubChemHTTPError" href="#pubchempy.PubChemHTTPError">PubChemHTTPError</a></li>
<li><a title="pubchempy.PubChemPyError" href="#pubchempy.PubChemPyError">PubChemPyError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pubchempy.ProjectCategory"><code class="flex name class">
<span>class <span class="ident">ProjectCategory</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProjectCategory(object):
    MLSCN = 1
    MPLCN = 2
    MLSCN_AP = 3
    MPLCN_AP = 4
    JOURNAL_ARTICLE = 5
    ASSAY_VENDOR = 6
    LITERATURE_EXTRACTED = 7
    LITERATURE_AUTHOR = 8
    LITERATURE_PUBLISHER = 9
    RNAIGI = 10
    OTHER = 255</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pubchempy.ProjectCategory.ASSAY_VENDOR"><code class="name">var <span class="ident">ASSAY_VENDOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.ProjectCategory.JOURNAL_ARTICLE"><code class="name">var <span class="ident">JOURNAL_ARTICLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.ProjectCategory.LITERATURE_AUTHOR"><code class="name">var <span class="ident">LITERATURE_AUTHOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.ProjectCategory.LITERATURE_EXTRACTED"><code class="name">var <span class="ident">LITERATURE_EXTRACTED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.ProjectCategory.LITERATURE_PUBLISHER"><code class="name">var <span class="ident">LITERATURE_PUBLISHER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.ProjectCategory.MLSCN"><code class="name">var <span class="ident">MLSCN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.ProjectCategory.MLSCN_AP"><code class="name">var <span class="ident">MLSCN_AP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.ProjectCategory.MPLCN"><code class="name">var <span class="ident">MPLCN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.ProjectCategory.MPLCN_AP"><code class="name">var <span class="ident">MPLCN_AP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.ProjectCategory.OTHER"><code class="name">var <span class="ident">OTHER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pubchempy.ProjectCategory.RNAIGI"><code class="name">var <span class="ident">RNAIGI</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pubchempy.PubChemHTTPError"><code class="flex name class">
<span>class <span class="ident">PubChemHTTPError</span></span>
<span>(</span><span>e)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic error class to handle all HTTP error codes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PubChemHTTPError(PubChemPyError):
    &#34;&#34;&#34;Generic error class to handle all HTTP error codes.&#34;&#34;&#34;
    def __init__(self, e):
        self.code = e.code
        self.msg = e.reason
        try:
            self.msg += &#39;: %s&#39; % json.loads(e.read().decode())[&#39;Fault&#39;][&#39;Details&#39;][0]
        except (ValueError, IndexError, KeyError):
            pass
        if self.code == 400:
            raise BadRequestError(self.msg)
        elif self.code == 404:
            raise NotFoundError(self.msg)
        elif self.code == 405:
            raise MethodNotAllowedError(self.msg)
        elif self.code == 504:
            raise TimeoutError(self.msg)
        elif self.code == 501:
            raise UnimplementedError(self.msg)
        elif self.code == 500:
            raise ServerError(self.msg)

    def __str__(self):
        return repr(self.msg)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pubchempy.PubChemPyError" href="#pubchempy.PubChemPyError">PubChemPyError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pubchempy.BadRequestError" href="#pubchempy.BadRequestError">BadRequestError</a></li>
<li><a title="pubchempy.MethodNotAllowedError" href="#pubchempy.MethodNotAllowedError">MethodNotAllowedError</a></li>
<li><a title="pubchempy.NotFoundError" href="#pubchempy.NotFoundError">NotFoundError</a></li>
<li><a title="pubchempy.ServerError" href="#pubchempy.ServerError">ServerError</a></li>
<li><a title="pubchempy.TimeoutError" href="#pubchempy.TimeoutError">TimeoutError</a></li>
<li><a title="pubchempy.UnimplementedError" href="#pubchempy.UnimplementedError">UnimplementedError</a></li>
</ul>
</dd>
<dt id="pubchempy.PubChemPyDeprecationWarning"><code class="flex name class">
<span>class <span class="ident">PubChemPyDeprecationWarning</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Warning category for deprecated features.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PubChemPyDeprecationWarning(Warning):
    &#34;&#34;&#34;Warning category for deprecated features.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Warning</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pubchempy.PubChemPyError"><code class="flex name class">
<span>class <span class="ident">PubChemPyError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all PubChemPy exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PubChemPyError(Exception):
    &#34;&#34;&#34;Base class for all PubChemPy exceptions.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pubchempy.PubChemHTTPError" href="#pubchempy.PubChemHTTPError">PubChemHTTPError</a></li>
<li><a title="pubchempy.ResponseParseError" href="#pubchempy.ResponseParseError">ResponseParseError</a></li>
</ul>
</dd>
<dt id="pubchempy.ResponseParseError"><code class="flex name class">
<span>class <span class="ident">ResponseParseError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>PubChem response is uninterpretable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResponseParseError(PubChemPyError):
    &#34;&#34;&#34;PubChem response is uninterpretable.&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pubchempy.PubChemPyError" href="#pubchempy.PubChemPyError">PubChemPyError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pubchempy.ServerError"><code class="flex name class">
<span>class <span class="ident">ServerError</span></span>
<span>(</span><span>msg='Some problem on the server side')</span>
</code></dt>
<dd>
<div class="desc"><p>Some problem on the server side (such as a database server down, etc.).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ServerError(PubChemHTTPError):
    &#34;&#34;&#34;Some problem on the server side (such as a database server down, etc.).&#34;&#34;&#34;
    def __init__(self, msg=&#39;Some problem on the server side&#39;):
        self.msg = msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pubchempy.PubChemHTTPError" href="#pubchempy.PubChemHTTPError">PubChemHTTPError</a></li>
<li><a title="pubchempy.PubChemPyError" href="#pubchempy.PubChemPyError">PubChemPyError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pubchempy.Substance"><code class="flex name class">
<span>class <span class="ident">Substance</span></span>
<span>(</span><span>record)</span>
</code></dt>
<dd>
<div class="desc"><p>Corresponds to a single record from the PubChem Substance database.</p>
<p>The PubChem Substance database contains all chemical records deposited in PubChem in their most raw form, before
any significant processing is applied. As a result, it contains duplicates, mixtures, and some records that don't
make chemical sense. This means that Substance records contain fewer calculated properties, however they do have
additional information about the original source that deposited the record.</p>
<p>The PubChem Compound database is constructed from the Substance database using a standardization and deduplication
process. Hence each Compound may be derived from a number of different Substances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Substance(object):
    &#34;&#34;&#34;Corresponds to a single record from the PubChem Substance database.

    The PubChem Substance database contains all chemical records deposited in PubChem in their most raw form, before
    any significant processing is applied. As a result, it contains duplicates, mixtures, and some records that don&#39;t
    make chemical sense. This means that Substance records contain fewer calculated properties, however they do have
    additional information about the original source that deposited the record.

    The PubChem Compound database is constructed from the Substance database using a standardization and deduplication
    process. Hence each Compound may be derived from a number of different Substances.
    &#34;&#34;&#34;

    @classmethod
    def from_sid(cls, sid):
        &#34;&#34;&#34;Retrieve the Substance record for the specified SID.

        :param int sid: The PubChem Substance Identifier (SID).
        &#34;&#34;&#34;
        record = json.loads(request(sid, &#39;sid&#39;, &#39;substance&#39;).read().decode())[&#39;PC_Substances&#39;][0]
        return cls(record)

    def __init__(self, record):
        self.record = record
        &#34;&#34;&#34;A dictionary containing the full Substance record that all other properties are obtained from.&#34;&#34;&#34;

    def __repr__(self):
        return &#39;Substance(%s)&#39; % self.sid if self.sid else &#39;Substance()&#39;

    def __eq__(self, other):
        return isinstance(other, type(self)) and self.record == other.record

    def to_dict(self, properties=None):
        &#34;&#34;&#34;Return a dictionary containing Substance data.

        If the properties parameter is not specified, everything except cids and aids is included. This is because the
        aids and cids properties each require an extra request to retrieve.

        :param properties: (optional) A list of the desired properties.
        &#34;&#34;&#34;
        if not properties:
            skip = {&#39;deposited_compound&#39;, &#39;standardized_compound&#39;, &#39;cids&#39;, &#39;aids&#39;}
            properties = [p for p in dir(Substance) if isinstance(getattr(Substance, p), property) and p not in skip]
        return {p: getattr(self, p) for p in properties}

    def to_series(self, properties=None):
        &#34;&#34;&#34;Return a pandas :class:`~pandas.Series` containing Substance data.

        If the properties parameter is not specified, everything except cids and aids is included. This is because the
        aids and cids properties each require an extra request to retrieve.

        :param properties: (optional) A list of the desired properties.
        &#34;&#34;&#34;
        import pandas as pd
        return pd.Series(self.to_dict(properties))

    @property
    def sid(self):
        &#34;&#34;&#34;The PubChem Substance Idenfitier (SID).&#34;&#34;&#34;
        return self.record[&#39;sid&#39;][&#39;id&#39;]

    @property
    def synonyms(self):
        &#34;&#34;&#34;A ranked list of all the names associated with this Substance.&#34;&#34;&#34;
        if &#39;synonyms&#39; in self.record:
            return self.record[&#39;synonyms&#39;]

    @property
    def source_name(self):
        &#34;&#34;&#34;The name of the PubChem depositor that was the source of this Substance.&#34;&#34;&#34;
        return self.record[&#39;source&#39;][&#39;db&#39;][&#39;name&#39;]

    @property
    def source_id(self):
        &#34;&#34;&#34;Unique ID for this Substance within those from the same PubChem depositor source.&#34;&#34;&#34;
        return self.record[&#39;source&#39;][&#39;db&#39;][&#39;source_id&#39;][&#39;str&#39;]

    @property
    def standardized_cid(self):
        &#34;&#34;&#34;The CID of the Compound that was produced when this Substance was standardized.

        May not exist if this Substance was not standardizable.
        &#34;&#34;&#34;
        for c in self.record[&#39;compound&#39;]:
            if c[&#39;id&#39;][&#39;type&#39;] == CompoundIdType.STANDARDIZED:
                return c[&#39;id&#39;][&#39;id&#39;][&#39;cid&#39;]

    @memoized_property
    def standardized_compound(self):
        &#34;&#34;&#34;Return the :class:`~pubchempy.Compound` that was produced when this Substance was standardized.

        Requires an extra request. Result is cached.
        &#34;&#34;&#34;
        for c in self.record[&#39;compound&#39;]:
            if c[&#39;id&#39;][&#39;type&#39;] == CompoundIdType.STANDARDIZED:
                return Compound.from_cid(c[&#39;id&#39;][&#39;id&#39;][&#39;cid&#39;])

    @property
    def deposited_compound(self):
        &#34;&#34;&#34;Return a :class:`~pubchempy.Compound` produced from the unstandardized Substance record as deposited.

        The resulting :class:`~pubchempy.Compound` will not have a ``cid`` and will be missing most properties.
        &#34;&#34;&#34;
        for c in self.record[&#39;compound&#39;]:
            if c[&#39;id&#39;][&#39;type&#39;] == CompoundIdType.DEPOSITED:
                return Compound(c)

    @memoized_property
    def cids(self):
        &#34;&#34;&#34;A list of all CIDs for Compounds that were produced when this Substance was standardized.

        Requires an extra request. Result is cached.&#34;&#34;&#34;
        results = get_json(self.sid, &#39;sid&#39;, &#39;substance&#39;, &#39;cids&#39;)
        return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;CID&#39;] if results else []

    @memoized_property
    def aids(self):
        &#34;&#34;&#34;A list of all AIDs for Assays associated with this Substance.

        Requires an extra request. Result is cached.&#34;&#34;&#34;
        results = get_json(self.sid, &#39;sid&#39;, &#39;substance&#39;, &#39;aids&#39;)
        return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;AID&#39;] if results else []</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pubchempy.Substance.from_sid"><code class="name flex">
<span>def <span class="ident">from_sid</span></span>(<span>sid)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the Substance record for the specified SID.</p>
<p>:param int sid: The PubChem Substance Identifier (SID).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_sid(cls, sid):
    &#34;&#34;&#34;Retrieve the Substance record for the specified SID.

    :param int sid: The PubChem Substance Identifier (SID).
    &#34;&#34;&#34;
    record = json.loads(request(sid, &#39;sid&#39;, &#39;substance&#39;).read().decode())[&#39;PC_Substances&#39;][0]
    return cls(record)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pubchempy.Substance.aids"><code class="name">var <span class="ident">aids</span></code></dt>
<dd>
<div class="desc"><p>A list of all AIDs for Assays associated with this Substance.</p>
<p>Requires an extra request. Result is cached.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@memoized_property
def aids(self):
    &#34;&#34;&#34;A list of all AIDs for Assays associated with this Substance.

    Requires an extra request. Result is cached.&#34;&#34;&#34;
    results = get_json(self.sid, &#39;sid&#39;, &#39;substance&#39;, &#39;aids&#39;)
    return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;AID&#39;] if results else []</code></pre>
</details>
</dd>
<dt id="pubchempy.Substance.cids"><code class="name">var <span class="ident">cids</span></code></dt>
<dd>
<div class="desc"><p>A list of all CIDs for Compounds that were produced when this Substance was standardized.</p>
<p>Requires an extra request. Result is cached.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@memoized_property
def cids(self):
    &#34;&#34;&#34;A list of all CIDs for Compounds that were produced when this Substance was standardized.

    Requires an extra request. Result is cached.&#34;&#34;&#34;
    results = get_json(self.sid, &#39;sid&#39;, &#39;substance&#39;, &#39;cids&#39;)
    return results[&#39;InformationList&#39;][&#39;Information&#39;][0][&#39;CID&#39;] if results else []</code></pre>
</details>
</dd>
<dt id="pubchempy.Substance.deposited_compound"><code class="name">var <span class="ident">deposited_compound</span></code></dt>
<dd>
<div class="desc"><p>Return a :class:<code>~pubchempy.Compound</code> produced from the unstandardized Substance record as deposited.</p>
<p>The resulting :class:<code>~pubchempy.Compound</code> will not have a <code>cid</code> and will be missing most properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def deposited_compound(self):
    &#34;&#34;&#34;Return a :class:`~pubchempy.Compound` produced from the unstandardized Substance record as deposited.

    The resulting :class:`~pubchempy.Compound` will not have a ``cid`` and will be missing most properties.
    &#34;&#34;&#34;
    for c in self.record[&#39;compound&#39;]:
        if c[&#39;id&#39;][&#39;type&#39;] == CompoundIdType.DEPOSITED:
            return Compound(c)</code></pre>
</details>
</dd>
<dt id="pubchempy.Substance.record"><code class="name">var <span class="ident">record</span></code></dt>
<dd>
<div class="desc"><p>A dictionary containing the full Substance record that all other properties are obtained from.</p></div>
</dd>
<dt id="pubchempy.Substance.sid"><code class="name">var <span class="ident">sid</span></code></dt>
<dd>
<div class="desc"><p>The PubChem Substance Idenfitier (SID).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sid(self):
    &#34;&#34;&#34;The PubChem Substance Idenfitier (SID).&#34;&#34;&#34;
    return self.record[&#39;sid&#39;][&#39;id&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Substance.source_id"><code class="name">var <span class="ident">source_id</span></code></dt>
<dd>
<div class="desc"><p>Unique ID for this Substance within those from the same PubChem depositor source.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def source_id(self):
    &#34;&#34;&#34;Unique ID for this Substance within those from the same PubChem depositor source.&#34;&#34;&#34;
    return self.record[&#39;source&#39;][&#39;db&#39;][&#39;source_id&#39;][&#39;str&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Substance.source_name"><code class="name">var <span class="ident">source_name</span></code></dt>
<dd>
<div class="desc"><p>The name of the PubChem depositor that was the source of this Substance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def source_name(self):
    &#34;&#34;&#34;The name of the PubChem depositor that was the source of this Substance.&#34;&#34;&#34;
    return self.record[&#39;source&#39;][&#39;db&#39;][&#39;name&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Substance.standardized_cid"><code class="name">var <span class="ident">standardized_cid</span></code></dt>
<dd>
<div class="desc"><p>The CID of the Compound that was produced when this Substance was standardized.</p>
<p>May not exist if this Substance was not standardizable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def standardized_cid(self):
    &#34;&#34;&#34;The CID of the Compound that was produced when this Substance was standardized.

    May not exist if this Substance was not standardizable.
    &#34;&#34;&#34;
    for c in self.record[&#39;compound&#39;]:
        if c[&#39;id&#39;][&#39;type&#39;] == CompoundIdType.STANDARDIZED:
            return c[&#39;id&#39;][&#39;id&#39;][&#39;cid&#39;]</code></pre>
</details>
</dd>
<dt id="pubchempy.Substance.standardized_compound"><code class="name">var <span class="ident">standardized_compound</span></code></dt>
<dd>
<div class="desc"><p>Return the :class:<code>~pubchempy.Compound</code> that was produced when this Substance was standardized.</p>
<p>Requires an extra request. Result is cached.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@memoized_property
def standardized_compound(self):
    &#34;&#34;&#34;Return the :class:`~pubchempy.Compound` that was produced when this Substance was standardized.

    Requires an extra request. Result is cached.
    &#34;&#34;&#34;
    for c in self.record[&#39;compound&#39;]:
        if c[&#39;id&#39;][&#39;type&#39;] == CompoundIdType.STANDARDIZED:
            return Compound.from_cid(c[&#39;id&#39;][&#39;id&#39;][&#39;cid&#39;])</code></pre>
</details>
</dd>
<dt id="pubchempy.Substance.synonyms"><code class="name">var <span class="ident">synonyms</span></code></dt>
<dd>
<div class="desc"><p>A ranked list of all the names associated with this Substance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def synonyms(self):
    &#34;&#34;&#34;A ranked list of all the names associated with this Substance.&#34;&#34;&#34;
    if &#39;synonyms&#39; in self.record:
        return self.record[&#39;synonyms&#39;]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pubchempy.Substance.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, properties=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary containing Substance data.</p>
<p>If the properties parameter is not specified, everything except cids and aids is included. This is because the
aids and cids properties each require an extra request to retrieve.</p>
<p>:param properties: (optional) A list of the desired properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, properties=None):
    &#34;&#34;&#34;Return a dictionary containing Substance data.

    If the properties parameter is not specified, everything except cids and aids is included. This is because the
    aids and cids properties each require an extra request to retrieve.

    :param properties: (optional) A list of the desired properties.
    &#34;&#34;&#34;
    if not properties:
        skip = {&#39;deposited_compound&#39;, &#39;standardized_compound&#39;, &#39;cids&#39;, &#39;aids&#39;}
        properties = [p for p in dir(Substance) if isinstance(getattr(Substance, p), property) and p not in skip]
    return {p: getattr(self, p) for p in properties}</code></pre>
</details>
</dd>
<dt id="pubchempy.Substance.to_series"><code class="name flex">
<span>def <span class="ident">to_series</span></span>(<span>self, properties=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a pandas :class:<code>~pandas.Series</code> containing Substance data.</p>
<p>If the properties parameter is not specified, everything except cids and aids is included. This is because the
aids and cids properties each require an extra request to retrieve.</p>
<p>:param properties: (optional) A list of the desired properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_series(self, properties=None):
    &#34;&#34;&#34;Return a pandas :class:`~pandas.Series` containing Substance data.

    If the properties parameter is not specified, everything except cids and aids is included. This is because the
    aids and cids properties each require an extra request to retrieve.

    :param properties: (optional) A list of the desired properties.
    &#34;&#34;&#34;
    import pandas as pd
    return pd.Series(self.to_dict(properties))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pubchempy.TimeoutError"><code class="flex name class">
<span>class <span class="ident">TimeoutError</span></span>
<span>(</span><span>msg='The request timed out')</span>
</code></dt>
<dd>
<div class="desc"><p>The request timed out, from server overload or too broad a request.</p>
<p>See :ref:<code>Avoiding TimeoutError &lt;avoiding_timeouterror&gt;</code> for more information.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeoutError(PubChemHTTPError):
    &#34;&#34;&#34;The request timed out, from server overload or too broad a request.

    See :ref:`Avoiding TimeoutError &lt;avoiding_timeouterror&gt;` for more information.
    &#34;&#34;&#34;
    def __init__(self, msg=&#39;The request timed out&#39;):
        self.msg = msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pubchempy.PubChemHTTPError" href="#pubchempy.PubChemHTTPError">PubChemHTTPError</a></li>
<li><a title="pubchempy.PubChemPyError" href="#pubchempy.PubChemPyError">PubChemPyError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="pubchempy.UnimplementedError"><code class="flex name class">
<span>class <span class="ident">UnimplementedError</span></span>
<span>(</span><span>msg='The requested operation has not been implemented')</span>
</code></dt>
<dd>
<div class="desc"><p>The requested operation has not (yet) been implemented by the server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnimplementedError(PubChemHTTPError):
    &#34;&#34;&#34;The requested operation has not (yet) been implemented by the server.&#34;&#34;&#34;
    def __init__(self, msg=&#39;The requested operation has not been implemented&#39;):
        self.msg = msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pubchempy.PubChemHTTPError" href="#pubchempy.PubChemHTTPError">PubChemHTTPError</a></li>
<li><a title="pubchempy.PubChemPyError" href="#pubchempy.PubChemPyError">PubChemPyError</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pubchempy.compounds_to_frame" href="#pubchempy.compounds_to_frame">compounds_to_frame</a></code></li>
<li><code><a title="pubchempy.deprecated" href="#pubchempy.deprecated">deprecated</a></code></li>
<li><code><a title="pubchempy.download" href="#pubchempy.download">download</a></code></li>
<li><code><a title="pubchempy.get" href="#pubchempy.get">get</a></code></li>
<li><code><a title="pubchempy.get_aids" href="#pubchempy.get_aids">get_aids</a></code></li>
<li><code><a title="pubchempy.get_all_sources" href="#pubchempy.get_all_sources">get_all_sources</a></code></li>
<li><code><a title="pubchempy.get_assays" href="#pubchempy.get_assays">get_assays</a></code></li>
<li><code><a title="pubchempy.get_cids" href="#pubchempy.get_cids">get_cids</a></code></li>
<li><code><a title="pubchempy.get_compounds" href="#pubchempy.get_compounds">get_compounds</a></code></li>
<li><code><a title="pubchempy.get_json" href="#pubchempy.get_json">get_json</a></code></li>
<li><code><a title="pubchempy.get_properties" href="#pubchempy.get_properties">get_properties</a></code></li>
<li><code><a title="pubchempy.get_sdf" href="#pubchempy.get_sdf">get_sdf</a></code></li>
<li><code><a title="pubchempy.get_sids" href="#pubchempy.get_sids">get_sids</a></code></li>
<li><code><a title="pubchempy.get_substances" href="#pubchempy.get_substances">get_substances</a></code></li>
<li><code><a title="pubchempy.get_synonyms" href="#pubchempy.get_synonyms">get_synonyms</a></code></li>
<li><code><a title="pubchempy.memoized_property" href="#pubchempy.memoized_property">memoized_property</a></code></li>
<li><code><a title="pubchempy.request" href="#pubchempy.request">request</a></code></li>
<li><code><a title="pubchempy.substances_to_frame" href="#pubchempy.substances_to_frame">substances_to_frame</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pubchempy.Assay" href="#pubchempy.Assay">Assay</a></code></h4>
<ul class="two-column">
<li><code><a title="pubchempy.Assay.aid" href="#pubchempy.Assay.aid">aid</a></code></li>
<li><code><a title="pubchempy.Assay.aid_version" href="#pubchempy.Assay.aid_version">aid_version</a></code></li>
<li><code><a title="pubchempy.Assay.comments" href="#pubchempy.Assay.comments">comments</a></code></li>
<li><code><a title="pubchempy.Assay.description" href="#pubchempy.Assay.description">description</a></code></li>
<li><code><a title="pubchempy.Assay.from_aid" href="#pubchempy.Assay.from_aid">from_aid</a></code></li>
<li><code><a title="pubchempy.Assay.name" href="#pubchempy.Assay.name">name</a></code></li>
<li><code><a title="pubchempy.Assay.project_category" href="#pubchempy.Assay.project_category">project_category</a></code></li>
<li><code><a title="pubchempy.Assay.record" href="#pubchempy.Assay.record">record</a></code></li>
<li><code><a title="pubchempy.Assay.results" href="#pubchempy.Assay.results">results</a></code></li>
<li><code><a title="pubchempy.Assay.revision" href="#pubchempy.Assay.revision">revision</a></code></li>
<li><code><a title="pubchempy.Assay.target" href="#pubchempy.Assay.target">target</a></code></li>
<li><code><a title="pubchempy.Assay.to_dict" href="#pubchempy.Assay.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubchempy.Atom" href="#pubchempy.Atom">Atom</a></code></h4>
<ul class="two-column">
<li><code><a title="pubchempy.Atom.aid" href="#pubchempy.Atom.aid">aid</a></code></li>
<li><code><a title="pubchempy.Atom.charge" href="#pubchempy.Atom.charge">charge</a></code></li>
<li><code><a title="pubchempy.Atom.coordinate_type" href="#pubchempy.Atom.coordinate_type">coordinate_type</a></code></li>
<li><code><a title="pubchempy.Atom.element" href="#pubchempy.Atom.element">element</a></code></li>
<li><code><a title="pubchempy.Atom.number" href="#pubchempy.Atom.number">number</a></code></li>
<li><code><a title="pubchempy.Atom.set_coordinates" href="#pubchempy.Atom.set_coordinates">set_coordinates</a></code></li>
<li><code><a title="pubchempy.Atom.to_dict" href="#pubchempy.Atom.to_dict">to_dict</a></code></li>
<li><code><a title="pubchempy.Atom.x" href="#pubchempy.Atom.x">x</a></code></li>
<li><code><a title="pubchempy.Atom.y" href="#pubchempy.Atom.y">y</a></code></li>
<li><code><a title="pubchempy.Atom.z" href="#pubchempy.Atom.z">z</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubchempy.BadRequestError" href="#pubchempy.BadRequestError">BadRequestError</a></code></h4>
</li>
<li>
<h4><code><a title="pubchempy.Bond" href="#pubchempy.Bond">Bond</a></code></h4>
<ul class="">
<li><code><a title="pubchempy.Bond.aid1" href="#pubchempy.Bond.aid1">aid1</a></code></li>
<li><code><a title="pubchempy.Bond.aid2" href="#pubchempy.Bond.aid2">aid2</a></code></li>
<li><code><a title="pubchempy.Bond.order" href="#pubchempy.Bond.order">order</a></code></li>
<li><code><a title="pubchempy.Bond.style" href="#pubchempy.Bond.style">style</a></code></li>
<li><code><a title="pubchempy.Bond.to_dict" href="#pubchempy.Bond.to_dict">to_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubchempy.BondType" href="#pubchempy.BondType">BondType</a></code></h4>
<ul class="two-column">
<li><code><a title="pubchempy.BondType.COMPLEX" href="#pubchempy.BondType.COMPLEX">COMPLEX</a></code></li>
<li><code><a title="pubchempy.BondType.DATIVE" href="#pubchempy.BondType.DATIVE">DATIVE</a></code></li>
<li><code><a title="pubchempy.BondType.DOUBLE" href="#pubchempy.BondType.DOUBLE">DOUBLE</a></code></li>
<li><code><a title="pubchempy.BondType.IONIC" href="#pubchempy.BondType.IONIC">IONIC</a></code></li>
<li><code><a title="pubchempy.BondType.QUADRUPLE" href="#pubchempy.BondType.QUADRUPLE">QUADRUPLE</a></code></li>
<li><code><a title="pubchempy.BondType.SINGLE" href="#pubchempy.BondType.SINGLE">SINGLE</a></code></li>
<li><code><a title="pubchempy.BondType.TRIPLE" href="#pubchempy.BondType.TRIPLE">TRIPLE</a></code></li>
<li><code><a title="pubchempy.BondType.UNKNOWN" href="#pubchempy.BondType.UNKNOWN">UNKNOWN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubchempy.Compound" href="#pubchempy.Compound">Compound</a></code></h4>
<ul class="">
<li><code><a title="pubchempy.Compound.aids" href="#pubchempy.Compound.aids">aids</a></code></li>
<li><code><a title="pubchempy.Compound.atom_stereo_count" href="#pubchempy.Compound.atom_stereo_count">atom_stereo_count</a></code></li>
<li><code><a title="pubchempy.Compound.atoms" href="#pubchempy.Compound.atoms">atoms</a></code></li>
<li><code><a title="pubchempy.Compound.bond_stereo_count" href="#pubchempy.Compound.bond_stereo_count">bond_stereo_count</a></code></li>
<li><code><a title="pubchempy.Compound.bonds" href="#pubchempy.Compound.bonds">bonds</a></code></li>
<li><code><a title="pubchempy.Compound.cactvs_fingerprint" href="#pubchempy.Compound.cactvs_fingerprint">cactvs_fingerprint</a></code></li>
<li><code><a title="pubchempy.Compound.canonical_smiles" href="#pubchempy.Compound.canonical_smiles">canonical_smiles</a></code></li>
<li><code><a title="pubchempy.Compound.charge" href="#pubchempy.Compound.charge">charge</a></code></li>
<li><code><a title="pubchempy.Compound.cid" href="#pubchempy.Compound.cid">cid</a></code></li>
<li><code><a title="pubchempy.Compound.complexity" href="#pubchempy.Compound.complexity">complexity</a></code></li>
<li><code><a title="pubchempy.Compound.conformer_id_3d" href="#pubchempy.Compound.conformer_id_3d">conformer_id_3d</a></code></li>
<li><code><a title="pubchempy.Compound.conformer_rmsd_3d" href="#pubchempy.Compound.conformer_rmsd_3d">conformer_rmsd_3d</a></code></li>
<li><code><a title="pubchempy.Compound.coordinate_type" href="#pubchempy.Compound.coordinate_type">coordinate_type</a></code></li>
<li><code><a title="pubchempy.Compound.covalent_unit_count" href="#pubchempy.Compound.covalent_unit_count">covalent_unit_count</a></code></li>
<li><code><a title="pubchempy.Compound.defined_atom_stereo_count" href="#pubchempy.Compound.defined_atom_stereo_count">defined_atom_stereo_count</a></code></li>
<li><code><a title="pubchempy.Compound.defined_bond_stereo_count" href="#pubchempy.Compound.defined_bond_stereo_count">defined_bond_stereo_count</a></code></li>
<li><code><a title="pubchempy.Compound.effective_rotor_count_3d" href="#pubchempy.Compound.effective_rotor_count_3d">effective_rotor_count_3d</a></code></li>
<li><code><a title="pubchempy.Compound.elements" href="#pubchempy.Compound.elements">elements</a></code></li>
<li><code><a title="pubchempy.Compound.exact_mass" href="#pubchempy.Compound.exact_mass">exact_mass</a></code></li>
<li><code><a title="pubchempy.Compound.feature_selfoverlap_3d" href="#pubchempy.Compound.feature_selfoverlap_3d">feature_selfoverlap_3d</a></code></li>
<li><code><a title="pubchempy.Compound.fingerprint" href="#pubchempy.Compound.fingerprint">fingerprint</a></code></li>
<li><code><a title="pubchempy.Compound.from_cid" href="#pubchempy.Compound.from_cid">from_cid</a></code></li>
<li><code><a title="pubchempy.Compound.h_bond_acceptor_count" href="#pubchempy.Compound.h_bond_acceptor_count">h_bond_acceptor_count</a></code></li>
<li><code><a title="pubchempy.Compound.h_bond_donor_count" href="#pubchempy.Compound.h_bond_donor_count">h_bond_donor_count</a></code></li>
<li><code><a title="pubchempy.Compound.heavy_atom_count" href="#pubchempy.Compound.heavy_atom_count">heavy_atom_count</a></code></li>
<li><code><a title="pubchempy.Compound.inchi" href="#pubchempy.Compound.inchi">inchi</a></code></li>
<li><code><a title="pubchempy.Compound.inchikey" href="#pubchempy.Compound.inchikey">inchikey</a></code></li>
<li><code><a title="pubchempy.Compound.isomeric_smiles" href="#pubchempy.Compound.isomeric_smiles">isomeric_smiles</a></code></li>
<li><code><a title="pubchempy.Compound.isotope_atom_count" href="#pubchempy.Compound.isotope_atom_count">isotope_atom_count</a></code></li>
<li><code><a title="pubchempy.Compound.iupac_name" href="#pubchempy.Compound.iupac_name">iupac_name</a></code></li>
<li><code><a title="pubchempy.Compound.mmff94_energy_3d" href="#pubchempy.Compound.mmff94_energy_3d">mmff94_energy_3d</a></code></li>
<li><code><a title="pubchempy.Compound.mmff94_partial_charges_3d" href="#pubchempy.Compound.mmff94_partial_charges_3d">mmff94_partial_charges_3d</a></code></li>
<li><code><a title="pubchempy.Compound.molecular_formula" href="#pubchempy.Compound.molecular_formula">molecular_formula</a></code></li>
<li><code><a title="pubchempy.Compound.molecular_weight" href="#pubchempy.Compound.molecular_weight">molecular_weight</a></code></li>
<li><code><a title="pubchempy.Compound.monoisotopic_mass" href="#pubchempy.Compound.monoisotopic_mass">monoisotopic_mass</a></code></li>
<li><code><a title="pubchempy.Compound.multipoles_3d" href="#pubchempy.Compound.multipoles_3d">multipoles_3d</a></code></li>
<li><code><a title="pubchempy.Compound.pharmacophore_features_3d" href="#pubchempy.Compound.pharmacophore_features_3d">pharmacophore_features_3d</a></code></li>
<li><code><a title="pubchempy.Compound.record" href="#pubchempy.Compound.record">record</a></code></li>
<li><code><a title="pubchempy.Compound.rotatable_bond_count" href="#pubchempy.Compound.rotatable_bond_count">rotatable_bond_count</a></code></li>
<li><code><a title="pubchempy.Compound.shape_fingerprint_3d" href="#pubchempy.Compound.shape_fingerprint_3d">shape_fingerprint_3d</a></code></li>
<li><code><a title="pubchempy.Compound.shape_selfoverlap_3d" href="#pubchempy.Compound.shape_selfoverlap_3d">shape_selfoverlap_3d</a></code></li>
<li><code><a title="pubchempy.Compound.sids" href="#pubchempy.Compound.sids">sids</a></code></li>
<li><code><a title="pubchempy.Compound.synonyms" href="#pubchempy.Compound.synonyms">synonyms</a></code></li>
<li><code><a title="pubchempy.Compound.to_dict" href="#pubchempy.Compound.to_dict">to_dict</a></code></li>
<li><code><a title="pubchempy.Compound.to_series" href="#pubchempy.Compound.to_series">to_series</a></code></li>
<li><code><a title="pubchempy.Compound.tpsa" href="#pubchempy.Compound.tpsa">tpsa</a></code></li>
<li><code><a title="pubchempy.Compound.undefined_atom_stereo_count" href="#pubchempy.Compound.undefined_atom_stereo_count">undefined_atom_stereo_count</a></code></li>
<li><code><a title="pubchempy.Compound.undefined_bond_stereo_count" href="#pubchempy.Compound.undefined_bond_stereo_count">undefined_bond_stereo_count</a></code></li>
<li><code><a title="pubchempy.Compound.volume_3d" href="#pubchempy.Compound.volume_3d">volume_3d</a></code></li>
<li><code><a title="pubchempy.Compound.xlogp" href="#pubchempy.Compound.xlogp">xlogp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubchempy.CompoundIdType" href="#pubchempy.CompoundIdType">CompoundIdType</a></code></h4>
<ul class="two-column">
<li><code><a title="pubchempy.CompoundIdType.COMPONENT" href="#pubchempy.CompoundIdType.COMPONENT">COMPONENT</a></code></li>
<li><code><a title="pubchempy.CompoundIdType.DEPOSITED" href="#pubchempy.CompoundIdType.DEPOSITED">DEPOSITED</a></code></li>
<li><code><a title="pubchempy.CompoundIdType.IONIZED" href="#pubchempy.CompoundIdType.IONIZED">IONIZED</a></code></li>
<li><code><a title="pubchempy.CompoundIdType.MIXTURE" href="#pubchempy.CompoundIdType.MIXTURE">MIXTURE</a></code></li>
<li><code><a title="pubchempy.CompoundIdType.NEUTRALIZED" href="#pubchempy.CompoundIdType.NEUTRALIZED">NEUTRALIZED</a></code></li>
<li><code><a title="pubchempy.CompoundIdType.STANDARDIZED" href="#pubchempy.CompoundIdType.STANDARDIZED">STANDARDIZED</a></code></li>
<li><code><a title="pubchempy.CompoundIdType.TAUTOMER" href="#pubchempy.CompoundIdType.TAUTOMER">TAUTOMER</a></code></li>
<li><code><a title="pubchempy.CompoundIdType.UNKNOWN" href="#pubchempy.CompoundIdType.UNKNOWN">UNKNOWN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubchempy.CoordinateType" href="#pubchempy.CoordinateType">CoordinateType</a></code></h4>
<ul class="two-column">
<li><code><a title="pubchempy.CoordinateType.ALIGNED" href="#pubchempy.CoordinateType.ALIGNED">ALIGNED</a></code></li>
<li><code><a title="pubchempy.CoordinateType.AUGMENTED" href="#pubchempy.CoordinateType.AUGMENTED">AUGMENTED</a></code></li>
<li><code><a title="pubchempy.CoordinateType.COMPACT" href="#pubchempy.CoordinateType.COMPACT">COMPACT</a></code></li>
<li><code><a title="pubchempy.CoordinateType.COMPUTED" href="#pubchempy.CoordinateType.COMPUTED">COMPUTED</a></code></li>
<li><code><a title="pubchempy.CoordinateType.EXPERIMENTAL" href="#pubchempy.CoordinateType.EXPERIMENTAL">EXPERIMENTAL</a></code></li>
<li><code><a title="pubchempy.CoordinateType.STANDARDIZED" href="#pubchempy.CoordinateType.STANDARDIZED">STANDARDIZED</a></code></li>
<li><code><a title="pubchempy.CoordinateType.SUBMITTED" href="#pubchempy.CoordinateType.SUBMITTED">SUBMITTED</a></code></li>
<li><code><a title="pubchempy.CoordinateType.THREE_D" href="#pubchempy.CoordinateType.THREE_D">THREE_D</a></code></li>
<li><code><a title="pubchempy.CoordinateType.TWO_D" href="#pubchempy.CoordinateType.TWO_D">TWO_D</a></code></li>
<li><code><a title="pubchempy.CoordinateType.UNITS_ANGSTROMS" href="#pubchempy.CoordinateType.UNITS_ANGSTROMS">UNITS_ANGSTROMS</a></code></li>
<li><code><a title="pubchempy.CoordinateType.UNITS_NANOMETERS" href="#pubchempy.CoordinateType.UNITS_NANOMETERS">UNITS_NANOMETERS</a></code></li>
<li><code><a title="pubchempy.CoordinateType.UNITS_PIXEL" href="#pubchempy.CoordinateType.UNITS_PIXEL">UNITS_PIXEL</a></code></li>
<li><code><a title="pubchempy.CoordinateType.UNITS_POINTS" href="#pubchempy.CoordinateType.UNITS_POINTS">UNITS_POINTS</a></code></li>
<li><code><a title="pubchempy.CoordinateType.UNITS_STDBONDS" href="#pubchempy.CoordinateType.UNITS_STDBONDS">UNITS_STDBONDS</a></code></li>
<li><code><a title="pubchempy.CoordinateType.UNITS_UNKNOWN" href="#pubchempy.CoordinateType.UNITS_UNKNOWN">UNITS_UNKNOWN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubchempy.MethodNotAllowedError" href="#pubchempy.MethodNotAllowedError">MethodNotAllowedError</a></code></h4>
</li>
<li>
<h4><code><a title="pubchempy.NotFoundError" href="#pubchempy.NotFoundError">NotFoundError</a></code></h4>
</li>
<li>
<h4><code><a title="pubchempy.ProjectCategory" href="#pubchempy.ProjectCategory">ProjectCategory</a></code></h4>
<ul class="">
<li><code><a title="pubchempy.ProjectCategory.ASSAY_VENDOR" href="#pubchempy.ProjectCategory.ASSAY_VENDOR">ASSAY_VENDOR</a></code></li>
<li><code><a title="pubchempy.ProjectCategory.JOURNAL_ARTICLE" href="#pubchempy.ProjectCategory.JOURNAL_ARTICLE">JOURNAL_ARTICLE</a></code></li>
<li><code><a title="pubchempy.ProjectCategory.LITERATURE_AUTHOR" href="#pubchempy.ProjectCategory.LITERATURE_AUTHOR">LITERATURE_AUTHOR</a></code></li>
<li><code><a title="pubchempy.ProjectCategory.LITERATURE_EXTRACTED" href="#pubchempy.ProjectCategory.LITERATURE_EXTRACTED">LITERATURE_EXTRACTED</a></code></li>
<li><code><a title="pubchempy.ProjectCategory.LITERATURE_PUBLISHER" href="#pubchempy.ProjectCategory.LITERATURE_PUBLISHER">LITERATURE_PUBLISHER</a></code></li>
<li><code><a title="pubchempy.ProjectCategory.MLSCN" href="#pubchempy.ProjectCategory.MLSCN">MLSCN</a></code></li>
<li><code><a title="pubchempy.ProjectCategory.MLSCN_AP" href="#pubchempy.ProjectCategory.MLSCN_AP">MLSCN_AP</a></code></li>
<li><code><a title="pubchempy.ProjectCategory.MPLCN" href="#pubchempy.ProjectCategory.MPLCN">MPLCN</a></code></li>
<li><code><a title="pubchempy.ProjectCategory.MPLCN_AP" href="#pubchempy.ProjectCategory.MPLCN_AP">MPLCN_AP</a></code></li>
<li><code><a title="pubchempy.ProjectCategory.OTHER" href="#pubchempy.ProjectCategory.OTHER">OTHER</a></code></li>
<li><code><a title="pubchempy.ProjectCategory.RNAIGI" href="#pubchempy.ProjectCategory.RNAIGI">RNAIGI</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubchempy.PubChemHTTPError" href="#pubchempy.PubChemHTTPError">PubChemHTTPError</a></code></h4>
</li>
<li>
<h4><code><a title="pubchempy.PubChemPyDeprecationWarning" href="#pubchempy.PubChemPyDeprecationWarning">PubChemPyDeprecationWarning</a></code></h4>
</li>
<li>
<h4><code><a title="pubchempy.PubChemPyError" href="#pubchempy.PubChemPyError">PubChemPyError</a></code></h4>
</li>
<li>
<h4><code><a title="pubchempy.ResponseParseError" href="#pubchempy.ResponseParseError">ResponseParseError</a></code></h4>
</li>
<li>
<h4><code><a title="pubchempy.ServerError" href="#pubchempy.ServerError">ServerError</a></code></h4>
</li>
<li>
<h4><code><a title="pubchempy.Substance" href="#pubchempy.Substance">Substance</a></code></h4>
<ul class="">
<li><code><a title="pubchempy.Substance.aids" href="#pubchempy.Substance.aids">aids</a></code></li>
<li><code><a title="pubchempy.Substance.cids" href="#pubchempy.Substance.cids">cids</a></code></li>
<li><code><a title="pubchempy.Substance.deposited_compound" href="#pubchempy.Substance.deposited_compound">deposited_compound</a></code></li>
<li><code><a title="pubchempy.Substance.from_sid" href="#pubchempy.Substance.from_sid">from_sid</a></code></li>
<li><code><a title="pubchempy.Substance.record" href="#pubchempy.Substance.record">record</a></code></li>
<li><code><a title="pubchempy.Substance.sid" href="#pubchempy.Substance.sid">sid</a></code></li>
<li><code><a title="pubchempy.Substance.source_id" href="#pubchempy.Substance.source_id">source_id</a></code></li>
<li><code><a title="pubchempy.Substance.source_name" href="#pubchempy.Substance.source_name">source_name</a></code></li>
<li><code><a title="pubchempy.Substance.standardized_cid" href="#pubchempy.Substance.standardized_cid">standardized_cid</a></code></li>
<li><code><a title="pubchempy.Substance.standardized_compound" href="#pubchempy.Substance.standardized_compound">standardized_compound</a></code></li>
<li><code><a title="pubchempy.Substance.synonyms" href="#pubchempy.Substance.synonyms">synonyms</a></code></li>
<li><code><a title="pubchempy.Substance.to_dict" href="#pubchempy.Substance.to_dict">to_dict</a></code></li>
<li><code><a title="pubchempy.Substance.to_series" href="#pubchempy.Substance.to_series">to_series</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pubchempy.TimeoutError" href="#pubchempy.TimeoutError">TimeoutError</a></code></h4>
</li>
<li>
<h4><code><a title="pubchempy.UnimplementedError" href="#pubchempy.UnimplementedError">UnimplementedError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>