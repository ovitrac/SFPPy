<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>mstruct API documentation</title>
<meta name="description" content="Module: `struct.py`
Matlab-like structure class with extensions for parameter evaluation, file paths, and automatic management of dependencies in …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mstruct</code></h1>
</header>
<section id="section-intro">
<h1 id="module-structpy">Module: <code>struct.py</code></h1>
<p>Matlab-like structure class with extensions for parameter evaluation, file paths, and automatic management of dependencies in parameter definitions. This module provides the following key classes:</p>
<ul>
<li><strong><code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code></strong>: A flexible base class that mimics Matlab structures, offering dynamic field creation, indexing, concatenation, and field-level evaluation.</li>
<li><strong><code><a title="mstruct.param" href="#mstruct.param">param</a></code></strong>: Derived from <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code>, this class enables dynamic evaluation of fields based on interdependent definitions.</li>
<li><strong><code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code></strong>: A further extension of <code><a title="mstruct.param" href="#mstruct.param">param</a></code> with automatic sorting and resolution of parameter dependencies during operations.</li>
<li><strong><code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code></strong>: A string subclass specialized for handling file paths and POSIX compatibility.</li>
</ul>
<hr>
<h2 id="purpose">Purpose</h2>
<p>This module aims to streamline the creation and manipulation of structures for scientific computation, data management, and dynamic scripting, particularly in complex workflows.</p>
<hr>
<h2 id="key-features">Key Features</h2>
<ul>
<li><strong>Flexible Dynamic Structure</strong>: Provides <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code> with field creation, deletion, and manipulation.</li>
<li><strong>Parameter Evaluation</strong>: Supports interdependent parameter evaluation with <code><a title="mstruct.param" href="#mstruct.param">param</a></code>.</li>
<li><strong>Path and String Management</strong>: Handles file paths and POSIX compliance with <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code>.</li>
<li><strong>Automatic Dependency Resolution</strong>: Manages parameter dependencies automatically with <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code>.</li>
</ul>
<hr>
<h2 id="evaluation-features">Evaluation Features</h2>
<ul>
<li><strong>Dynamic Expressions</strong>: Evaluate expressions within <code>${...}</code> placeholders or as standalone scalar expressions.</li>
<li><strong>Matrix and Array Support</strong>: Perform advanced operations such as matrix multiplication (<code>@</code>), transposition (<code>.T</code>), and slicing within <code>${...}</code>.</li>
<li><strong>Safe Evaluation</strong>: Eliminates the use of <code>eval</code>, using <code>safe_fstring()</code> and <code><a title="mstruct.SafeEvaluator" href="#mstruct.SafeEvaluator">SafeEvaluator</a></code> for secure computation.</li>
<li><strong>Comprehensive Function Set</strong>:</li>
<li><strong>Trigonometric Functions</strong>: <code>sin</code>, <code>cos</code>, <code>tan</code>, etc.</li>
<li><strong>Exponential and Logarithmic</strong>: <code>exp</code>, <code>log</code>, <code>sqrt</code>, etc.</li>
<li><strong>Random Functions</strong>: <code>gauss</code>, <code>uniform</code>, <code>randint</code>, etc.</li>
<li><strong>Error Handling</strong>: Robust detection of undefined variables, invalid operations, and unsupported expressions.</li>
<li><strong>Type Preservation</strong>: Retains original data types (e.g., <code>float</code>, <code>numpy.ndarray</code>) for accuracy and further computation.</li>
<li><strong>Custom Formatting</strong>: Formats arrays and matrices for display with clear distinction between row/column vectors and higher-dimensional arrays.</li>
</ul>
<hr>
<h2 id="examples">Examples</h2>
<h3 id="basic-struct-usage">Basic Struct Usage</h3>
<pre><code class="language-python">from struct import struct

s = struct(a=1, b=2, c='${a} + ${b}')
s.a = 10
s[&quot;b&quot;] = 5
delattr(s, &quot;c&quot;)  # Delete a field
</code></pre>
<hr>
<h3 id="parameter-evaluation-with-param">Parameter Evaluation with <code><a title="mstruct.param" href="#mstruct.param">param</a></code></h3>
<pre><code class="language-python">from struct import param

# Define parameters with dependencies
p = param(a=1, b='${a}*2', c='${b}+5')
evaluated = p.eval()  # Evaluate all fields dynamically
print(evaluated.c)  # Output: 7
</code></pre>
<hr>
<h3 id="path-management-with-pstr">Path Management with <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code></h3>
<pre><code class="language-python">from struct import pstr

# Create and manipulate POSIX-compliant paths
path = pstr(&quot;/this/is/a/path/&quot;)
combined = path / &quot;file.txt&quot;
print(combined)  # Output: &quot;/this/is/a/path/file.txt&quot;
</code></pre>
<hr>
<h3 id="automatic-dependency-handling-with-paramauto">Automatic Dependency Handling with <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code></h3>
<pre><code class="language-python">from struct import paramauto

# Automatically resolve dependencies in parameters
pa = paramauto(a=1, b='${a}+1', c='${b}*2')
pa.disp()
# Output:
# -----------
#       a: 1
#       b: ${a}+1
#        = 2
#       c: ${b}*2
#        = 4
# -----------
</code></pre>
<hr>
<h3 id="evaluation-usage">Evaluation Usage</h3>
<pre><code class="language-python">from patankar.private.mstruct import param
import numpy as np

p = param()
p.a = [1.0, 0.2, 0.03, 0.004]
p.b = np.array([p.a])
p.f = p.b.T @ p.b  # Matrix multiplication
p.g = &quot;${a[1]}&quot;    # Expression referencing `a`
p.h = &quot;${b.T @ b}&quot; # Matrix operation
print(p.eval())
</code></pre>
<hr>
<p>Created on Sun Jan 23 14:19:03 2022
<strong>Author</strong>: INRAE\Olivier Vitrac</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
# Module: `struct.py`
Matlab-like structure class with extensions for parameter evaluation, file paths, and automatic management of dependencies in parameter definitions. This module provides the following key classes:

- **`struct`**: A flexible base class that mimics Matlab structures, offering dynamic field creation, indexing, concatenation, and field-level evaluation.
- **`param`**: Derived from `struct`, this class enables dynamic evaluation of fields based on interdependent definitions.
- **`paramauto`**: A further extension of `param` with automatic sorting and resolution of parameter dependencies during operations.
- **`pstr`**: A string subclass specialized for handling file paths and POSIX compatibility.

---

## Purpose
This module aims to streamline the creation and manipulation of structures for scientific computation, data management, and dynamic scripting, particularly in complex workflows.

---

## Key Features
- **Flexible Dynamic Structure**: Provides `struct` with field creation, deletion, and manipulation.
- **Parameter Evaluation**: Supports interdependent parameter evaluation with `param`.
- **Path and String Management**: Handles file paths and POSIX compliance with `pstr`.
- **Automatic Dependency Resolution**: Manages parameter dependencies automatically with `paramauto`.

---

## Evaluation Features
- **Dynamic Expressions**: Evaluate expressions within `${...}` placeholders or as standalone scalar expressions.
- **Matrix and Array Support**: Perform advanced operations such as matrix multiplication (`@`), transposition (`.T`), and slicing within `${...}`.
- **Safe Evaluation**: Eliminates the use of `eval`, using `safe_fstring()` and `SafeEvaluator` for secure computation.
- **Comprehensive Function Set**:
  - **Trigonometric Functions**: `sin`, `cos`, `tan`, etc.
  - **Exponential and Logarithmic**: `exp`, `log`, `sqrt`, etc.
  - **Random Functions**: `gauss`, `uniform`, `randint`, etc.
- **Error Handling**: Robust detection of undefined variables, invalid operations, and unsupported expressions.
- **Type Preservation**: Retains original data types (e.g., `float`, `numpy.ndarray`) for accuracy and further computation.
- **Custom Formatting**: Formats arrays and matrices for display with clear distinction between row/column vectors and higher-dimensional arrays.


---

## Examples

### Basic Struct Usage
```python
from struct import struct

s = struct(a=1, b=2, c=&#39;${a} + ${b}&#39;)
s.a = 10
s[&#34;b&#34;] = 5
delattr(s, &#34;c&#34;)  # Delete a field
```

---

### Parameter Evaluation with `param`
```python
from struct import param

# Define parameters with dependencies
p = param(a=1, b=&#39;${a}*2&#39;, c=&#39;${b}+5&#39;)
evaluated = p.eval()  # Evaluate all fields dynamically
print(evaluated.c)  # Output: 7
```

---

### Path Management with `pstr`
```python
from struct import pstr

# Create and manipulate POSIX-compliant paths
path = pstr(&#34;/this/is/a/path/&#34;)
combined = path / &#34;file.txt&#34;
print(combined)  # Output: &#34;/this/is/a/path/file.txt&#34;
```

---

### Automatic Dependency Handling with `paramauto`
```python
from struct import paramauto

# Automatically resolve dependencies in parameters
pa = paramauto(a=1, b=&#39;${a}+1&#39;, c=&#39;${b}*2&#39;)
pa.disp()
# Output:
# -----------
#       a: 1
#       b: ${a}+1
#        = 2
#       c: ${b}*2
#        = 4
# -----------
```

---

### Evaluation Usage
```python
from patankar.private.mstruct import param
import numpy as np

p = param()
p.a = [1.0, 0.2, 0.03, 0.004]
p.b = np.array([p.a])
p.f = p.b.T @ p.b  # Matrix multiplication
p.g = &#34;${a[1]}&#34;    # Expression referencing `a`
p.h = &#34;${b.T @ b}&#34; # Matrix operation
print(p.eval())
```

---

Created on Sun Jan 23 14:19:03 2022
**Author**: INRAE\Olivier Vitrac
&#34;&#34;&#34;

# revision history
# imported from the project Pizza3 (not used yet in SFPPy)

__project__ = &#34;SFPPy&#34; # from project Pizza3
__author__ = &#34;Olivier Vitrac&#34;
__copyright__ = &#34;Copyright 2022&#34;
__credits__ = [&#34;Olivier Vitrac&#34;]
__license__ = &#34;MIT&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;1.2&#34;


# %% Dependencies
# import types     # to check types (not required anymore since only builtin types are used)
import ast         # for safe evaluation (ast.literal_eval is used to evaluate strings starting with !)
import operator    # operators
import re          # regular expression
from pathlib import Path # for path managment (note that pstr uses its own logic)
from pathlib import PurePosixPath as PurePath
from copy import copy as duplicate # to duplicate objects
from copy import deepcopy as duplicatedeep # used by __deepcopy__()
# Import math functions
import builtins, math
import random
import numpy as np

__all__ = [&#39;AttrErrorDict&#39;, &#39;SafeEvaluator&#39;, &#39;evaluate_with_placeholders&#39;, &#39;is_empty&#39;, &#39;is_literal_string&#39;, &#39;param&#39;, &#39;paramauto&#39;, &#39;pstr&#39;, &#39;struct&#39;]


# %% Private classes, functions, variables

_list_types = (list,tuple,np.ndarray) # list types recognized as such
_numeric_types = (int,float,str,list,tuple,np.ndarray, np.generic) # numeric types recognized as such


# List of functions recognized by SafeEvaluator()
# some functions might be unavailable with Python versions older than 3.10
_number_theoretic_funcs = [ # --- Number-Theoretic Functions
    &#34;comb&#34;,      # Number of ways to choose k items from n items without repetition and without order
    &#34;factorial&#34;, # n factorial
    &#34;gcd&#34;,       # Greatest common divisor of the integer arguments
    &#34;isqrt&#34;,     # Integer square root of a nonnegative integer n
    &#34;lcm&#34;,       # Least common multiple of the integer arguments
    &#34;perm&#34;       # Number of ways to choose k items from n items without repetition and with order
]
_floating_arithmetic_funcs = [ # --- Floating Point Arithmetic
    &#34;ceil&#34;,      # Ceiling of x, the smallest integer greater than or equal to x
    &#34;fabs&#34;,      # Absolute value of x
    &#34;floor&#34;,     # Floor of x, the largest integer less than or equal to x
#    &#34;fma&#34;,       # Fused multiply-add operation: (x * y) + z (Python 3.13 required)
    &#34;fmod&#34;,      # Remainder of division x / y
    &#34;modf&#34;,      # Fractional and integer parts of x
    &#34;remainder&#34;, # Remainder of x with respect to y
    &#34;trunc&#34;      # Integer part of x
]
_floating_manipulation_funcs = [ # --- Floating Point Manipulation Functions
    &#34;copysign&#34;,  # Magnitude (absolute value) of x with the sign of y
    &#34;frexp&#34;,     # Mantissa and exponent of x
    &#34;isclose&#34;,   # Check if the values a and b are close to each other
    &#34;isfinite&#34;,  # Check if x is neither an infinity nor a NaN
    &#34;isinf&#34;,     # Check if x is a positive or negative infinity
    &#34;isnan&#34;,     # Check if x is a NaN (not a number)
    &#34;ldexp&#34;,     # x * (2**i), inverse of function frexp()
    &#34;nextafter&#34;, # Floating-point value steps steps after x towards y
    &#34;ulp&#34;        # Value of the least significant bit of x
]
_power_exp_log_funcs = [ # --- Power, Exponential, and Logarithmic Functions
    &#34;cbrt&#34;,      # Cube root of x
    &#34;exp&#34;,       # e raised to the power x
    &#34;exp2&#34;,      # 2 raised to the power x
    &#34;expm1&#34;,     # e raised to the power x, minus 1
    &#34;log&#34;,       # Logarithm of x to the given base (e by default)
    &#34;log1p&#34;,     # Natural logarithm of 1+x (base e)
    &#34;log2&#34;,      # Base-2 logarithm of x
    &#34;log10&#34;,     # Base-10 logarithm of x
    &#34;pow&#34;,       # x raised to the power y
    &#34;sqrt&#34;       # Square root of x
]
_summation_product_funcs = [ # --- Summation and Product Functions
    &#34;dist&#34;,      # Euclidean distance between two points p and q given as an iterable of coordinates
    &#34;fsum&#34;,      # Sum of values in the input iterable
    &#34;hypot&#34;,     # Euclidean norm of an iterable of coordinates
    &#34;prod&#34;,      # Product of elements in the input iterable with a start value
    &#34;sumprod&#34;    # Sum of products from two iterables p and q
]
_angular_conversion_funcs = [ # --- Angular Conversion Functions
    &#34;degrees&#34;,   # Convert angle x from radians to degrees
    &#34;radians&#34;    # Convert angle x from degrees to radians
]
_trigonometric_funcs = [ # --- Trigonometric Functions
    &#34;acos&#34;,      # Arc cosine of x
    &#34;asin&#34;,      # Arc sine of x
    &#34;atan&#34;,      # Arc tangent of x
    &#34;atan2&#34;,     # Arc tangent of y/x
    &#34;cos&#34;,       # Cosine of x
    &#34;sin&#34;,       # Sine of x
    &#34;tan&#34;        # Tangent of x
]
_hyperbolic_funcs = [ # --- Hyperbolic Functions
    &#34;acosh&#34;,     # Inverse hyperbolic cosine of x
    &#34;asinh&#34;,     # Inverse hyperbolic sine of x
    &#34;atanh&#34;,     # Inverse hyperbolic tangent of x
    &#34;cosh&#34;,      # Hyperbolic cosine of x
    &#34;sinh&#34;,      # Hyperbolic sine of x
    &#34;tanh&#34;       # Hyperbolic tangent of x
]
_special_funcs = [ # --- Special Functions
    &#34;erf&#34;,       # Error function at x
    &#34;erfc&#34;,      # Complementary error function at x
    &#34;gamma&#34;,     # Gamma function at x
    &#34;lgamma&#34;     # Natural logarithm of the absolute value of the Gamma function at x
]
_constants = [ # --- Constants
    &#34;pi&#34;,        # π = 3.141592…
    &#34;e&#34;,         # e = 2.718281…
    &#34;tau&#34;,       # τ = 2π = 6.283185…
    &#34;inf&#34;,       # Positive infinity
    &#34;nan&#34;        # “Not a number” (NaN)
]
# Combine all functions and constants into one list:
_all_math_names = (
    _number_theoretic_funcs +
    _floating_arithmetic_funcs +
    _floating_manipulation_funcs +
    _power_exp_log_funcs +
    _summation_product_funcs +
    _angular_conversion_funcs +
    _trigonometric_funcs +
    _hyperbolic_funcs +
    _special_funcs +
    _constants
)


# Safe f&#34;&#34; to evaluate ${var}, ${expression} and some expressions ${v1}+${v2}
class SafeEvaluator(ast.NodeVisitor):
    &#34;&#34;&#34;A safe evaluator class for expressions involving math, NumPy, random, and basic operators.&#34;&#34;&#34;

    def __init__(self, context={}):
        self.context = {**context}
        # Update context with math functions/constants from _all_math_names that exist in math module.
        self.context.update({
            name: getattr(math, name)
            for name in _all_math_names if hasattr(math, name)
        })
        # Add built-in functions relevant for math that are not part of the math module.
        for name in (&#34;abs&#34;, &#34;round&#34;, &#34;min&#34;, &#34;max&#34;, &#34;sum&#34;, &#34;divmod&#34;):
            self.context[name] = getattr(builtins, name)

        self.context.update({
            &#34;gauss&#34;: random.gauss,
            &#34;uniform&#34;: random.uniform,
            &#34;randint&#34;: random.randint,
            &#34;choice&#34;: random.choice
        })
        # Add NumPy as np
        self.context[&#34;np&#34;] = np  # Allow &#39;np.sin&#39;, &#39;np.cos&#39;, etc.
        # Define allowed operators
        self.operators = {
            ast.Add: operator.add,
            ast.Sub: operator.sub,
            ast.Mult: operator.mul,
            ast.Div: operator.truediv,
            ast.FloorDiv: operator.floordiv,
            ast.Mod: operator.mod,
            ast.Pow: operator.pow,
            ast.USub: operator.neg,  # Unary subtraction
        }

    def visit_Name(self, node):
        if node.id in self.context:
            return self.context[node.id]
        raise ValueError(f&#34;Variable or function &#39;{node.id}&#39; is not defined&#34;)

    def visit_Constant(self, node):
        return node.value

    def visit_BinOp(self, node):
        left = self.visit(node.left)
        right = self.visit(node.right)
        op_type = type(node.op)
        if isinstance(left, np.ndarray) and isinstance(right, np.ndarray) and isinstance(node.op, ast.MatMult):
            return np.matmul(left, right)
        if op_type in self.operators:
            return self.operators[op_type](left, right)
        raise ValueError(f&#34;Unsupported operator: {op_type}&#34;)

    def visit_UnaryOp(self, node):
        operand = self.visit(node.operand)
        op_type = type(node.op)
        if op_type in self.operators:
            return self.operators[op_type](operand)
        raise ValueError(f&#34;Unsupported unary operator: {op_type}&#34;)

    def visit_Call(self, node):
        func = self.visit(node.func)
        if callable(func):
            args = [self.visit(arg) for arg in node.args]
            kwargs = {kw.arg: self.visit(kw.value) for kw in node.keywords}
            return func(*args, **kwargs)
        raise ValueError(f&#34;Function &#39;{ast.dump(node.func)}&#39; is not callable&#34;)

    def visit_Attribute(self, node):
        value = self.visit(node.value)
        attr = node.attr
        if hasattr(value, attr):
            # If the attribute is &#34;T&#34;, return the transpose of the array
            if attr == &#34;T&#34; and isinstance(value, np.ndarray):
                return value.T
            # Check if the attribute is the &#39;@&#39; matrix multiplication operator
            if attr == &#34;@&#34; and isinstance(value, np.ndarray):
                return value @ value  # or handle accordingly with another operand
            return getattr(value, attr)
        raise ValueError(f&#34;Object &#39;{value}&#39; has no attribute &#39;{attr}&#39;&#34;)

    def visit_Subscript(self, node):
        value = self.visit(node.value)
        slice_obj = self.visit(node.slice)
        try:
            return value[slice_obj]
        except Exception as e:
            raise ValueError(f&#34;Invalid index {slice_obj} for object of type {type(value).__name__}: {e}&#34;)

    def visit_Index(self, node):
        return self.visit(node.value)

    def visit_Slice(self, node):
        lower = self.visit(node.lower) if node.lower else None
        upper = self.visit(node.upper) if node.upper else None
        step = self.visit(node.step) if node.step else None
        return slice(lower, upper, step)

    def visit_ExtSlice(self, node):
        dims = tuple(self.visit(dim) for dim in node.dims)
        return dims

    def visit_Tuple(self, node):
        return tuple(self.visit(elt) for elt in node.elts)

    def visit_List(self, node):
        return [self.visit(elt) for elt in node.elts]

    def visit_Dict(self, node):
        &#34;&#34;&#34;
        Evaluate a dictionary expression by safely evaluating each key and value.
        This allows expressions like: {&#34;a&#34;: ${v1}+${v2}, &#34;b&#34;: ${var}}.
        &#34;&#34;&#34;
        return {self.visit(key): self.visit(value) for key, value in zip(node.keys, node.values)}

    def generic_visit(self, node):
        raise ValueError(f&#34;Unsupported expression: {ast.dump(node)}&#34;)

    def evaluate(self, expression):
        tree = ast.parse(expression, mode=&#39;eval&#39;)
        return self.visit(tree.body)

# Use SafeEvaluator only to unescaped variables ${var} and expressions ${var1+var2}
# This methodology separates string interpolation from expression evaluation
def evaluate_with_placeholders(text, evaluator, evaluator_nocontext=SafeEvaluator(),raiseerror=False):
    &#34;&#34;&#34;
    Evaluates only unescaped placeholders of the form ${...} in the input text.
    Escaped placeholders (\\${...}) are left as literal text (after removing the escape).

    Note1 : ${ ... } can be ${var} or an expressions such as ${var1+var2}
    Note2 : a full evaluation is attempted only after the full evaluation using the same
    evaluator without context

    Example:

        context = {&#39;a&#39;: 10, &#39;b&#39;: 5}
        evaluator = SafeEvaluator(context)
        evaluator_nocontext = SafeEvaluator()

        text = &#34;Evaluated variable: ${a} and literal: \\${a} and sum: ${a + b}, leave intact a+b, ${a}+${b}&#34;
        processed_text = evaluate_with_placeholders(text, evaluator)
        print(processed_text)

    &#34;&#34;&#34;
    # Pattern explanation:
    #   (?&lt;!\\)   : Negative lookbehind to ensure the &#39;${&#39; is not preceded by a backslash.
    #   (\$\{([^}]+)\}) : Captures the full placeholder in group 1 and the inner expression in group 2.
    pattern = r&#39;(?&lt;!\\)(\$\{([^}]+)\})&#39;

    def replace_placeholder(match):
        # Extract the inner expression from the placeholder.
        expr = match.group(2)
        # Evaluate the expression using your SafeEvaluator instance.
        try:
            value = evaluator.evaluate(expr)
        except Exception as e:
            raise ValueError(f&#34;Error evaluating expression &#39;{expr}&#39;: {e}&#34;)
        return str(value)

    # String Interpolation: Replace unescaped placeholders with their evaluated results.
    result = re.sub(pattern, replace_placeholder, text)
    # Finally, unescape the escaped placeholders: replace &#34;\${&#34; with &#34;${&#34;.
    result = result.replace(r&#39;\${&#39;, &#39;${&#39;)
    # Full evaluation if possible
    if raiseerror:
        return evaluator_nocontext.evaluate(result)
    else:
        try:
            return evaluator_nocontext.evaluate(result)
        except Exception:
            return result


# returns True for literal string starting with &#34;$&#34;
def is_literal_string(s):
    &#34;&#34;&#34;
    Returns True if the first non-blank character in the string is &#39;$&#39;
    and it is not immediately followed by &#39;{&#39; or &#39;[&#39;.

    Parameters:
        s (str): The string to check.

    Returns:
        bool: True if the condition is met, otherwise False.
    &#34;&#34;&#34;
    stripped = s.lstrip()  # Remove leading whitespace
    if not stripped:
        return False
    if stripped[0] != &#39;$&#39;:
        return False
    # If there is a character following &#39;$&#39;, ensure it&#39;s not &#39;{&#39; or &#39;[&#39;.
    if len(stripped) &gt; 1 and stripped[1] in (&#39;{&#39;, &#39;[&#39;):
        return False
    return True

# Class to handle expressions containing operators correctly without being misinterpreted as attribute accesses.
class AttrErrorDict(dict):
    &#34;&#34;&#34;Custom dictionary that raises AttributeError (as required for the logic of struct)
       instead of KeyError for missing keys and strips quotes from strings.&#34;&#34;&#34;
    def __getitem__(self, key):
        try:
            value = super().__getitem__(key)
            if isinstance(value, str):
                # Strip surrounding single or double quotes if present
                if (value.startswith(&#34;&#39;&#34;) and value.endswith(&#34;&#39;&#34;)) or (value.startswith(&#39;&#34;&#39;) and value.endswith(&#39;&#34;&#39;)):
                    return value[1:-1]
                return value
            return value
        except KeyError:
            raise AttributeError(f&#34;Attribute &#39;{key}&#39; not found&#34;)

# A generalized isempty defintion
def is_empty(value):
    &#34;&#34;&#34;Return True if value is considered empty (None, &#34;&#34;, [] or ()).&#34;&#34;&#34;
    return value is None or value == &#34;&#34; or value == [] or value == ()

# %% core struct class
class struct():
    &#34;&#34;&#34;
    Class: `struct`
    ================

    A lightweight class that mimics Matlab-like structures, with additional features
    such as dynamic field creation, indexing, concatenation, and compatibility with
    evaluated parameters (`param`).

    ---

    ### Features
    - Dynamic creation of fields.
    - Indexing and iteration support for fields.
    - Concatenation and subtraction of structures.
    - Conversion to and from dictionaries.
    - Compatible with `param` and `paramauto` for evaluation and dependency handling.

    ---

    ### Examples

    #### Basic Usage
    ```python
    s = struct(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    print(s.a)  # 1
    s.d = 11    # Append a new field
    delattr(s, &#39;d&#39;)  # Delete the field
    ```

    #### Using `param` for Evaluation
    ```python
    p = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    p.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    # --------
    ```

    ---

    ### Concatenation and Subtraction
    Fields from the right-most structure overwrite existing values.
    ```python
    a = struct(a=1, b=2)
    b = struct(c=3, d=&#34;d&#34;, e=&#34;e&#34;)
    c = a + b
    e = c - a
    ```

    ---

    ### Practical Shorthands

    #### Constructing a Structure from Keys
    ```python
    s = struct.fromkeys([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;])
    # Output:
    # --------
    #      a: None
    #      b: None
    #      c: None
    #      d: None
    # --------
    ```

    #### Building a Structure from Variables in a String
    ```python
    s = struct.scan(&#34;${a} + ${b} * ${c} / ${d} --- ${ee}&#34;)
    s.a = 1
    s.b = &#34;test&#34;
    s.c = [1, &#34;a&#34;, 2]
    s.generator()
    # Output:
    # X = struct(
    #      a=1,
    #      b=&#34;test&#34;,
    #      c=[1, &#39;a&#39;, 2],
    #      d=None,
    #      ee=None
    # )
    ```

    #### Indexing and Iteration
    Structures can be indexed or sliced like lists.
    ```python
    c = a + b
    c[0]      # Access the first field
    c[-1]     # Access the last field
    c[:2]     # Slice the structure
    for field in c:
        print(field)
    ```

    ---

    ### Dynamic Dependency Management
    `struct` provides control over dependencies, sorting, and evaluation.

    ```python
    s = struct(d=3, e=&#34;${c} + {d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    s.sortdefinitions()
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}
    #      e: ${c} + ${d}
    # --------
    ```

    For dynamic evaluation, use `param`:
    ```python
    p = param(sortdefinitions=True, d=3, e=&#34;${c} + ${d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}  (= 3)
    #      e: ${c} + ${d}  (= 6)
    # --------
    ```

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two structures (`__add__`).
    - `-`: Subtraction of fields (`__sub__`).
    - `&lt;&lt;`: Import values from another structure (`__lshift__`)
    - `len()`: Number of fields (`__len__`).
    - `in`: Check for field existence (`__contains__`).

    #### Method Overview
    | Method                | Description                                             |
    |-----------------------|---------------------------------------------------------|
    | `check(default)`      | Populate fields with defaults if missing.               |
    | `clear()`             | Remove all fields.                                      |
    | `dict2struct(dico)`   | Create a structure from a dictionary.                   |
    | `disp()`              | Display the structure.                                  |
    | `eval()`              | Evaluate expressions within fields.                     |
    | `fromkeys(keys)`      | Create a structure from a list of keys.                 |
    | `generator()`         | Generate Python code representing the structure.        |
    | `importfrom()`        | Import undefined values from another struct or dict.    |
    | `items()`             | Return key-value pairs.                                 |
    | `keys()`              | Return all keys in the structure.                       |
    | `read(file)`          | Load structure fields from a file.                      |
    | `scan(string)`        | Extract variables from a string and populate fields.    |
    | `sortdefinitions()`   | Sort fields to resolve dependencies.                    |
    | `struct2dict()`       | Convert the structure to a dictionary.                  |
    | `validkeys()`         | Return valid keys                                       |
    | `values()`            | Return all field values.                                |
    | `write(file)`         | Save the structure to a file.                           |

    ---

    ### Dynamic Properties
    | Property    | Description                            |
    |-------------|----------------------------------------|
    | `isempty`   | `True` if the structure is empty.      |
    | `isdefined` | `True` if all fields are defined.      |

    ---
    &#34;&#34;&#34;

    # attributes to be overdefined
    _type = &#34;struct&#34;        # object type
    _fulltype = &#34;structure&#34; # full name
    _ftype = &#34;field&#34;        # field name
    _evalfeature = False    # true if eval() is available
    _maxdisplay = 40        # maximum number of characters to display (should be even)
    _propertyasattribute = False
    _precision = 4
    _needs_sorting = False

    # attributes for the iterator method
    # Please keep it static, duplicate the object before changing _iter_
    _iter_ = 0

    # excluded attributes (keep the , in the Tupple if it is singleton)
    _excludedattr = {&#39;_iter_&#39;,&#39;__class__&#39;,&#39;_protection&#39;,&#39;_evaluation&#39;,&#39;_returnerror&#39;,&#39;_debug&#39;,&#39;_precision&#39;,&#39;_needs_sorting&#39;} # used by keys() and len()


    # Methods
    def __init__(self,debug=False,**kwargs):
        &#34;&#34;&#34; constructor, use debug=True to report eval errors&#34;&#34;&#34;
        # Optionally extend _excludedattr here
        self._excludedattr = self._excludedattr | {&#39;_excludedattr&#39;, &#39;_type&#39;, &#39;_fulltype&#39;,&#39;_ftype&#39;} # addition 2024-10-11
        self._debug = debug
        self.set(**kwargs)

    def zip(self):
        &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
        return zip(self.keys(),self.values())

    @staticmethod
    def dict2struct(dico,makeparam=False):
        &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
        if isinstance(dico,dict):
            s = param() if makeparam else struct()
            s.set(**dico)
            return s
        raise TypeError(&#34;the argument must be a dictionary&#34;)

    def struct2dict(self):
        &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
        return dict(self.zip())

    def struct2param(self,protection=False,evaluation=True):
        &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
        p = param(**self.struct2dict())
        for i in range(len(self)):
            if isinstance(self[i],pstr): p[i] = pstr(p[i])
        p._protection = protection
        p._evaluation = evaluation
        return p

    def set(self,**kwargs):
        &#34;&#34;&#34; initialization &#34;&#34;&#34;
        self.__dict__.update(kwargs)

    def setattr(self,key,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0 and key in self:
            delattr(self, key)
        else:
            self.__dict__[key] = value

    def getattr(self,key):
        &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
        if key in self.__dict__:
            return self.__dict__[key]
        elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
             key not in self._excludedattr and \
             key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
            # If _propertyasattribute is True and it&#39;s a property, get its value
            return self.__class__.__dict__[key].fget(self)
        else:
            raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)

    def hasattr(self, key):
        &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
        return key in self.__dict__ or (
            getattr(self, &#39;_propertyasattribute&#39;, False) and
            key not in self._excludedattr and
            key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
        )

    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return pstr.eval(self.getattr(key))

    def __setattr__(self,key,value):
        &#34;&#34;&#34; set attribute override &#34;&#34;&#34;
        self.setattr(key,value)

    def __contains__(self,item):
        &#34;&#34;&#34; in override &#34;&#34;&#34;
        return self.hasattr(item)

    def keys(self):
        &#34;&#34;&#34; return the fields &#34;&#34;&#34;
        # keys() is used by struct() and its iterator
        return [key for key in self.__dict__.keys() if key not in self._excludedattr]

    def keyssorted(self,reverse=True):
        &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
        klist = self.keys()
        l = [len(k) for k in klist]
        return [k for _,k in sorted(zip(l,klist),reverse=reverse)]

    def values(self):
        &#34;&#34;&#34; return the values &#34;&#34;&#34;
        # values() is used by struct() and its iterator
        return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]

    @staticmethod
    def fromkeysvalues(keys,values,makeparam=False):
        &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
            use makeparam = True to create a param instead of struct
        &#34;&#34;&#34;
        if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
        if not isinstance(keys,_list_types): keys = [keys]
        if not isinstance(values,_list_types): values = [values]
        nk,nv = len(keys), len(values)
        s = param() if makeparam else struct()
        if nk&gt;0 and nv&gt;0:
            iv = 0
            for ik in range(nk):
                s.setattr(keys[ik], values[iv])
                iv = min(nv-1,iv+1)
            for ik in range(nk,nv):
                s.setattr(f&#34;key{ik}&#34;, values[ik])
        return s

    def items(self):
        &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
        return self.zip()

    def __getitem__(self,idx):
        &#34;&#34;&#34;
            s[i] returns the ith element of the structure
            s[:4] returns a structure with the four first fields
            s[[1,3]] returns the second and fourth elements
        &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                return self.getattr(self.keys()[idx])
            raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            out = struct.fromkeysvalues(self.keys()[idx], self.values()[idx])
            if isinstance(self,paramauto):
                return paramauto(**out)
            elif isinstance(self,param):
                return param(**out)
            else:
                return out
        elif isinstance(idx,(list,tuple)):
            k,v= self.keys(), self.values()
            nk = len(k)
            s = param() if isinstance(self,param) else struct()
            for i in idx:
                if isinstance(i,int):
                    if -nk &lt;= i &lt; nk:  # Allow standard Python negative indexing
                        i = i % nk  # Convert negative index to positive equivalent
                        s.setattr(k[i],v[i])
                    else:
                        raise IndexError(f&#34;idx must contain integers in range [-{nk}, {nk-1}], not {i}&#34;)
                elif isinstance(i,str):
                    if i in self:
                        s.setattr(i, self.getattr(i))
                    else:
                        raise KeyError((f&#39;idx &#34;{idx}&#34; is not a valid key&#39;))
                else:
                    TypeError(&#34;idx must contain only integers or strings&#34;)
            return s
        elif isinstance(idx,str):
            return self.getattr(idx)
        else:
            raise TypeError(&#34;The index must be an integer or a slice and not a %s&#34; % type(idx).__name__)

    def __setitem__(self,idx,value):
        &#34;&#34;&#34; set the ith element of the structure  &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                self.setattr(self.keys()[idx], value)
            else:
                raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            k = self.keys()[idx]
            if len(value)&lt;=1:
                for i in range(len(k)): self.setattr(k[i], value)
            elif len(k) == len(value):
                for i in range(len(k)): self.setattr(k[i], value[i])
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of elements in the slice (%d)&#34; \
                       % (len(value),len(idx)))
        elif isinstance(idx,(list,tuple)):
            if len(value)&lt;=1:
                for i in range(len(idx)): self[idx[i]]=value
            elif len(idx) == len(value):
                for i in range(len(idx)): self[idx[i]]=value[i]
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of indices (%d)&#34; \
                                 % (len(value),len(idx)))

    def __len__(self):
        &#34;&#34;&#34; return the number of fields &#34;&#34;&#34;
        # len() is used by struct() and its iterator
        return len(self.keys())

    def __iter__(self):
        &#34;&#34;&#34; struct iterator &#34;&#34;&#34;
        # note that in the original object _iter_ is a static property not in dup
        dup = duplicate(self)
        dup._iter_ = 0
        return dup

    def __next__(self):
        &#34;&#34;&#34; increment iterator &#34;&#34;&#34;
        self._iter_ += 1
        if self._iter_&lt;=len(self):
            return self[self._iter_-1]
        self._iter_ = 0
        raise StopIteration(f&#34;Maximum {self._ftype} iteration reached {len(self)}&#34;)

    def __add__(self, s, sortdefinitions=False, raiseerror=True, silentmode=True):
        &#34;&#34;&#34;
        Add two structure objects, with precedence as follows:

          paramauto &gt; param &gt; struct

        In c = a + b, if b has a higher precedence than a then c will be of b&#39;s class,
        otherwise it will be of a&#39;s class.

        The new instance is created by copying the fields from the left-hand operand (a)
        and then updating with the fields from the right-hand operand (b).

        If self or s is of class paramauto, the current state of _needs_sorting is propagated
        but not forced to be true.

        &#34;&#34;&#34;
        if not isinstance(s, struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)

        # Define a helper to assign a precedence value.
        def get_precedence(obj):
            if isinstance(obj, paramauto):
                return 2
            elif isinstance(obj, param):
                return 1
            elif isinstance(obj, struct):
                return 0
            else:
                return 0  # fallback for unknown derivations

        # current classes
        leftprecedence = get_precedence(self)
        rightprecedence = get_precedence(s)
        # Determine which class to use for the duplicate.
        # If s (b) has a higher precedence than self (a), use s&#39;s class; otherwise, use self&#39;s.
        hi_class = self.__class__ if leftprecedence &gt;= rightprecedence else s.__class__
        # Create a new instance of the chosen class by copying self&#39;s fields.
        dup = hi_class(**self)
        # Update with the fields from s.
        dup.update(**s)
        if sortdefinitions: # defer sorting by preserving the state of _needs_sorting
            if leftprecedence &lt; rightprecedence == 2: # left is promoted
                dup._needs_sorting = s._needs_sorting
            elif rightprecedence &lt; leftprecedence == 2: # right is promoted
                dup._needs_sorting = self._needs_sorting
            elif leftprecedence == rightprecedence == 2: # left and right are equivalent
                dup._needs_sorting = self._needs_sorting or s._needs_sorting
            # dup.sortdefinitions(raiseerror=raiseerror, silentmode=silentmode)
        return dup

    def __iadd__(self,s,sortdefinitions=False,raiseerror=False, silentmode=True):
        &#34;&#34;&#34; iadd a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        self.update(**s)
        if sortdefinitions:
            self._needs_sorting = True
            # self.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return self

    def __sub__(self,s):
        &#34;&#34;&#34; sub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        listofkeys = dup.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(dup,k)
        return dup

    def __isub__(self,s):
        &#34;&#34;&#34; isub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        listofkeys = self.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(self,k)
        return self

    def dispmax(self,content):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        if len(strcontent)&gt;self._maxdisplay:
            nchar = round(self._maxdisplay/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content

    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        if self.__dict__=={}:
            print(f&#34;empty {self._fulltype} ({self._type} object) with no {self._type}s&#34;)
            return f&#34;empty {self._fulltype}&#34;
        else:
            numfmt = f&#34;.{self._precision}g&#34;
            tmp = self.eval() if self._evalfeature else []
            keylengths = [len(key) for key in self.__dict__]
            width = max(10,max(keylengths)+2)
            fmt = &#34;%%%ss:&#34; % width
            fmteval = fmt[:-1]+&#34;=&#34;
            fmtcls =  fmt[:-1]+&#34;:&#34;
            line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
            print(line)
            for key,value in self.__dict__.items():
                if key not in self._excludedattr:
                    if isinstance(value,_numeric_types):
                        # old code (removed on 2025-01-18)
                        # if isinstance(value,pstr):
                        #     print(fmt % key,&#39;p&#34;&#39;+self.dispmax(value)+&#39;&#34;&#39;)
                        # if isinstance(value,str) and value==&#34;&#34;:
                        #     print(fmt % key,&#39;&#34;&#34;&#39;)
                        # else:
                        #     print(fmt % key,self.dispmax(value))
                        if isinstance(value,np.ndarray):
                            print(fmt % key, struct.format_array(value,numfmt=numfmt))
                        else:
                            print(fmt % key,self.dispmax(value))
                    elif isinstance(value,struct):
                        print(fmt % key,self.dispmax(value.__str__()))
                    elif isinstance(value,(type,dict)):
                        print(fmt % key,self.dispmax(str(value)))
                    else:
                        print(fmt % key,type(value))
                        print(fmtcls % &#34;&#34;,self.dispmax(str(value)))
                    if self._evalfeature:
                        if isinstance(self,paramauto):
                            try:
                                if isinstance(value,pstr):
                                    print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                                elif isinstance(value,str):
                                    if value == &#34;&#34;:
                                        print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                    else:
                                        print(fmteval % &#34;&#34;,self.dispmax(tmp.getattr(key)))
                            except Exception as err:
                                print(fmteval % &#34;&#34;,err.message, err.args)
                        else:
                            if isinstance(value,pstr):
                                print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                            elif isinstance(value,str):
                                if value == &#34;&#34;:
                                    print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                else:
                                    calcvalue =tmp.getattr(key)
                                    if isinstance(calcvalue, str) and &#34;error&#34; in calcvalue.lower():
                                        print(fmteval % &#34;&#34;,calcvalue)
                                    else:
                                        if isinstance(calcvalue,np.ndarray):
                                            print(fmteval % &#34;&#34;, struct.format_array(calcvalue,numfmt=numfmt))
                                        else:
                                            print(fmteval % &#34;&#34;,self.dispmax(calcvalue))
                            elif isinstance(value,list):
                                calcvalue =tmp.getattr(key)
                                print(fmteval % &#34;&#34;,self.dispmax(str(calcvalue)))
            print(line)
            return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    def disp(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        self.__repr__()

    def __str__(self):
        return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    @property
    def isempty(self):
        &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
        return len(self)==0

    def clear(self):
        &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
        for k in self.keys(): delattr(self,k)

    def format(self, s, escape=False, raiseerror=True):
        &#34;&#34;&#34;
            Format a string with fields using {field} as placeholders.
            Handles expressions like ${variable1}.

            Args:
                s (str): The input string to format.
                escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
                raiseerror (bool): If True, raises errors for missing fields.

            Note:
                NumPy vectors and matrices are converted into their text representation (default behavior)
                If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

            Returns:
                str: The formatted string.
        &#34;&#34;&#34;
        tmp = self.np2str()
        if raiseerror:
            try:
                if escape:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.format_map(AttrErrorDict(self.__dict__))
                else:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
            except AttributeError as attr_err:
                # Handle AttributeError for expressions with operators
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                if self._debug:
                    print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
                return s_  # Revert to using &#39;${&#39; for unresolved expressions
            except IndexError as idx_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                if self._debug:
                    print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
                raise IndexError from idx_err
            except Exception as other_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                raise RuntimeError from other_err
        else:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except:  # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))

    def format_legacy(self,s,escape=False,raiseerror=True):
        &#34;&#34;&#34;
            format a string with field (use {field} as placeholders)
                s.replace(string), s.replace(string,escape=True)
                where:
                    s is a struct object
                    string is a string with possibly ${variable1}
                    escape is a flag to prevent ${} replaced by {}
        &#34;&#34;&#34;
        if raiseerror:
            try:
                if escape:
                    return s.format(**self.__dict__)
                else:
                    return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
            except KeyError as kerr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
                return s_ # instead of s (we put back $) - OV 2023/01/27
            except Exception as othererr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                raise RuntimeError from othererr
        else:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)

    def fromkeys(self,keys):
        &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
        return self+struct(**dict.fromkeys(keys,None))

    @staticmethod
    def scan(s):
        &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
        tmp = struct()
        #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
        found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
        uniq = []
        for x in found:
            if x not in uniq: uniq.append(x)
        return tmp.fromkeys(uniq)

    @staticmethod
    def isstrexpression(s):
        &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        return re.search(r&#34;\$\{.*?\}&#34;,s) is not None

    @property
    def isexpression(self):
        &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        for k,v in self.items():
            if isinstance(v,str):
                s.setattr(k,struct.isstrexpression(v))
            else:
                s.setattr(k,False)
        return s

    @staticmethod
    def isstrdefined(s,ref):
        &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        if struct.isstrexpression(s):
            k = struct.scan(s).keys()
            allfound,i,nk = True,0,len(k)
            while (i&lt;nk) and allfound:
                allfound = k[i] in ref
                i += 1
            return allfound
        else:
            return False


    def isdefined(self,ref=None):
        &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
        nk = len(k)
        if ref is None:
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
                else:
                    s.setattr(k[i],True)
        else:
            if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],ref))
                else:
                    s.setattr(k[i],True)
        return s


    def sortdefinitions(self,raiseerror=True,silentmode=False):
        &#34;&#34;&#34; sortdefintions sorts all definitions
            so that they can be executed as param().
            If any inconsistency is found, an error message is generated.

            Flags = default values
                raiseerror=True show erros of True
                silentmode=False no warning if True
        &#34;&#34;&#34;
        find = lambda xlist: [i for i, x in enumerate(xlist) if x]
        findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
        k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
        istatic = findnot(isexpr)
        idynamic = find(isexpr)
        static = struct.fromkeysvalues(
            [ k[i] for i in istatic ],
            [ v[i] for i in istatic ],
            makeparam = False)
        dynamic = struct.fromkeysvalues(
            [ k[i] for i in idynamic ],
            [ v[i] for i in idynamic ],
            makeparam=False)
        current = static # make static the current structure
        nmissing, anychange, errorfound = len(dynamic), False, False
        while nmissing:
            itst, found = 0, False
            while itst&lt;nmissing and not found:
                teststruct = current + dynamic[[itst]] # add the test field
                found = all(list(teststruct.isdefined()))
                ifound = itst
                itst += 1
            if found:
                current = teststruct # we accept the new field
                dynamic[ifound] = []
                nmissing -= 1
                anychange = True
            else:
                if raiseerror:
                    raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                                   (nmissing,len(self),self._ftype))
                else:
                    if (not errorfound) and (not silentmode):
                        print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                              (nmissing,len(self),self._ftype))
                    current = teststruct # we accept the new field (even if it cannot be interpreted)
                    dynamic[ifound] = []
                    nmissing -= 1
                    errorfound = True
        if anychange:
            self.clear() # reset all fields and assign them in the proper order
            k,v = current.keys(), current.values()
            for i in range(len(k)):
                self.setattr(k[i],v[i])


    def generator(self, printout=False):
        &#34;&#34;&#34;
        Generate Python code of the equivalent structure.

        This method converts the current structure (an instance of `param`, `paramauto`, or `struct`)
        into Python code that, when executed, recreates an equivalent structure. The generated code is
        formatted with one field per line.

        By default (when `printout` is False), the generated code is returned as a raw string that starts
        directly with, for example, `param(` (or `paramauto(` or `struct(`), with no &#34;X = &#34; prefix or leading
        newline. When `printout` is True, the generated code is printed to standard output and includes a prefix
        &#34;X = &#34; to indicate the variable name.

        Parameters:
            printout (bool): If True, the generated code is printed to standard output with the &#34;X = &#34; prefix.
                             If False (default), the code is returned as a raw string starting with, e.g.,
                             `param(`.

        Returns:
            str: The generated Python code representing the structure (regardless of whether it was printed).
        &#34;&#34;&#34;
        nk = len(self)
        tmp = self.np2str()
        # Compute the field format based on the maximum key length (with a minimum width of 10)
        fmt = &#34;%%%ss =&#34; % max(10, max([len(k) for k in self.keys()]) + 2)
        # Determine the appropriate class string for the current instance.
        if isinstance(self, param):
            classstr = &#34;param&#34;
        elif &#39;paramauto&#39; in globals() and isinstance(self, paramauto):
            classstr = &#34;paramauto&#34;
        else:
            classstr = &#34;struct&#34;

        lines = []
        if nk == 0:
            # For an empty structure.
            if printout:
                lines.append(f&#34;X = {classstr}()&#34;)
            else:
                lines.append(f&#34;{classstr}()&#34;)
        else:
            # Header: include &#34;X = &#34; only if printing.
            if printout:
                header = f&#34;X = {classstr}(&#34;
            else:
                header = f&#34;{classstr}(&#34;
            lines.append(header)
            # Iterate over keys to generate each field line.
            for i, k in enumerate(self.keys()):
                v = getattr(self, k)
                if isinstance(v, np.ndarray):
                    vtmp = getattr(tmp, k)
                    field = fmt % k + &#34; &#34; + vtmp
                elif isinstance(v, (int, float)) or v is None:
                    field = fmt % k + &#34; &#34; + str(v)
                elif isinstance(v, str):
                    field = fmt % k + &#34; &#34; + f&#39;&#34;{v}&#34;&#39;
                elif isinstance(v, (list, tuple, dict)):
                    field = fmt % k + &#34; &#34; + str(v)
                else:
                    field = fmt % k + &#34; &#34; + &#34;/* unsupported type */&#34;
                # Append a comma after each field except the last one.
                if i &lt; nk - 1:
                    field += &#34;,&#34;
                lines.append(field)
            # Create a closing line that aligns the closing parenthesis.
            closing_line = fmt[:-1] % &#34;)&#34;
            lines.append(closing_line)
        result = &#34;\n&#34;.join(lines)
        if printout:
            print(result)
            return None
        return result


    # copy and deep copy methpds for the class
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, duplicatedeep(v, memo))
        return copie


    # write a file
    def write(self, file, overwrite=True, mkdir=False):
        &#34;&#34;&#34;
            write the equivalent structure (not recursive for nested struct)
                write(filename, overwrite=True, mkdir=False)

            Parameters:
            - file: The file path to write to.
            - overwrite: Whether to overwrite the file if it exists (default: True).
            - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()

        # Check if the directory exists or if mkdir is set to True, create it
        if mkdir:
            file_path.parent.mkdir(parents=True, exist_ok=True)
        elif not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If overwrite is False and the file already exists, raise an exception
        if not overwrite and file_path.exists():
            raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
        # Convert to static if needed
        if isinstance(p,(param,paramauto)):
            tmp = self.tostatic()
        else:
            tmp = self
        # Open and write to the file using the resolved path
        with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
            print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
            for k, v in tmp.items():
                if v is None:
                    print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
                elif isinstance(v, (int, float)):
                    print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
                elif isinstance(v, str):
                    print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
                else:
                    print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)


    # read a file
    @staticmethod
    def read(file):
        &#34;&#34;&#34;
            read the equivalent structure
                read(filename)

            Parameters:
            - file: The file path to read from.
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()
        # Check if the parent directory exists, otherwise raise an error
        if not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If the file does not exist, raise an exception
        if not file_path.exists():
            raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
        # Open and read the file
        with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
            s = struct()  # Assuming struct is defined elsewhere
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                expr = line.split(sep=&#34;=&#34;)
                if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                    lhs = expr[0]
                    rhs = &#34;&#34;.join(expr[1:]).strip()
                    if len(rhs) == 0 or rhs == &#34;None&#34;:
                        v = None
                    else:
                        v = eval(rhs)
                    s.setattr(lhs, v)
        return s

    # argcheck
    def check(self,default):
        &#34;&#34;&#34;
        populate fields from a default structure
            check(defaultstruct)
            missing field, None and [] values are replaced by default ones

            Note: a.check(b) is equivalent to b+a except for [] and None values
        &#34;&#34;&#34;
        if not isinstance(default,struct):
            raise TypeError(&#34;the first argument must be a structure&#34;)
        for f in default.keys():
            ref = default.getattr(f)
            if f not in self:
                self.setattr(f, ref)
            else:
                current = self.getattr(f)
                if ((current is None)  or (current==[])) and \
                    ((ref is not None) and (ref!=[])):
                        self.setattr(f, ref)


    # update values based on key:value
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update multiple fields at once, while protecting certain attributes.

        Parameters:
        -----------
        **kwargs : dict
            The fields to update and their new values.

        Protected attributes defined in _excludedattr are not updated.

        Usage:
        ------
        s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
        &#34;&#34;&#34;
        protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())
        for key, value in kwargs.items():
            if key in protected_attributes:
                print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
            else:
                self.setattr(key, value)


    # override () for subindexing structure with key names
    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extract a sub-structure based on the specified keys,
        keeping the same class type.

        Parameters:
        -----------
        *keys : str
            The keys for the fields to include in the sub-structure.

        Returns:
        --------
        struct
            A new instance of the same class as the original, containing
            only the specified keys.

        Usage:
        ------
        sub_struct = s(&#39;key1&#39;, &#39;key2&#39;, ...)
        &#34;&#34;&#34;
        # Create a new instance of the same class
        sub_struct = self.__class__()

        # Get the full type and field type for error messages
        fulltype = getattr(self, &#39;_fulltype&#39;, &#39;structure&#39;)
        ftype = getattr(self, &#39;_ftype&#39;, &#39;field&#39;)

        # Add only the specified keys to the new sub-structure
        for key in keys:
            if key in self:
                sub_struct.setattr(key, self.getattr(key))
            else:
                raise KeyError(f&#34;{fulltype} does not contain the {ftype} &#39;{key}&#39;.&#34;)

        return sub_struct


    def __delattr__(self, key):
        &#34;&#34;&#34; Delete an instance attribute if it exists and is not a class or excluded attribute. &#34;&#34;&#34;
        if key in self._excludedattr:
            raise AttributeError(f&#34;Cannot delete excluded attribute &#39;{key}&#39;&#34;)
        elif key in self.__class__.__dict__:  # Check if it&#39;s a class attribute
            raise AttributeError(f&#34;Cannot delete class attribute &#39;{key}&#39;&#34;)
        elif key in self.__dict__:  # Delete only if in instance&#39;s __dict__
            del self.__dict__[key]
        else:
            raise AttributeError(f&#34;{self._type} has no attribute &#39;{key}&#39;&#34;)


    # A la Matlab display method of vectors, matrices and ND-arrays
    @staticmethod
    def format_array(value,numfmt=&#34;.4g&#34;):
        &#34;&#34;&#34;
        Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
        Recursively formats multi-dimensional arrays without introducing unwanted commas.

        Args:
            value (np.ndarray): The NumPy array to format.
            numfmt: numeric format to be used for the string conversion (default=&#34;.4g&#34;)

        Returns:
            str: A formatted string representation of the array.
        &#34;&#34;&#34;
        dtype_str = {
            np.float64: &#34;double&#34;,
            np.float32: &#34;single&#34;,
            np.int32: &#34;int32&#34;,
            np.int64: &#34;int64&#34;,
            np.complex64: &#34;complex single&#34;,
            np.complex128: &#34;complex double&#34;,
        }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

        max_display = 10  # Maximum number of elements to display

        def format_recursive(arr):
            &#34;&#34;&#34;
            Recursively formats the array based on its dimensions.

            Args:
                arr (np.ndarray): The array or sub-array to format.

            Returns:
                str: Formatted string of the array.
            &#34;&#34;&#34;
            if arr.ndim == 0:
                return f&#34;{arr.item()}&#34;

            if arr.ndim == 1:
                if len(arr) &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr) + &#34;]&#34;
                else:
                    return f&#34;[{len(arr)} elements]&#34;

            if arr.ndim == 2:
                if arr.shape[1] == 1:
                    # Column vector
                    if arr.shape[0] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in arr) + &#34;]T&#34;
                    else:
                        return f&#34;[{arr.shape[0]}×1 vector]&#34;
                elif arr.shape[0] == 1:
                    # Row vector
                    if arr.shape[1] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr[0]) + &#34;]&#34;
                    else:
                        return f&#34;[1×{arr.shape[1]} vector]&#34;
                else:
                    # General matrix
                    return f&#34;[{arr.shape[0]}×{arr.shape[1]} matrix]&#34;

            # For higher dimensions
            shape_str = &#34;×&#34;.join(map(str, arr.shape))
            if arr.size &lt;= max_display:
                # Show full content
                if arr.ndim &gt; 2:
                    # Represent multi-dimensional arrays with nested brackets
                    return &#34;[&#34; + &#34; &#34;.join(format_recursive(subarr) for subarr in arr) + f&#34;] ({shape_str} {dtype_str})&#34;
            return f&#34;[{shape_str} array ({dtype_str})]&#34;

        if value.size == 0:
            return &#34;[]&#34;

        if value.ndim == 0 or value.size == 1:
            return f&#34;{value.item()} ({dtype_str})&#34;

        if value.ndim == 1 or value.ndim == 2:
            # Use existing logic for vectors and matrices
            if value.ndim == 1:
                if len(value) &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{len(value)}×1 {dtype_str}]&#34;
            elif value.ndim == 2:
                rows, cols = value.shape
                if cols == 1:  # Column vector
                    if rows &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[{rows}×1 {dtype_str}]&#34;
                elif rows == 1:  # Row vector
                    if cols &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[1×{cols} {dtype_str}]&#34;
                else:  # General matrix
                    formatted = f&#34;[{rows}×{cols} {dtype_str}]&#34;
            return formatted

        # For higher-dimensional arrays
        if value.size &lt;= max_display:
            formatted = format_recursive(value)
        else:
            shape_str = &#34;×&#34;.join(map(str, value.shape))
            formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

        return formatted


    # convert all NumPy entries to &#34;nestable&#34; expressions
    def np2str(self):
        &#34;&#34;&#34; Convert all NumPy entries of s into their string representations, handling both lists and dictionaries. &#34;&#34;&#34;
        out = struct()
        def format_numpy_result(value):
            &#34;&#34;&#34;
            Converts a NumPy array or scalar into a string representation:
            - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
            - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
            - If the value is a list or dict, the conversion is applied recursively.
            - Non-ndarray inputs that are not list/dict are returned without modification.

            Args:
                value (np.ndarray, scalar, list, dict, or other): The value to format.

            Returns:
                str, list, dict, or original type: A properly formatted string for NumPy arrays/scalars,
                a recursively converted list/dict, or the original value.
            &#34;&#34;&#34;
            if isinstance(value, dict):
                # Recursively process each key in the dictionary.
                new_dict = {}
                for k, v in value.items():
                    new_dict[k] = format_numpy_result(v)
                return new_dict
            elif isinstance(value, list):
                # Recursively process each element in the list.
                return [format_numpy_result(x) for x in value]
            elif isinstance(value, tuple):
                return tuple(format_numpy_result(x) for x in value)
            elif isinstance(value, struct):
                return value.npstr()
            elif np.isscalar(value):
                # For scalars: if numeric, use str() to avoid extra quotes.
                if isinstance(value, (int, float, complex, str)) or value is None:
                    return value
                else:
                    return repr(value)
            elif isinstance(value, np.ndarray):
                # Check if the array has exactly one element.
                if value.size == 1:
                    # Extract the scalar value.
                    return repr(value.item())
                # Convert the array to a nested list.
                nested_list = value.tolist()
                # Recursively format the nested list into a valid string.
                def list_to_string(lst):
                    if isinstance(lst, list):
                        return &#34;[&#34; + &#34;,&#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                    else:
                        return repr(lst)
                return list_to_string(nested_list)
            else:
                # Return the input unmodified if not a NumPy array, list, dict, or scalar.
                return str(value) # str() preferred over repr() for concision
        # Process all entries in self.
        for key, value in self.items():
            out.setattr(key, format_numpy_result(value))
        return out

    # minimal replacement of placeholders by numbers or their string representations
    def numrepl(self, text):
        r&#34;&#34;&#34;
        Replace all placeholders of the form ${key} in the given text by the corresponding
        numeric value from the instance fields, under the following conditions:

        1. &#39;key&#39; must be a valid field in self (i.e., if key in self).
        2. The value corresponding to &#39;key&#39; is either:
             - an int,
             - a float, or
             - a string that represents a valid number (e.g., &#34;1&#34; or &#34;1.0&#34;).

        Only when these conditions are met, the placeholder is substituted.
        The conversion preserves the original type: if the stored value is int, then the
        substitution will be done as an integer (e.g., 1 and not 1.0). Otherwise, if it is
        a float then it will be substituted as a float.

        Any placeholder for which the above conditions are not met remains unchanged.

        Placeholders are recognized by the pattern &#34;${&lt;key&gt;}&#34; where &lt;key&gt; is captured as all
        text until the next &#34;}&#34; (optionally allowing whitespace inside the braces).
        &#34;&#34;&#34;
        # Pattern: match &#34;${&#34;, then optional whitespace, capture all characters until &#34;}&#34;,
        # then optional whitespace, then &#34;}&#34;.
        placeholder_pattern = re.compile(r&#34;\$\{\s*([^}]+?)\s*\}&#34;)

        def replace_match(match):
            key = match.group(1)
            # Check if the key exists in self.
            if key in self:
                value = self[key]
                # If the value is already numeric, substitute directly.
                if isinstance(value, (int, float)):
                    return str(value)
                # If the value is a string, try to interpret it as a numeric value.
                elif isinstance(value, str):
                    s = value.strip()
                    # Check if s is a valid integer representation.
                    if re.fullmatch(r&#34;[+-]?\d+&#34;, s):
                        try:
                            num = int(s)
                            return str(num)
                        except ValueError:
                            # Should not occur because the regex already matched.
                            return match.group(0)
                    # Check if s is a valid float representation (including scientific notation).
                    elif re.fullmatch(r&#34;[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?&#34;, s):
                        try:
                            num = float(s)
                            return str(num)
                        except ValueError:
                            return match.group(0)
            # If key not in self or value is not numeric (or numeric string), leave placeholder intact.
            return match.group(0)

        # Replace all placeholders in the text using the replacer function.
        return placeholder_pattern.sub(replace_match, text)

    # import method
    def importfrom(self, s, nonempty=True, replacedefaultvar=True):
        &#34;&#34;&#34;
        Import values from &#39;s&#39; into self according to the following rules:

        - Only fields that already exist in self are considered.
        - If s is a dictionary, it is converted to a struct via struct(**s).
        - If the current value of a field in self is empty (None, &#34;&#34;, [] or ()),
          then that field is updated from s.
        - If nonempty is True (default), then only non-empty values from s are imported.
        - If replacedefaultvar is True (default), then if a field in self exactly equals
          &#34;${key}&#34; (with key being the field name), it is replaced by the corresponding
          value from s if it is empty.
        - Raises a TypeError if s is not a dict or struct (i.e. if it doesn’t support keys()).
        &#34;&#34;&#34;
        # If s is a dictionary, convert it to a struct instance.
        if isinstance(s, dict):
            s = struct(**s)
        elif not hasattr(s, &#34;keys&#34;):
            raise TypeError(f&#34;s must be a struct or a dictionary not a type {type(s).__name__}&#34;)

        for key in self.keys():
            if key in s:
                s_value = getattr(s, key)
                current_value = getattr(self, key)
                if is_empty(current_value) or (replacedefaultvar and current_value == &#34;${&#34; + key + &#34;}&#34;):
                    if nonempty:
                        if not is_empty(s_value):
                            setattr(self, key, s_value)
                    else:
                        setattr(self, key, s_value)

    # importfrom with copy
    def __lshift__(self, other):
        &#34;&#34;&#34;
        Allows the syntax:

            s = s1 &lt;&lt; s2

        where a new instance is created as a copy of s1 (preserving its type, whether
        struct, param, or paramauto) and then updated with the values from s2 using
        importfrom.
        &#34;&#34;&#34;
        # Create a new instance preserving the type of self.
        new_instance = type(self)(**{k: getattr(self, k) for k in self.keys()})
        # Import values from other (s2) into the new instance.
        new_instance.importfrom(other)
        return new_instance

    # returns only valid keys
    def validkeys(self, list_of_keys):
        &#34;&#34;&#34;
        Validate and return the subset of keys from the provided list that are valid in the instance.

        Parameters:
        -----------
        list_of_keys : list
            A list of keys (as strings) to check against the instance’s attributes.

        Returns:
        --------
        list
            A list of keys from list_of_keys that are valid (i.e., exist as attributes in the instance).

        Raises:
        -------
        TypeError
            If list_of_keys is not a list or if any element in list_of_keys is not a string.

        Example:
        --------
        &gt;&gt;&gt; s = struct()
        &gt;&gt;&gt; s.foo = 42
        &gt;&gt;&gt; s.bar = &#34;hello&#34;
        &gt;&gt;&gt; valid = s.validkeys([&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;])
        &gt;&gt;&gt; print(valid)   # Output: [&#39;foo&#39;, &#39;bar&#39;] assuming &#39;baz&#39; is not defined in s
        &#34;&#34;&#34;
        # Check that list_of_keys is a list
        if not isinstance(list_of_keys, list):
            raise TypeError(&#34;list_of_keys must be a list&#34;)

        # Check that every entry in the list is a string
        for key in list_of_keys:
            if not isinstance(key, str):
                raise TypeError(&#34;Each key in list_of_keys must be a string&#34;)

        # Assuming valid keys are those present in the instance&#39;s __dict__
        return [key for key in list_of_keys if key in self]

# %% param class with scripting and evaluation capabilities
class param(struct):
    &#34;&#34;&#34;
    Class: `param`
    ==============

    A class derived from `struct` that introduces dynamic evaluation of field values.
    The `param` class acts as a container for evaluated parameters, allowing expressions
    to depend on other fields. It supports advanced evaluation, sorting of dependencies,
    and text formatting.

    ---

    ### Features
    - Inherits all functionalities of `struct`.
    - Supports dynamic evaluation of field expressions.
    - Automatically resolves dependencies between fields.
    - Includes utility methods for text formatting and evaluation.

    ### Shorthands for `p=param(...)`
    - `s = p.eval()` returns the full evaluated structure
    - `p.getval(&#34;field&#34;)` returns the evaluation for the field &#34;field&#34;
    - `s = p()` returns the full evaluated structure as `p.eval()`
    - `s = p(&#34;field1&#34;,&#34;field2&#34;...)` returns the evaluated substructure for fields &#34;field1&#34;, &#34;field2&#34;

    ---

    ### Examples

    #### Basic Usage with Evaluation
    ```python
    s = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;, d=&#34;$this is a string&#34;, e=&#34;1000 # this is my number&#34;)
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------

    s.a = 10
    s.eval()
    # Output:
    # --------
    #      a: 10
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 12)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------
    ```

    #### Handling Text Parameters
    ```python
    s = param()
    s.mypath = &#34;$/this/folder&#34;
    s.myfile = &#34;$file&#34;
    s.myext = &#34;$ext&#34;
    s.fullfile = &#34;$${mypath}/${myfile}.${myext}&#34;
    s.eval()
    # Output:
    # --------
    #    mypath: $/this/folder (= /this/folder)
    #    myfile: $file (= file)
    #     myext: $ext (= ext)
    #  fullfile: $${mypath}/${myfile}.${myext} (= /this/folder/file.ext)
    # --------
    ```

    ---

    ### Text Evaluation and Formatting

    #### Evaluate Strings
    ```python
    s = param(a=1, b=2)
    result = s.eval(&#34;this is a string with ${a} and ${b}&#34;)
    print(result)  # &#34;this is a string with 1 and 2&#34;
    ```

    #### Prevent Evaluation
    ```python
    definitions = param(a=1, b=&#34;${a}*10+${a}&#34;, c=&#34;\\${a}+10&#34;, d=&#39;\\${myparam}&#39;)
    text = definitions.formateval(&#34;this is my text ${a}, ${b}, \\${myvar}=${c}+${d}&#34;)
    print(text)  # &#34;this is my text 1, 11, \\${myvar}=\\${a}+10+${myparam}&#34;
    ```

    ---

    ### Advanced Usage

    #### Rearranging and Sorting Definitions
    ```python
    s = param(
        a=1,
        f=&#34;${e}/3&#34;,
        e=&#34;${a}*${c}&#34;,
        c=&#34;${a}+${b}&#34;,
        b=2,
        d=&#34;${c}*2&#34;
    )
    s.sortdefinitions()
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} (= 3)
    #      d: ${c} * 2 (= 6)
    #      e: ${a} * ${c} (= 3)
    #      f: ${e} / 3 (= 1.0)
    # --------
    ```

    #### Internal Evaluation and Recursion with !
    ```python
    p=param()
    p.a = [0,1,2]
    p.b = &#39;![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]&#39;
    p
    # Output:
    #  -------------:----------------------------------------
    #          a: [0, 1, 2]
    #          b: ![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]
    #           = [1, 2, &#39;test&#39;, &#39;1&#39;]
    #  -------------:----------------------------------------
    # Out: parameter list (param object) with 2 definitions
    ```

    #### Error Handling
    ```python
    p = param(b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;, a=1)
    p.disp()
    # Output:
    # --------
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      a: 1
    # --------
    ```

    Sorting unresolved definitions raises errors unless explicitly suppressed:
    ```python
    p.sortdefinitions(raiseerror=False)
    # WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
    ```

    ---

    ### Utility Methods
    | Method                 | Description                                             |
    |------------------------|---------------------------------------------------------|
    | `eval()`               | Evaluate all field expressions.                         |
    | `formateval(string)`   | Format and evaluate a string with field placeholders.   |
    | `protect(string)`      | Escape variable placeholders in a string.               |
    | `sortdefinitions()`    | Sort definitions to resolve dependencies.               |
    | `escape(string)`       | Protect escaped variables in a string.                  |
    | `safe_fstring(string)` | evaluate safely complex mathemical expressions.         |

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two parameter lists, sorting definitions.
    - `-`: Subtraction of fields.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Notes
    - The `paramauto` class simplifies handling of partial definitions and inherits from `param`.
    - Use `paramauto` when definitions need to be stacked irrespective of execution order.
    &#34;&#34;&#34;

    # override
    _type = &#34;param&#34;
    _fulltype = &#34;parameter list&#34;
    _ftype = &#34;definition&#34;
    _evalfeature = True    # This class can be evaluated with .eval()
    _returnerror = True    # This class returns an error in the evaluation string (added on 2024-09-06)


    # magic constructor
    def __init__(self,_protection=False,_evaluation=True,
                 sortdefinitions=False,debug=False,**kwargs):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        super().__init__(debug=debug,**kwargs)
        self._protection = _protection
        self._evaluation = _evaluation
        self._needs_sorting = False # defers sorting
        if sortdefinitions: self.sortdefinitions()

    # escape definitions if needed
    @staticmethod
    def escape(s):
        &#34;&#34;&#34;
            escape \\${} as ${{}} --&gt; keep variable names
            convert ${} as {} --&gt; prepare Python replacement

            Examples:
                escape(&#34;\\${a}&#34;)
                returns (&#39;${{a}}&#39;, True)

                escape(&#34;  \\${abc} ${a} \\${bc}&#34;)
                returns (&#39;  ${{abc}} {a} ${{bc}}&#39;, True)

                escape(&#34;${a}&#34;)
                Out[94]: (&#39;{a}&#39;, False)

                escape(&#34;${tata}&#34;)
                returns (&#39;{tata}&#39;, False)

        &#34;&#34;&#34;
        if not isinstance(s,str):
            raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)
        se, start, found = &#34;&#34;, 0, True
        while found:
            pos0 = s.find(r&#34;\${&#34;,start)
            found = pos0&gt;=0
            if found:
                pos1 = s.find(&#34;}&#34;,pos0)
                found = pos1&gt;=0
                if found:
                    se += s[start:pos0].replace(&#34;${&#34;,&#34;{&#34;)+&#34;${{&#34;+s[pos0+3:pos1]+&#34;}}&#34;
                    start=pos1+1
        result = se+s[start:].replace(&#34;${&#34;,&#34;{&#34;)
        if isinstance(s,pstr): result = pstr(result)
        return result,start&gt;0

    # protect variables in a string
    def protect(self,s=&#34;&#34;):
        &#34;&#34;&#34; protect $variable as ${variable} &#34;&#34;&#34;
        if isinstance(s,str):
            t = s.replace(r&#34;\$&#34;,&#34;££&#34;) # &amp;&amp; is a placeholder
            escape = t!=s
            for k in self.keyssorted():
                t = t.replace(&#34;$&#34;+k,&#34;${&#34;+k+&#34;}&#34;)
            if escape: t = t.replace(&#34;££&#34;,r&#34;\$&#34;)
            if isinstance(s,pstr): t = pstr(t)
            return t, escape
        raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)


    # lines starting with # (hash) are interpreted as comments
    # ${variable} or {variable} are substituted by variable.value
    # any line starting with $ is assumed to be a string (no interpretation)
    # ^ is accepted in formula(replaced by **))
    def eval(self,s=&#34;&#34;,protection=False):
        &#34;&#34;&#34;
            Eval method for structure such as MS.alias

                s = p.eval() or s = p.eval(string)

                where :
                    p is a param object
                    s is a structure with evaluated fields
                    string is only used to determine whether definitions have been forgotten

        &#34;&#34;&#34;
        # handle deferred sorting
        if self._needs_sorting:
            self.sortdefinitions(raiseerror=False, silentmode=True)
        # the argument s is only used by formateval() for error management
        tmp = struct(debug=self._debug)
        # evaluator without context
        evaluator_nocontext = SafeEvaluator() # for global evaluation without context

        # main string evaluator
        def evalstr(value,key=&#34;&#34;):
            # replace ${variable} (Bash, Lammps syntax) by {variable} (Python syntax)
            # use \${variable} to prevent replacement (espace with \)
            # Protect variables if required
            ispstr = isinstance(value,pstr)
            valuesafe = pstr.eval(value,ispstr=ispstr) # value.strip()
            if valuesafe==&#34;${&#34;+key+&#34;}&#34;: # circular reference (it cannot be evaluated)
                return valuesafe
            if protection or self._protection:
                valuesafe, escape0 = self.protect(valuesafe)
            else:
                escape0 = False
            # replace ${var} by {var} once basic substitutions have been applied
            valuesafe_priorescape = tmp.numrepl(valuesafe) # minimal substitution
            valuesafe, escape = param.escape(valuesafe_priorescape)
            escape = escape or escape0
            # replace &#34;^&#34; (Matlab, Lammps exponent) by &#34;**&#34; (Python syntax)
            valuesafe = pstr.eval(valuesafe.replace(&#34;^&#34;,&#34;**&#34;),ispstr=ispstr)
            # Remove all content after #
            # if the first character is &#39;#&#39;, it is not comment (e.g. MarkDown titles)
            poscomment = valuesafe.find(&#34;#&#34;)
            if poscomment&gt;0: valuesafe = valuesafe[0:poscomment].strip()
            # Matrix shorthand replacement
            # $[[1,2,${a}]]+$[[10,20,30]] --&gt; np.array([[1,2,${a}]])+np.array([[10,20,30]])
            valuesafe = param.replace_matrix_shorthand(valuesafe)
            # Literal string starts with $ (no interpretation), ! (evaluation)
            if not self._evaluation:
                return pstr.eval(tmp.format(valuesafe,escape),ispstr=ispstr)
            elif valuesafe.startswith(&#34;!&#34;): # &lt;---------- FORECED LITERAL EVALUATION (error messages are returned)
                try:
                    #vtmp = ast.literal_eval(valuesafe[1:])
                    evaluator = SafeEvaluator(tmp)
                    vtmp = evaluate_with_placeholders(valuesafe[1:],evaluator,evaluator_nocontext)
                    if isinstance(vtmp,list):
                        for i,item in enumerate(vtmp):
                            if isinstance(item,str) and not is_literal_string(item):
                                try:
                                    vtmp[i] = tmp.format(item, raiseerror=False) # in case substitions/interpolations are needed
                                    try:
                                        vtmp[i] = evaluator_nocontext.evaluate(vtmp[i]) # full evaluation without context
                                    except Exception as othererr:
                                        if self._debug:
                                            print(f&#34;DEBUG {key}: Error evaluating: {vtmp[i]}\n&lt; {othererr} &gt;&#34;)
                                except Exception as ve:
                                    vtmp[i] = f&#34;Error in &lt;{item}&gt;: {ve.__class__.__name__} - {str(ve)}&#34;
                    return vtmp
                except (SyntaxError, ValueError) as e:
                    return f&#34;Error: {e.__class__.__name__} - {str(e)}&#34;
            elif valuesafe.startswith(&#34;$&#34;) and not escape:
                return tmp.format(valuesafe[1:].lstrip()) # discard $
            elif valuesafe.startswith(&#34;%&#34;):
                return tmp.format(valuesafe[1:].lstrip()) # discard %
            else: # string empty or which can be evaluated
                if valuesafe==&#34;&#34;:
                    return valuesafe # empty content
                else:
                    if isinstance(value,pstr): # keep path
                        return pstr.topath(tmp.format(valuesafe,escape=escape))
                    elif escape:  # partial evaluation
                        return tmp.format(valuesafe,escape=True)
                    else: # full evaluation (if it fails the last string content is returned) &lt;---------- FULL EVALUTION will be tried
                        try:
                            resstr = tmp.format(valuesafe,raiseerror=False)
                        except (KeyError,NameError) as nameerr:
                            try: # nested indexing (guess)
                                resstr = param.safe_fstring(
                                param.replace_matrix_shorthand(valuesafe_priorescape),tmp)
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluate_with_placeholders(resstr,
                                          evaluator,evaluator_nocontext,raiseerror=True)
                            except Exception as othererr:
                                if self._returnerror: # added on 2024-09-06
                                    strnameerr = str(nameerr).replace(&#34;&#39;&#34;,&#34;&#34;)
                                    if self._debug:
                                        print(f&#39;Key Error for &#34;{key}&#34; &lt; {othererr} &gt;&#39;)
                                    return &#39;&lt; undef %s &#34;${%s}&#34; &gt;&#39; % (self._ftype,strnameerr)
                                else:
                                    return value #we keep the original value
                            else:
                                return reseval
                        except SyntaxError as commonerr:
                            return &#34;Syntax Error &lt; %s &gt;&#34; % commonerr
                        except TypeError  as commonerr:
                            try: # nested indexing (guess)
                                resstr = param.safe_fstring(
                                param.replace_matrix_shorthand(valuesafe_priorescape),tmp)
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluate_with_placeholders(resstr,
                                          evaluator,evaluator_nocontext,raiseerror=True)
                            except Exception as othererr:
                                if self._debug:
                                    print(f&#39;Type Error for &#34;{key}&#34; &lt; {othererr} &gt;&#39;)
                                return &#34;Type Error &lt; %s &gt;&#34; % commonerr
                            else:
                                return reseval
                        except (IndexError,AttributeError):
                            try:
                                resstr = param.safe_fstring(
                                    param.replace_matrix_shorthand(valuesafe_priorescape),tmp)
                            except Exception as fstrerr:
                                return &#34;Index Error &lt; %s &gt;&#34; % fstrerr
                            else:
                                try:
                                    # reseval = eval(resstr)
                                    # reseval = ast.literal_eval(resstr)
                                    # Use SafeEvaluator to evaluate the final expression
                                    evaluator = SafeEvaluator(tmp)
                                    reseval = evaluator.evaluate(resstr)
                                except Exception as othererr:
                                    #tmp.setattr(key,&#34;Mathematical Error around/in ${}: &lt; %s &gt;&#34; % othererr)
                                    if self._debug:
                                        print(f&#34;DEBUG {key}: Error evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                    return resstr
                                else:
                                    return reseval
                        except ValueError as valerr: # forced evaluation within ${}
                            try:
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluate_with_placeholders(valuesafe_priorescape,evaluator,evaluator_nocontext,raiseerror=True)
                            except SyntaxError as synerror:
                                if self._debug:
                                    print(f&#34;DEBUG {key}: Error evaluating: {valuesafe_priorescape}\n&lt; {synerror} &gt;&#34;)
                                return evaluate_with_placeholders(valuesafe_priorescape,evaluator,evaluator_nocontext,raiseerror=False)
                            except Exception as othererr:
                                if self._debug:
                                    print(f&#34;DEBUG {key}: Error evaluating: {valuesafe_priorescape}\n&lt; {othererr} &gt;&#34;)
                                return &#34;Error in ${}: &lt; %s &gt;&#34; % valerr
                            else:
                                return reseval

                        except Exception as othererr:
                            return &#34;Error in ${}: &lt; %s &gt;&#34; % othererr
                        else:
                            try:
                                # reseval = eval(resstr)
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluate_with_placeholders(resstr,evaluator,evaluator_nocontext)
                            except Exception as othererr:
                                #tmp.setattr(key,&#34;Eval Error &lt; %s &gt;&#34; % othererr)
                                if self._debug:
                                    print(f&#34;DEBUG {key}: Error evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                return resstr.replace(&#34;\n&#34;,&#34;,&#34;) # \n replaced by ,
                            else:
                                return reseval

        # evalstr() refactored for error management
        def safe_evalstr(x,key=&#34;&#34;):
            xeval = evalstr(x,key)
            if isinstance(xeval,str):
                try:
                    evaluator = SafeEvaluator(tmp)
                    return evaluate_with_placeholders(xeval,evaluator,evaluator_nocontext)
                except Exception as e:
                    if self._debug:
                        print(f&#34;DEBUG {key}: Error evaluating &#39;{x}&#39;: {e}&#34;)
                    return xeval  # default fallback value
            else:
                return xeval

        # Evaluate all DEFINITIONS
        for key,value in self.items():
            # strings are assumed to be expressions on one single line
            if isinstance(value,str):
                tmp.setattr(key,evalstr(value,key))
            elif isinstance(value,_numeric_types): # already a number
                if isinstance(value,list):
                    valuelist = [safe_evalstr(x,key) if isinstance(x,str) else x for x in value]
                    tmp.setattr(key,valuelist)
                else:
                    tmp.setattr(key, value) # store the value with the key
            elif isinstance(value, dict):
                # For dictionaries, evaluate each entry using its own key (sub_key)
                new_dict = {}
                for sub_key, sub_value in value.items():
                    if isinstance(sub_value, str):
                        new_dict[sub_key] = safe_evalstr(sub_value,key)
                    elif isinstance(sub_value, list):
                        # If an entry is a list, apply safe_evalstr to each string element within it
                        new_dict[sub_key] = [safe_evalstr(x, sub_key) if isinstance(x, str) else x
                                             for x in sub_value]
                    else:
                        new_dict[sub_key] = sub_value
                tmp.setattr(key, new_dict)
            else: # unsupported types
                if s.find(&#34;{&#34;+key+&#34;}&#34;)&gt;=0:
                    print(f&#39;*** WARNING ***\n\tIn the {self._ftype}:&#34;\n{s}\n&#34;&#39;)
                else:
                    print(f&#39;unable to interpret the &#34;{key}&#34; of type {type(value)}&#39;)
        return tmp

    # formateval obeys to following rules
    # lines starting with # (hash) are interpreted as comments
    def formateval(self,s,protection=False,fullevaluation=True):
        &#34;&#34;&#34;
            format method with evaluation feature

                txt = p.formateval(&#34;this my text with ${variable1}, ${variable2} &#34;)

                where:
                    p is a param object

                Example:
                    definitions = param(a=1,b=&#34;${a}&#34;,c=&#34;\\${a}&#34;)
                    text = definitions.formateval(&#34;this my text ${a}, ${b}, ${c}&#34;)
                    print(text)

        &#34;&#34;&#34;
        tmp = self.eval(s,protection=protection)
        evaluator = SafeEvaluator(tmp) # used when fullevaluation=True
        evaluator_nocontext = SafeEvaluator() # for global evaluation without context
        # Do all replacements in s (keep comments)
        if len(tmp)==0:
            return s
        else:
            ispstr = isinstance(s,pstr)
            ssafe, escape = param.escape(s)
            slines = ssafe.split(&#34;\n&#34;)
            slines_priorescape = s.split(&#34;\n&#34;)
            for i in range(len(slines)):
                poscomment = slines[i].find(&#34;#&#34;)
                if poscomment&gt;=0:
                    while (poscomment&gt;0) and (slines[i][poscomment-1]==&#34; &#34;):
                        poscomment -= 1
                    comment = slines[i][poscomment:len(slines[i])]
                    slines[i]  = slines[i][0:poscomment]
                else:
                    comment = &#34;&#34;
                # Protect variables if required
                if protection or self._protection:
                    slines[i], escape2 = self.protect(slines[i])
                # conversion
                if ispstr:
                    slines[i] = pstr.eval(tmp.format(slines[i],escape=escape),ispstr=ispstr)
                else:
                    if fullevaluation:
                        try:
                            resstr =tmp.format(slines[i],escape=escape)
                        except:
                            resstr = param.safe_fstring(slines[i],tmp,varprefix=&#34;&#34;)
                        try:
                            #reseval = evaluator.evaluate(resstr)
                            reseval = evaluate_with_placeholders(slines_priorescape[i],evaluator,evaluator_nocontext,raiseerror=True)
                            slines[i] = str(reseval)+&#34; &#34;+comment if comment else str(reseval)
                        except:
                            slines[i] = resstr + comment
                    else:
                        slines[i] = tmp.format(slines[i],escape=escape)+comment
                # convert starting % into # to authorize replacement in comments
                if len(slines[i])&gt;0:
                    if slines[i][0] == &#34;%&#34;: slines[i]=&#34;#&#34;+slines[i][1:]
            return &#34;\n&#34;.join(slines)


    # return the value instead of formula
    def getval(self,key):
        &#34;&#34;&#34; returns the evaluated value &#34;&#34;&#34;
        s = self.eval()
        return getattr(s,key)

    # override () for subindexing structure with key names
    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extract an evaluated sub-structure based on the specified keys,
        keeping the same class type.

        Parameters:
        -----------
        *keys : str
            The keys for the fields to include in the sub-structure.

        Returns:
        --------
        struct
            An evaluated instance of class struct, containing
            only the specified keys with evaluated values.

        Usage:
        ------
        sub_struct = p(&#39;key1&#39;, &#39;key2&#39;, ...)
        &#34;&#34;&#34;
        s = self.eval()
        if keys:
            return s(*keys)
        else:
            return s

    # returns the equivalent structure evaluated
    def tostruct(self,protection=False):
        &#34;&#34;&#34;
            generate the evaluated structure
                tostruct(protection=False)
        &#34;&#34;&#34;
        return self.eval(protection=protection)

    # returns the equivalent paramauto instance
    def toparamauto(self):
        &#34;&#34;&#34;
            convert a param instance into a paramauto instance
                toparamauto()
        &#34;&#34;&#34;
        return paramauto(**self)

    # returns the equivalent structure evaluated
    def tostatic(self):
        &#34;&#34;&#34; convert dynamic a param() object to a static struct() object.
            note: no interpretation
            note: use tostruct() to interpret them and convert it to struct
            note: tostatic().struct2param() makes it reversible
        &#34;&#34;&#34;
        return struct.fromkeysvalues(self.keys(),self.values(),makeparam=False)

    # Matlab vector/list conversion
    @staticmethod
    def expand_ranges(text,numfmt=&#34;.4g&#34;):
        &#34;&#34;&#34;
        Expands MATLAB-style ranges in a string.

        Args:
            text: The input string containing ranges.
            numfmt: numeric format to be used for the string conversion (default=&#34;.4g&#34;)

        Returns:
            The string with ranges expanded, or the original string if no valid ranges are found
            or if expansion leads to more than 100 elements. Returns an error message if the input
            format is invalid.
        &#34;&#34;&#34;
        def expand_range(match):
            try:
                parts = match.group(1).split(&#39;:&#39;)
                if len(parts) == 2:
                    start, stop = map(float, parts)
                    step = 1.0
                elif len(parts) == 3:
                    start, step, stop = map(float, parts)
                else:
                    return match.group(0)  # Return original if format is invalid
                if step == 0:
                    return &#34;Error: &lt;Step cannot be zero.&gt;&#34;
                if (stop - start) / step &gt; 1e6:
                    return &#34;Error: &lt;Range is too large.&gt;&#34;
                if step &gt; 0:
                    num_elements = int(np.floor((stop - start)/step)+1)
                else:
                     num_elements = int(np.floor((start - stop)/-step)+1)
                if num_elements &gt; 100:
                    return match.group(0)  # Return original if too many elements
                expanded_range = np.arange(start, stop + np.sign(step)*1e-9, step) #adding a small number to include the stop in case of integer steps
                return &#39;[&#39; + &#39;,&#39;.join(f&#39;{x:{numfmt}}&#39; for x in expanded_range) + &#39;]&#39;
            except ValueError:
                return &#34;Error: &lt;Invalid range format.&gt;&#34;
        pattern = r&#39;(\b(?:-?\d+(?:\.\d*)?|-?\.\d+)(?::(?:-?\d+(?:\.\d*)?|-?\.\d+)){1,2})\b&#39;
        expanded_text = re.sub(pattern, expand_range, text)
        #check for errors generated by the function
        if &#34;Error:&#34; in expanded_text:
            return expanded_text
        return expanded_text

    # Matlab syntax conversion
    @staticmethod
    def convert_matlab_like_arrays(text):
        &#34;&#34;&#34;
        Converts Matlab-like array syntax (including hybrid notations) into
        a NumPy-esque list syntax in multiple passes.

        Steps:
          1) Convert 2D Matlab arrays (containing semicolons) into Python-like nested lists.
          2) Convert bracketed row vectors (no semicolons or nested brackets) into double-bracket format.
          3) Replace spaces with commas under specific conditions and remove duplicates.

        Args:
            text (str): Input string that may contain Matlab-like arrays.

        Returns:
            str: Transformed text with arrays converted to a Python/NumPy-like syntax.

        Examples:

            examples = [
                &#34;[1, 2  ${var1}          ; 4, 5     ${var2}]&#34;,
                &#34;[1,2,3]&#34;,
                &#34;[1 2 ,  3]&#34;,
                &#34;[1;2; 3]&#34;,
                &#34;[[-0.5, 0.5;-0.5, 0.5],[ -0.5,  0.5; -0.5,  0.5]]&#34;,
                &#34;[[1,2;3,4],[5,6; 7,8]]&#34;,
                &#34;[1, 2, 3; 4, 5, 6]&#34;,  # Hybrid
                &#34;[[Already, in, Python]]&#34;,  # Already Python-like?
                &#34;Not an array&#34;
            ]

            for ex in examples:
                converted = param.convert_matlab_like_arrays(ex)
                print(f&#34;Matlab: {ex}\nNumPy : {converted}\n&#34;)

        &#34;&#34;&#34;
        # --------------------------------------------------------------------------
        # Step 1: Detect innermost [ ... ; ... ] blocks and convert them
        # --------------------------------------------------------------------------
        def convert_matrices_with_semicolons(txt):
            &#34;&#34;&#34;
            Repeatedly find the innermost bracket pair that contains a semicolon
            and convert it to a Python-style nested list, row by row.
            &#34;&#34;&#34;
            # Pattern to find innermost [ ... ; ... ] without nested brackets
            pattern = r&#39;\[[^\[\]]*?;[^\[\]]*?\]&#39;
            while True:
                match = re.search(pattern, txt)
                if not match:
                    break  # No more [ ... ; ... ] blocks to convert
                inner_block = match.group(0)
                # Remove the outer brackets
                inner_content = inner_block[1:-1].strip()
                # Split into rows by semicolon
                rows = [row.strip() for row in inner_content.split(&#39;;&#39;)]
                converted_rows = []
                for row in rows:
                    # Replace multiple spaces with a single space
                    row_clean = re.sub(r&#39;\s+&#39;, &#39; &#39;, row)
                    # Split row by commas or spaces
                    row_elems = re.split(r&#39;[,\s]+&#39;, row_clean)
                    row_elems = [elem for elem in row_elems if elem]  # Remove empty strings
                    # Join elements with commas and encapsulate in brackets
                    converted_rows.append(&#34;[&#34; + &#34;,&#34;.join(row_elems) + &#34;]&#34;)
                # Join the row lists and encapsulate them in brackets
                replacement = &#34;[&#34; + &#34;,&#34;.join(converted_rows) + &#34;]&#34;
                # Replace the original Matlab matrix with the Python list
                txt = txt[:match.start()] + replacement + txt[match.end():]
            return txt
        # --------------------------------------------------------------------------
        # Step 2: Convert row vectors without semicolons or nested brackets
        #         into double-bracket format, e.g. [1,2,3] -&gt; [[1,2,3]]
        # --------------------------------------------------------------------------
        def convert_row_vectors(txt):
            &#34;&#34;&#34;
            Convert [1,2,3] or [1 2 3] into [[1,2,3]] if the bracket does not contain
            semicolons, nor nested brackets. We do this iteratively, skipping any
            bracket blocks that don&#39;t qualify, rather than stopping.
            &#34;&#34;&#34;
            # We only want bracket blocks that are NOT preceded by &#39;[&#39; or &#39;,&#39;
            # do not contain semicolons or nested brackets
            # and are not followed by &#39;]&#39; or &#39;,&#39;
            pattern = r&#34;(?&lt;!\[)(?&lt;!,)\([^();]*\)(?!\s*\])(?!\s*\,)&#34;
            startpos = 0
            while True:
                match = re.search(pattern, txt[startpos:])
                if not match:
                    break  # No more bracket blocks to check
                # Compute absolute positions in txt
                mstart = startpos + match.start()
                mend   = startpos + match.end()
                block  = txt[mstart:mend]
                # we need to be sure that [ ] are present around the block even if separated by spaces
                if mstart == 0 or mend == len(txt) - 1:
                    break
                if not (re.match(r&#34;\[\s*$&#34;, txt[:mstart]) and re.match(r&#34;^\s*\]&#34;, txt[mend+1:])):
                    break
                # Double-check that this bracket does not contain semicolons or nested brackets
                # If it does, we skip it (just advance the search) to avoid messing up matrices.
                # That is, we do not transform it into double brackets.
                if &#39;;&#39; in block or &#39;[&#39; in block[1:-1] or &#39;]&#39; in block[1:-1]:
                    # Move beyond this match and keep searching
                    startpos = mend
                    continue
                # It&#39;s a pure row vector (no semicolons, no nested brackets)
                new_block = &#34;[&#34; + block + &#34;]&#34;  # e.g. [1,2,3] -&gt; [[1,2,3]]
                txt = txt[:mstart] + new_block + txt[mend:]
                # Update search position to avoid re-matching inside the newly inserted text
                startpos = mstart + len(new_block)
            return txt
        # --------------------------------------------------------------------------
        # Step 3: Replace spaces with commas under specific conditions and clean up
        # --------------------------------------------------------------------------
        def replace_spaces_safely(txt):
            &#34;&#34;&#34;
            Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas.
            Then remove multiple consecutive commas and trailing commas before closing brackets.
            &#34;&#34;&#34;
            # 1) Replace spaces with commas if not preceded by [,\s
            #    and followed by digit or $
            txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
            # 2) Remove multiple consecutive commas
            txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
            # 3) Remove trailing commas before closing brackets
            txt = re.sub(r&#39;,+\]&#39;, &#39;]&#39;, txt)
            return txt

        def replace_spaces_with_commas(txt):
            &#34;&#34;&#34;
            Replaces spaces with commas only when they&#39;re within array shorthands and not preceded by a comma, opening bracket, or whitespace,
            and are followed by a digit or &#39;$&#39;. Also collapses multiple commas into one and strips leading/trailing commas.

            Parameters:
            ----------
            txt : str
                The text to process.

            Returns:
            -------
            str
                The processed text with appropriate commas.
            &#34;&#34;&#34;
            # Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas
            txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
            # Remove multiple consecutive commas
            txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
            # Strip leading and trailing commas
            txt = txt.strip(&#39;,&#39;)
            # Replace residual multiple consecutive spaces with a single space
            return re.sub(r&#39;\s+&#39;, &#39; &#39;, txt)

        # --------------------------------------------------------------------------
        # Apply Step 1: Convert matrices with semicolons
        # --------------------------------------------------------------------------
        text_cv = convert_matrices_with_semicolons(text)
        # --------------------------------------------------------------------------
        # Apply Step 2: Convert row vectors (no semicolons/nested brackets)
        # --------------------------------------------------------------------------
        text_cv = convert_row_vectors(text_cv)
        # --------------------------------------------------------------------------
        # Apply Step 3: Replace spaces with commas and clean up
        # --------------------------------------------------------------------------
        if text_cv != text:
            return replace_spaces_with_commas(text_cv) # old method: replace_spaces_safely(text_cv)
        else:
            return text



    @classmethod
    def replace_matrix_shorthand(cls,valuesafe):
        &#34;&#34;&#34;
        Transforms custom shorthand notations for NumPy arrays within a string into valid NumPy array constructors.
        Supports up to 4-dimensional arrays and handles variable references.

        **Shorthand Patterns:**
        - **1D**: `$[1 2 3]` → `np.atleast_2d(np.array([1,2,3]))`
        - **2D**: `$[[1 2],[3 4]]` → `np.array([[1,2],[3,4]])`
        - **3D**: `$[[[1 2],[3 4]],[[5 6],[7 8]]]` → `np.array([[[1,2],[3,4]],[[5,6],[7,8]]])`
        - **4D**: `$[[[[1 2]]]]` → `np.array([[[[1,2]]]])`
        - **Variable References**: `@{var}` → `np.atleast_2d(np.array(${var}))`

        **Parameters:**
        ----------
        valuesafe : str
            The input string containing shorthand notations for NumPy arrays and variable references.

        **Returns:**
        -------
        str
            The transformed string with shorthands replaced by valid NumPy array constructors.

        **Raises:**
        -------
        ValueError
            If there are unmatched brackets in any shorthand.

        **Examples:**
        --------
        &gt;&gt;&gt; # 1D shorthand
        &gt;&gt;&gt; s = &#34;$[1 2 3]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.atleast_2d(np.array([1,2,3]))&#39;

        &gt;&gt;&gt; # 2D shorthand with mixed spacing
        &gt;&gt;&gt; s = &#34;$[[1, 2], [3 4]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[1,2],[3,4]])&#39;

        &gt;&gt;&gt; # 3D array with partial spacing
        &gt;&gt;&gt; s = &#34;$[[[1  2], [3 4]], [[5 6], [7 8]]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[1,2],[3,4]],[[5,6],[7,8]]])&#39;

        &gt;&gt;&gt; # 4D array
        &gt;&gt;&gt; s = &#34;$[[[[1 2]]]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[[1,2]]]])&#39;

        &gt;&gt;&gt; # Combined with variable references
        &gt;&gt;&gt; s = &#34;@{a} + $[[${b}, 2],[ 3  4]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.atleast_2d(np.array(${a})) + np.array([[${b},2],[3,4]])&#39;

        &gt;&gt;&gt; # Complex ND array with scaling
        &gt;&gt;&gt; s = &#39;$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*0.001&#39;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[-0.5,-0.5],[-0.5,-0.5]],[[0.5,0.5],[0.5,0.5]]])*0.001&#39;
        &#34;&#34;&#34;

        numfmt = f&#34;.{cls._precision}g&#34;

        def replace_spaces_with_commas(txt):
            &#34;&#34;&#34;
            Replaces spaces with commas only when they&#39;re not preceded by a comma, opening bracket, or whitespace,
            and are followed by a digit or &#39;$&#39;. Also collapses multiple commas into one and strips leading/trailing commas.

            Parameters:
            ----------
            txt : str
                The text to process.

            Returns:
            -------
            str
                The processed text with appropriate commas.
            &#34;&#34;&#34;
            # Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas
            txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
            # Remove multiple consecutive commas
            txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
            return txt.strip(&#39;,&#39;)

        def build_pass_list(string):
            &#34;&#34;&#34;
            Determines which dimensions (1D..4D) appear in the string by searching for:
             - 4D: $[[[[
             - 3D: $[[[
             - 2D: $[[
             - 1D: $[

            Returns a sorted list in descending order, e.g., [4, 3, 2, 1].

            Parameters:
            ----------
            string : str
                The input string to scan.

            Returns:
            -------
            list
                A list of integers representing the dimensions found, sorted descending.
            &#34;&#34;&#34;
            dims_found = set()
            if re.search(r&#39;\$\[\[\[\[&#39;, string):
                dims_found.add(4)
            if re.search(r&#39;\$\[\[\[&#39;, string):
                dims_found.add(3)
            if re.search(r&#39;\$\[\[&#39;, string):
                dims_found.add(2)
            if re.search(r&#39;\$\[&#39;, string):
                dims_found.add(1)
            return sorted(dims_found, reverse=True)

        # Step 0: convert eventual Matlab syntax for row and column vectors into NumPy syntax
        valuesafe = param.expand_ranges(valuesafe,numfmt)  # expands start:stop and start:step:stop syntax
        valuesafe = param.convert_matlab_like_arrays(valuesafe) # vectors and matrices conversion
        # Step 1: Handle @{var} -&gt; np.atleast_2d(np.array(${var}))
        valuesafe = re.sub(r&#39;@\{([^\{\}]+)\}&#39;, r&#39;np.atleast_2d(np.array(${\1}))&#39;, valuesafe)
        # Step 2: Build pass list from largest dimension to smallest
        pass_list = build_pass_list(valuesafe)
        # Step 3: Define patterns and replacements for each dimension
        dimension_patterns = {
            4: (r&#39;\$\[\[\[\[(.*?)\]\]\]\]&#39;, &#39;np.array([[[[{content}]]]])&#39;),   # 4D
            3: (r&#39;\$\[\[\[(.*?)\]\]\]&#39;, &#39;np.array([[[{content}]]])&#39;),         # 3D
            2: (r&#39;\$\[\[(.*?)\]\]&#39;, &#39;np.array([[{content}]])&#39;),               # 2D
            1: (r&#39;\$\[(.*?)\]&#39;, &#39;np.atleast_2d(np.array([{content}]))&#39;)       # 1D
        }
        # Step 4: Iterate over each dimension and perform replacements
        for dim in pass_list:
            pattern, replacement_fmt = dimension_patterns[dim]
            # Find all non-overlapping matches for the current dimension
            matches = list(re.finditer(pattern, valuesafe))
            for match in matches:
                full_match = match.group(0)       # Entire matched shorthand
                inner_content = match.group(1)    # Content inside the brackets
                # Replace spaces with commas as per rules
                processed_content = replace_spaces_with_commas(inner_content.strip())
                # Create the replacement string
                replacement = replacement_fmt.format(content=processed_content)
                # Replace the shorthand in the string
                valuesafe = valuesafe.replace(full_match, replacement)
        # Step 5: Verify that all shorthands have been replaced by checking for remaining &#39;$[&#39;
        if re.search(r&#39;\$\[&#39;, valuesafe):
            raise ValueError(&#34;Unmatched or improperly formatted brackets detected in the input string.&#34;)
        return valuesafe



    # Safe fstring
    @staticmethod
    def safe_fstring(template, context,varprefix=&#34;$&#34;):
        &#34;&#34;&#34;Safely evaluate expressions in ${} using SafeEvaluator.&#34;&#34;&#34;
        evaluator = SafeEvaluator(context)
        # Process template string in combination with safe_fstring()
        # it is required to have an output compatible with eval()

        def process_template(valuesafe):
            &#34;&#34;&#34;
            Processes the input string by:
            1. Stripping leading and trailing whitespace.
            2. Removing comments (any text after &#39;#&#39; unless &#39;#&#39; is the first character).
            3. Replacing &#39;^&#39; with &#39;**&#39;.
            4. Replacing &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;. &lt;-- not applied anymore (brings confusion)

            Args:
                valuesafe (str): The input string to process.

            Returns:
                str: The processed string.
            &#34;&#34;&#34;
            # Step 1: Strip leading and trailing whitespace
            valuesafe = valuesafe.strip()
            # Step 2: Remove comments
            # This regex removes &#39;#&#39; and everything after it if &#39;#&#39; is not the first character
            # (?&lt;!^) is a negative lookbehind that ensures &#39;#&#39; is not at the start of the string
            valuesafe = re.sub(r&#39;(?&lt;!^)\#.*&#39;, &#39;&#39;, valuesafe)
            # Step 3: Replace &#39;^&#39; with &#39;**&#39;
            valuesafe = re.sub(r&#39;\^&#39;, &#39;**&#39;, valuesafe)
            # Step 4: Replace &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;
            # (?&lt;!\$)\{ matches &#39;{&#39; not preceded by &#39;$&#39;
            # valuesafe = re.sub(r&#39;(?&lt;!\$)\{&#39;, &#39;${&#39;, valuesafe)
            # Optional: Strip again to remove any trailing whitespace left after removing comments
            valuesafe = valuesafe.strip()
            return valuesafe

        # Adjusted display for NumPy arrays
        def serialize_result(result):
            &#34;&#34;&#34;
            Serialize the result into a string that can be evaluated in Python.
            Handles NumPy arrays by converting them to lists with commas.
            Handles other iterable types appropriately.
            &#34;&#34;&#34;
            if isinstance(result, np.ndarray):
                return str(result.tolist())
            elif isinstance(result, (list, tuple, dict)):
                return str(result)
            else:
                return str(result)
        # Regular expression to find ${expr} patterns
        escaped_varprefix = re.escape(varprefix)
        pattern = re.compile(escaped_varprefix+r&#39;\{([^{}]+)\}&#39;)
        def replacer(match):
            expr = match.group(1)
            try:
                result = evaluator.evaluate(expr)
                serialized = serialize_result(result)
                return serialized
            except Exception as e:
                return f&#34;&lt;Error: {e}&gt;&#34;
        return pattern.sub(replacer, process_template(template))

# %% str class for file and paths
# this class guarantees that paths are POSIX at any time


class pstr(str):
    &#34;&#34;&#34;
    Class: `pstr`
    =============

    A specialized string class for handling paths and filenames, derived from `struct`.
    The `pstr` class ensures compatibility with POSIX-style paths and provides enhanced
    operations for path manipulation.

    ---

    ### Features
    - Maintains POSIX-style paths.
    - Automatically handles trailing slashes.
    - Supports path concatenation using `/`.
    - Converts seamlessly back to `str` for compatibility with string methods.
    - Includes additional utility methods for path evaluation and formatting.

    ---

    ### Examples

    #### Basic Usage
    ```python
    a = pstr(&#34;this/is/mypath//&#34;)
    b = pstr(&#34;mylocalfolder/myfile.ext&#34;)
    c = a / b
    print(c)  # this/is/mypath/mylocalfolder/myfile.ext
    ```

    #### Keeping Trailing Slashes
    ```python
    a = pstr(&#34;this/is/mypath//&#34;)
    print(a)  # this/is/mypath/
    ```

    ---

    ### Path Operations

    #### Path Concatenation
    Use the `/` operator to concatenate paths:
    ```python
    a = pstr(&#34;folder/subfolder&#34;)
    b = pstr(&#34;file.txt&#34;)
    c = a / b
    print(c)  # folder/subfolder/file.txt
    ```

    #### Path Evaluation
    Evaluate or convert paths while preserving the `pstr` type:
    ```python
    result = pstr.eval(&#34;some/path/afterreplacement&#34;, ispstr=True)
    print(result)  # some/path/afterreplacement
    ```

    ---

    ### Advanced Usage

    #### Using String Methods
    Methods like `replace()` convert `pstr` back to `str`. To retain the `pstr` type:
    ```python
    new_path = pstr.eval(a.replace(&#34;mypath&#34;, &#34;newpath&#34;), ispstr=True)
    print(new_path)  # this/is/newpath/
    ```

    #### Handling POSIX Paths
    The `pstr.topath()` method ensures the path remains POSIX-compliant:
    ```python
    path = pstr(&#34;C:\\Windows\\Path&#34;)
    posix_path = path.topath()
    print(posix_path)  # C:/Windows/Path
    ```

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `/`: Concatenates two paths (`__truediv__`).
    - `+`: Concatenates strings as paths, resulting in a `pstr` object (`__add__`).
    - `+=`: Adds to an existing `pstr` object (`__iadd__`).

    ---

    ### Utility Methods

    | Method          | Description                                  |
    |------------------|----------------------------------------------|
    | `eval(value)`    | Evaluates the path or string for compatibility with `pstr`. |
    | `topath()`       | Returns the POSIX-compliant path.           |

    ---

    ### Notes
    - Use `pstr` for consistent and safe handling of file paths across different platforms.
    - Converts back to `str` when using non-`pstr` specific methods to ensure compatibility.
    &#34;&#34;&#34;

    def __repr__(self):
        result = self.topath()
        if result[-1] != &#34;/&#34; and self[-1] == &#34;/&#34;:
            result += &#34;/&#34;
        return result

    def topath(self):
        &#34;&#34;&#34; return a validated path &#34;&#34;&#34;
        value = pstr(PurePath(self))
        if value[-1] != &#34;/&#34; and self [-1]==&#34;/&#34;:
            value += &#34;/&#34;
        return value


    @staticmethod
    def eval(value,ispstr=False):
        &#34;&#34;&#34; evaluate the path of it os a path &#34;&#34;&#34;
        if isinstance(value,pstr):
            return value.topath()
        elif isinstance(value,PurePath) or ispstr:
            return pstr(value).topath()
        else:
            return value

    def __truediv__(self,value):
        &#34;&#34;&#34; overload / &#34;&#34;&#34;
        operand = pstr.eval(value)
        result = pstr(PurePath(self) / operand)
        if result[-1] != &#34;/&#34; and operand[-1] == &#34;/&#34;:
            result += &#34;/&#34;
        return result

    def __add__(self,value):
        return pstr(str(self)+value)

    def __iadd__(self,value):
        return pstr(str(self)+value)


# %% class paramauto() which enforces sortdefinitions = True, raiseerror=False
class paramauto(param):
    &#34;&#34;&#34;
    Class: `paramauto`
    ==================

    A subclass of `param` with enhanced handling for automatic sorting and evaluation
    of definitions. The `paramauto` class ensures that all fields are sorted to resolve
    dependencies, allowing seamless stacking of partially defined objects.

    ---

    ### Features
    - Inherits all functionalities of `param`.
    - Automatically sorts definitions for dependency resolution.
    - Simplifies handling of partial definitions in dynamic structures.
    - Supports safe concatenation of definitions.

    ---

    ### Examples

    #### Automatic Dependency Sorting
    Definitions are automatically sorted to resolve dependencies:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${b}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${b} (= 3)
    # --------
    ```

    #### Handling Missing Definitions
    Unresolved dependencies raise warnings but do not block execution:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------
    ```

    ---

    ### Concatenation and Inheritance
    Concatenating `paramauto` objects resolves definitions:
    ```python
    p1 = paramauto(a=1, b=&#34;${a}+2&#34;)
    p2 = paramauto(c=&#34;${b}*3&#34;)
    p3 = p1 + p2
    p3.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 2 (= 3)
    #      c: ${b} * 3 (= 9)
    # --------
    ```

    ---

    ### Utility Methods

    | Method                | Description                                            |
    |-----------------------|--------------------------------------------------------|
    | `sortdefinitions()`   | Automatically sorts fields to resolve dependencies.    |
    | `eval()`              | Evaluate all fields, resolving dependencies.           |
    | `disp()`              | Display all fields with their resolved values.         |

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `+`: Concatenates two `paramauto` objects, resolving dependencies.
    - `+=`: Updates the current object with another, resolving dependencies.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Advanced Usage

    #### Partial Definitions
    The `paramauto` class simplifies handling of partially defined fields:
    ```python
    p = paramauto(a=&#34;${d}&#34;, b=&#34;${a}+1&#34;)
    p.disp()
    # Warning: Unable to resolve dependencies.
    # --------
    #      a: ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      b: ${a} + 1 (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------

    p.d = 10
    p.disp()
    # Dependencies are resolved:
    # --------
    #      d: 10
    #      a: ${d} (= 10)
    #      b: ${a} + 1 (= 11)
    # --------
    ```

    ---

    ### Notes
    - The `paramauto` class is computationally more intensive than `param` due to automatic sorting.
    - It is ideal for managing dynamic systems with complex interdependencies.

    ### Examples
                    p = paramauto()
                    p.b = &#34;${aa}&#34;
                    p.disp()
                yields
                    WARNING: unable to interpret 1/1 expressions in &#34;definitions&#34;
                      -----------:----------------------------------------
                                b: ${aa}
                                 = &lt; undef definition &#34;${aa}&#34; &gt;
                      -----------:----------------------------------------
                      p.aa = 2
                      p.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                    -----------:----------------------------------------
                    q = paramauto(c=&#34;${aa}+${b}&#34;)+p
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                              c: ${aa}+${b}
                               = 4
                    -----------:----------------------------------------
                    q.aa = 30
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 30
                              b: ${aa}
                               = 30
                              c: ${aa}+${b}
                               = 60
                    -----------:----------------------------------------
                    q.aa = &#34;${d}&#34;
                    q.disp()
                yields multiple errors (recursion)
                WARNING: unable to interpret 3/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                           aa: ${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                            b: ${aa}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                            c: ${aa}+${b}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                  -----------:----------------------------------------
                    q.d = 100
                    q.disp()
                yields
                  -----------:----------------------------------------
                            d: 100
                           aa: ${d}
                             = 100
                            b: ${aa}
                             = 100
                            c: ${aa}+${b}
                             = 200
                  -----------:----------------------------------------


            Example:

                p = paramauto(b=&#34;${a}+1&#34;,c=&#34;${a}+${d}&#34;,a=1)
                p.disp()
            generates:
                WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                            a: 1
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                  -----------:----------------------------------------
            setting p.d
                p.d = 2
                p.disp()
            produces
                  -----------:----------------------------------------
                            a: 1
                            d: 2
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = 3
                  -----------:----------------------------------------

    &#34;&#34;&#34;

    def __add__(self,p):
        return super().__add__(p,sortdefinitions=True,raiseerror=False)
        self._needs_sorting = True

    def __iadd__(self,p):
        return super().__iadd__(p,sortdefinitions=True,raiseerror=False)
        self._needs_sorting = True

    def __repr__(self):
        self.sortdefinitions(raiseerror=False)
        #super(param,self).__repr__()
        super().__repr__()
        return str(self)

    def setattr(self,key,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0 and key in self:
            delattr(self, key)
        else:
            self.__dict__[key] = value
            self.__dict__[&#34;_needs_sorting&#34;] = True

    def sortdefinitions(self, raiseerror=True, silentmode=True):
        if self._needs_sorting:
            super().sortdefinitions(raiseerror=raiseerror, silentmode=silentmode)
            self._needs_sorting = False

# %% DEBUG
# ===================================================
# main()
# ===================================================
# for debugging purposes (code called as a script)
# the code is called from here
# ===================================================
if __name__ == &#39;__main__&#39;:
# =============================================================================
#     # very advanced
#     import os
#     from fitness.private.loadods import alias
#     local = &#34;C:/Users/olivi/OneDrive/Data/Olivier/INRA/Etudiants &amp; visiteurs/Steward Ouadi/python/test/output/&#34;
#     odsfile = &#34;fileid_conferences_FoodRisk.ods&#34;
#     fullfodsfile = os.path.join(local,odsfile)
#     p = alias(fullfodsfile)
#     p.disp()
# =============================================================================
# new feature
    a = struct(a=1,b=2)
    a[&#34;b&#34;]
# path example
    s0 = struct(a=pstr(&#34;/tmp/&#34;),b=pstr(&#34;test////&#34;),c=pstr(&#34;${a}/${b}&#34;),d=pstr(&#34;${a}/${c}&#34;),e=pstr(&#34;$c/$a&#34;))
    s = struct.struct2param(s0,protection=True)
    s.disp()
    s.a/s.b
    str(pstr.topath(f&#34;{s.a}/{s.b}&#34;))
    s.eval()
    # escape example
    definitions = param(a=1,b=&#34;${a}*10+${a}&#34;,c=r&#34;\${a}+10&#34;,d=r&#39;\${myparam}&#39;)
    text = definitions.formateval(r&#34;this my text ${a}, ${b}, \${myvar}=${c}+${d}&#34;)
    print(text)

    definitions = param(a=1,b=&#34;$a*10+$a&#34;,c=r&#34;\$a+10&#34;,d=r&#39;\$myparam&#39;)
    text = definitions.formateval(r&#34;this my text $a, $b, \$myvar=$c+$d&#34;,protection=True)
    print(text)
    # assignment
    s = struct(a=1,b=2)
    s[1] = 3
    s.disp()
    # conversion
    s = {&#34;a&#34;:1, &#34;b&#34;:2}
    t=struct.dict2struct(s)
    t.disp()
    sback = t.struct2dict()
    sback.__repr__()
    # file definition
    p=struct.fromkeysvalues([&#34;a&#34;,&#34;b&#34;,&#34;c&#34;,&#34;d&#34;],[1,2,3]).struct2param()
    ptxt = p.protect(&#34;$c=$a+$b&#34;)
    definitions.write(&#34;../../tmp/test.txt&#34;)
    # populate/inherit fields
    default = struct(a=1,b=&#34;2&#34;,c=[1,2,3])
    tst = struct(a=10)
    tst.check(default)
    tst.disp()
    # multiple assigment
    a = struct(a=1,b=2,c=3,d=4)
    b = struct(a=10,b=20,c=30,d=40)
    a[:2] = b[1:3]
    a[:2] = b[(1,3)]
    # reorganize definitions to enable param.eval()
    s = param(
        a = 1,
        f = &#34;${e}/3&#34;,
        e = &#34;${a}*${c}&#34;,
        c = &#34;${a}+${b}&#34;,
        b = 2,
        d = &#34;${c}*2&#34;
        )
    #s[0:2] = [1,2]
    s.isexpression
    struct.isstrdefined(&#34;${a}+${b}&#34;,s)
    s.isdefined()
    s.sortdefinitions()
    s.disp()
    p = param(b=&#34;${a}+1&#34;,c=&#34;${a}+${d}&#34;,a=1)
    p.disp()

# features 2025
    p=param()
    p.a = [0,1,2]
    p.b = &#39;![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]&#39;
    p

# Mathematical expressions
    # Example: param.safe_fstring()
    # Sample context with a NumPy array
    context = param(
        f = np.array([
            [1, 2, 3, 4],
            [5, 6, 7, 8],
            [9, 10, 11, 12],
            [13, 14, 15, 16]
        ])
    )
    # Example expressions
    expressions = [
        &#34;${a[1]}&#34;,                # Should return 0.2 (assuming &#39;a&#39; is defined in context)
        &#34;${b[0,1]} + ${a[0]}&#34;,    # Should return 1.2 (assuming &#39;b&#39; and &#39;a&#39; are defined)
        &#34;${f[0:2,1]}&#34;               # Should return the second column of &#39;f&#39;
    ]
    # Assuming &#39;a&#39; and &#39;b&#39; are defined in the context
    context.update(
        a =[1.0, 0.2, 0.03, 0.004],
        b = np.array([[1, 0.2, 0.03, 0.004]])
    )
    for expr in expressions:
        result = param.safe_fstring(expr, context)
        print(f&#34;Expression: {expr} =&gt; Result: {result}&#34;)

    # OUTPUT
    #   -------------:----------------------------------------
    # Expression: ${a[1]} =&gt; Result: 0.2
    # Expression: ${b[0,1]} + ${a[0]} =&gt; Result: 0.2 + 1.0
    # Expression: ${f[0:2,1]} =&gt; Result: [2, 6]
    #   -------------:----------------------------------------

    # Example with matrix operations
    p=param()
    p.a = [1.0, .2, .03, .004]
    p.b = np.array([p.a])
    p.c = p.a*2
    p.d = p.b*2
    p.e = p.b.T
    p.f = p.b.T@p.b # Matrix multiplication for (3x1) @ (1x3)
    p.g = &#34;${a[1]}&#34;
    p.h = &#34;${b[0,1]} + ${a[0]}&#34;
    p.i = &#34;${f[0,1]}&#34;
    p.j = &#34;${f[:,1]}&#34;
    p.k = &#34;@{j}+1&#34;  # note that &#34;@{j}+1&#34; and &#34;${j}+1&#34; do not have the same meaning
    p.l = &#34;${b.T}&#34;
    p.m = &#34;${b.T @ b}&#34;    # evaluate fully the matrix operation
    p.n = &#34;${b.T} @ ${b}&#34; # concatenate two string-results separated by @
    p.o =&#34;the result is: ${b[0,1]} + ${a[0]}&#34;
    p.p = &#34;the value of a[0] is ${a[0]}&#34;
    p.q = &#34;1+1&#34;
    print(repr(p))

    # OUTPUT
    #   -------------:----------------------------------------
    #               a: [1.0, 0.2, 0.03, 0.004]
    #               b: [1 0.2 0.03 0.004] (double)
    #               c: [1.0, 0.2, 0.03, 0.0 [...] 0, 0.2, 0.03, 0.004]
    #               d: [2 0.4 0.06 0.008] (double)
    #               e: [1 0.2 0.03 0.004]T (double)
    #               f: [4×4 double]
    #               g: ${a[1]}
    #                = 0.2
    #               h: ${b[0,1]} + ${a[0]}
    #                = 1.2
    #               i: ${f[0,1]}
    #                = 0.2
    #               j: ${f[:,1]}
    #                = [0.2, 0.040000000000 [...] 0001, 0.006, 0.0008]
    #               k: ${j}+1
    #                = [0.2, 0.040000000000 [...] 01, 0.006, 0.0008]+1
    #               l: ${b.T}
    #                = [[1.   ], [0.2  ], [0.03 ], [0.004]]
    #               m: ${b.T @ b}
    #                = [[1.0, 0.2, 0.03, 0. [...] , 0.00012, 1.6e-05]]
    #               n: ${b.T} @ ${b}
    #                = [[1.   ], [0.2  ], [ [...]  0.2   0.03  0.004]]
    #               o: the result is: ${b[0,1]} + ${a[0]}
    #                = the result is: 0.2 + 1.0
    #               p: the value of a[0] is ${a[0]}
    #                = the value of a[0] is 1.0
    #               q: 1+1
    #                = 2
    #   -------------:----------------------------------------
    # parameter list (param object) with 17 definitions


# Example with new NumPy shorthands
    p = param(debug=True);
    p.a = 1.0
    p.b = &#34;10.0&#34;
    p.c = &#34;$[${a},2,3]*${b}&#34; # Create a Numpy vector from an operation
    p.n = &#34;$[0,0,1]&#34;         # another one
    p.o1 = &#34;@{n}&#34;          # create a copy
    p.o2 = &#34;$[${a},2,3]&#34; # create a Numpy vector
    p.o3 = &#34;@{o1} @ @{o2}.T&#34; # multiplication between two vectots
    p.d = &#34;@{n}.T @ $[[${a},2,3]]&#34; # another one
    p.f = &#34;($[${a},2,3]*${b}) @ np.array([[0,0,1]]).T&#34; # another one using explicitly NumPy
    p.nT = &#34;@{n}.T&#34; # transpose of a vector/matrix
    p.m = &#34;${n.T}*2&#34; # this operation is illegal and will be kept as a string
    p.o = &#34;@{n}.T*2&#34; # this one is the correct one
    p.p = &#34;$[[1,2],[3,4]]&#34; # Create a 2D Numpy array
    p.q = &#34;${p[1,1]}&#34;   # index a 2D NumPy array
    p.r = &#34;${p[:,1]}&#34;   # this is a valid syntax to get the slice as a list
    p.s = &#34;@{p}[:,1]+1&#34; # use this syntax if you need apply an operation to the slice
    # more advanced
    p.V1 = &#34;$[1.0,0.2,0.03]&#34;
    p.V2 = &#34;@{V1}+1&#34;
    p.V3 = &#34;@{V1}.T @ @{V2}&#34;
    p.V4 = &#34;np.diag(@{V3})&#34;
    p.V5 = &#34;np.linalg.eig(@{V3})&#34;
    p.out = &#34;the first eigenvalue is: ${V5.eigenvalues[0]}&#34;
    print(repr(p))


    # OUTPUT with DEBUG MESSAGES
    # DEBUG m: Error in Evaluating: [[0]
    #  [0]
    #  [1]]*2
    # &lt; Invalid index 1 for object of type int: &#39;int&#39; object is not subscriptable &gt;
    # DEBUG out: Error in Evaluating: the first eigenvalue is: 2.0
    # &lt; invalid syntax (&lt;unknown&gt;, line 1) &gt;
    #   -------------:----------------------------------------
    #               a: 1.0
    #               b: 10.0
    #                = 10.0
    #               c: $[${a},2,3]*${b}
    #                = [10 20 30] (double)
    #               n: $[0,0,1]
    #                = [0 0 1] (int64)
    #              o1: @{n}
    #                = [0 0 1] (int64)
    #              o2: $[${a},2,3]
    #                = [1 2 3] (double)
    #              o3: @{o1} @ @{o2}.T
    #                = 3.0 (double)
    #               d: @{n}.T @ $[[${a},2,3]]
    #                = [3×3 double]
    #               f: ($[${a},2,3]*${b}) @ [...] p.array([[0,0,1]]).T
    #                = 30.0 (double)
    #              nT: @{n}.T
    #                = [0 0 1]T (int64)
    #               m: ${n.T}*2
    #                = [[0], [0], [1]]*2
    #               o: @{n}.T*2
    #                = [0 0 2]T (int64)
    #               p: $[[1,2],[3,4]]
    #                = [2×2 int64]
    #               q: ${p[1,1]}
    #                = 4
    #               r: ${p[:,1]}
    #                = [2, 4]
    #               s: @{p}[:,1]+1
    #                = [3 5] (int64)
    #              V1: $[1.0,0.2,0.03]
    #                = [1 0.2 0.03] (double)
    #              V2: @{V1}+1
    #                = [2 1.2 1.03] (double)
    #              V3: @{V1}.T @ @{V2}
    #                = [3×3 double]
    #              V4: np.diag(@{V3})
    #                = [2 0.24 0.0309] (double)
    #              V5: np.linalg.eig(@{V3})
    #                = EigResult(eigenvalue [...] 332, -0.06057363]]))
    #             out: the first eigenvalue is: ${V3[0,0]}
    #                = the first eigenvalue is: 2.0
    #   -------------:----------------------------------------
    # parameter list (param object) with 22 definitions

# Advanced NumPy example

    p = param(debug=True)
    p.p = &#34;$[[1, 2], [3, 4]]&#34;      # Create a 2D NumPy array
    p.q = &#34;${p[1, 1]}&#34;             # Indexing: retrieves 4
    p.r = &#34;@{p}[:,1] + 1&#34;          # Add 1 to the second column
    p.s = &#34;@{p}[:, 1].reshape(-1, 1) @ @{r}&#34; # perform p(:,1)&#39;*s in Matlab sense
    p.t = &#34;np.linalg.eig(@{s})&#34;
    p.w = &#34;${t.eigenvalues[0]} + ${t.eigenvalues[1]}&#34; # sum of eigen values
    p.x = &#34;$[[0,${t.eigenvalues[0]}+${t.eigenvalues[1]}]]&#34; # horizontal concat à la Matlab
    print(repr(p))

    # Output
  #   -------------:----------------------------------------
  #               p: $[[1, 2], [3, 4]]
  #                = [2×2 int64]
  #               q: ${p[1, 1]}
  #                = 4
  #               r: @{p}[:,1] + 1
  #                = [3 5] (int64)
  #               s: @{p}[:, 1].reshape(-1, 1) @ @{r}
  #                = [2×2 int64]
  #               t: np.linalg.eig(@{s})
  #                = EigResult(eigenvalue [...] 576, -0.89442719]]))
  #               w: ${t.eigenvalues[0]}  [...]  ${t.eigenvalues[1]}
  #                = 26.0
  #               x: $[[0,${t.eigenvalues [...] {t.eigenvalues[1]}]]
  #                = [0 26] (double)
  #   -------------:----------------------------------------
  # parameter list (param object) with 7 definitions


#%% Math example with DSCRIPT (pending) - v 1.005
    from patanakar.dscript import dscript
    from patanakar.private.mstruct import param

    D = dscript(name=&#34;math example&#34;)

    # The definitions are given with hybrid Matlab/NumPy notations
    D.DEFINITIONS.l = [1e-3, 2e-3, 3e-3]    # l is defined as a list
    D.DEFINITIONS.a = &#34;$[1 2 3]&#34;            # a is defined with  Matlab notations
    D.DEFINITIONS.b = &#34;$[1:3]&#34;              # b is defined with  Matlab notations
    D.DEFINITIONS.c = &#34;$[0.1:0.1:0.9]&#34;      # c is defined with  Matlab notations
    D.DEFINITIONS.scale = &#34;@{l}*2*@{a}&#34;     # l is rescaled
    D.DEFINITIONS.x0 = &#34;$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*${scale[0,0]}*${a[0,0]}&#34;
    D.DEFINITIONS.y0 = &#34;$[[[-0.5, -0.5],[0.5, 0.5]],[[ -0.5,  -0.5],[ 0.5,  0.5]]]*${scale[0,1]}*${a[0,1]}&#34;
    D.DEFINITIONS.z0 = &#34;$[[-0.5 0.5 ;-0.5 0.5],[ -0.5,  0.5;  -0.5,  0.5]]*${l[2]}*${a[0,2]}&#34;
    D.DEFINITIONS.X0 = &#34;@{x0}.flatten()&#34;
    D.DEFINITIONS.Y0 = &#34;@{y0}.flatten()&#34;
    D.DEFINITIONS.Z0 = &#34;@{z0}.flatten()&#34;
    T = D.DEFINITIONS.eval()
    D.DEFINITIONS.x0
    T.x0
    print(repr(D.DEFINITIONS))

    # Output
    #  -------------:----------------------------------------
    #              l: [0.001, 0.002, 0.003]
    #              a: $[1 2 3]
    #              = [1 2 3] (int64)
    #             b: $[1:3]
    #              = [1 2 3] (int64)
    #             c: $[0.1:0.1:0.9]
    #              = [0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9] (double)
    #         scale: @{l}*2*@{a}
    #              = [0.002 0.008 0.018] (double)
    #            x0: $[[[-0.5, -0.5],[-0. [...] cale[0,0]}*${a[0,0]}
    #              = [[2×2 matrix] [2×2 matrix]] (2×2×2 double)
    #            y0: $[[[-0.5, -0.5],[0.5 [...] cale[0,1]}*${a[0,1]}
    #              = [[2×2 matrix] [2×2 matrix]] (2×2×2 double)
    #            z0: $[[-0.5 0.5 ;-0.5 0. [...] ]]*${l[2]}*${a[0,2]}
    #              = [[2×2 matrix] [2×2 matrix]] (2×2×2 double)
    #            X0: @{x0}.flatten()
    #              = [-0.001 -0.001 -0.001 -0.001 0.001 0.001 0.001 0.001] (double)
    #            Y0: @{y0}.flatten()
    #              = [-0.008 -0.008 0.008 0.008 -0.008 -0.008 0.008 0.008] (double)
    #            Z0: @{z0}.flatten()
    #              = [-0.0045 0.0045 -0.0045 0.0045 -0.0045 0.0045 -0.0045 0.0045] (double)
    #  -------------:----------------------------------------</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mstruct.evaluate_with_placeholders"><code class="name flex">
<span>def <span class="ident">evaluate_with_placeholders</span></span>(<span>text, evaluator, evaluator_nocontext=&lt;mstruct.SafeEvaluator object&gt;, raiseerror=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates only unescaped placeholders of the form ${&hellip;} in the input text.
Escaped placeholders (\${&hellip;}) are left as literal text (after removing the escape).</p>
<p>Note1 : ${ &hellip; } can be ${var} or an expressions such as ${var1+var2}
Note2 : a full evaluation is attempted only after the full evaluation using the same
evaluator without context</p>
<h2 id="example">Example</h2>
<p>context = {'a': 10, 'b': 5}
evaluator = SafeEvaluator(context)
evaluator_nocontext = SafeEvaluator()</p>
<p>text = "Evaluated variable: ${a} and literal: \${a} and sum: ${a + b}, leave intact a+b, ${a}+${b}"
processed_text = evaluate_with_placeholders(text, evaluator)
print(processed_text)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_with_placeholders(text, evaluator, evaluator_nocontext=SafeEvaluator(),raiseerror=False):
    &#34;&#34;&#34;
    Evaluates only unescaped placeholders of the form ${...} in the input text.
    Escaped placeholders (\\${...}) are left as literal text (after removing the escape).

    Note1 : ${ ... } can be ${var} or an expressions such as ${var1+var2}
    Note2 : a full evaluation is attempted only after the full evaluation using the same
    evaluator without context

    Example:

        context = {&#39;a&#39;: 10, &#39;b&#39;: 5}
        evaluator = SafeEvaluator(context)
        evaluator_nocontext = SafeEvaluator()

        text = &#34;Evaluated variable: ${a} and literal: \\${a} and sum: ${a + b}, leave intact a+b, ${a}+${b}&#34;
        processed_text = evaluate_with_placeholders(text, evaluator)
        print(processed_text)

    &#34;&#34;&#34;
    # Pattern explanation:
    #   (?&lt;!\\)   : Negative lookbehind to ensure the &#39;${&#39; is not preceded by a backslash.
    #   (\$\{([^}]+)\}) : Captures the full placeholder in group 1 and the inner expression in group 2.
    pattern = r&#39;(?&lt;!\\)(\$\{([^}]+)\})&#39;

    def replace_placeholder(match):
        # Extract the inner expression from the placeholder.
        expr = match.group(2)
        # Evaluate the expression using your SafeEvaluator instance.
        try:
            value = evaluator.evaluate(expr)
        except Exception as e:
            raise ValueError(f&#34;Error evaluating expression &#39;{expr}&#39;: {e}&#34;)
        return str(value)

    # String Interpolation: Replace unescaped placeholders with their evaluated results.
    result = re.sub(pattern, replace_placeholder, text)
    # Finally, unescape the escaped placeholders: replace &#34;\${&#34; with &#34;${&#34;.
    result = result.replace(r&#39;\${&#39;, &#39;${&#39;)
    # Full evaluation if possible
    if raiseerror:
        return evaluator_nocontext.evaluate(result)
    else:
        try:
            return evaluator_nocontext.evaluate(result)
        except Exception:
            return result</code></pre>
</details>
</dd>
<dt id="mstruct.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if value is considered empty (None, "", [] or ()).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(value):
    &#34;&#34;&#34;Return True if value is considered empty (None, &#34;&#34;, [] or ()).&#34;&#34;&#34;
    return value is None or value == &#34;&#34; or value == [] or value == ()</code></pre>
</details>
</dd>
<dt id="mstruct.is_literal_string"><code class="name flex">
<span>def <span class="ident">is_literal_string</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns True if the first non-blank character in the string is '$'
and it is not immediately followed by '{' or '['.</p>
<h2 id="parameters">Parameters</h2>
<p>s (str): The string to check.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the condition is met, otherwise False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_literal_string(s):
    &#34;&#34;&#34;
    Returns True if the first non-blank character in the string is &#39;$&#39;
    and it is not immediately followed by &#39;{&#39; or &#39;[&#39;.

    Parameters:
        s (str): The string to check.

    Returns:
        bool: True if the condition is met, otherwise False.
    &#34;&#34;&#34;
    stripped = s.lstrip()  # Remove leading whitespace
    if not stripped:
        return False
    if stripped[0] != &#39;$&#39;:
        return False
    # If there is a character following &#39;$&#39;, ensure it&#39;s not &#39;{&#39; or &#39;[&#39;.
    if len(stripped) &gt; 1 and stripped[1] in (&#39;{&#39;, &#39;[&#39;):
        return False
    return True</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mstruct.AttrErrorDict"><code class="flex name class">
<span>class <span class="ident">AttrErrorDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom dictionary that raises AttributeError (as required for the logic of struct)
instead of KeyError for missing keys and strips quotes from strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AttrErrorDict(dict):
    &#34;&#34;&#34;Custom dictionary that raises AttributeError (as required for the logic of struct)
       instead of KeyError for missing keys and strips quotes from strings.&#34;&#34;&#34;
    def __getitem__(self, key):
        try:
            value = super().__getitem__(key)
            if isinstance(value, str):
                # Strip surrounding single or double quotes if present
                if (value.startswith(&#34;&#39;&#34;) and value.endswith(&#34;&#39;&#34;)) or (value.startswith(&#39;&#34;&#39;) and value.endswith(&#39;&#34;&#39;)):
                    return value[1:-1]
                return value
            return value
        except KeyError:
            raise AttributeError(f&#34;Attribute &#39;{key}&#39; not found&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
<dt id="mstruct.SafeEvaluator"><code class="flex name class">
<span>class <span class="ident">SafeEvaluator</span></span>
<span>(</span><span>context={})</span>
</code></dt>
<dd>
<div class="desc"><p>A safe evaluator class for expressions involving math, NumPy, random, and basic operators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SafeEvaluator(ast.NodeVisitor):
    &#34;&#34;&#34;A safe evaluator class for expressions involving math, NumPy, random, and basic operators.&#34;&#34;&#34;

    def __init__(self, context={}):
        self.context = {**context}
        # Update context with math functions/constants from _all_math_names that exist in math module.
        self.context.update({
            name: getattr(math, name)
            for name in _all_math_names if hasattr(math, name)
        })
        # Add built-in functions relevant for math that are not part of the math module.
        for name in (&#34;abs&#34;, &#34;round&#34;, &#34;min&#34;, &#34;max&#34;, &#34;sum&#34;, &#34;divmod&#34;):
            self.context[name] = getattr(builtins, name)

        self.context.update({
            &#34;gauss&#34;: random.gauss,
            &#34;uniform&#34;: random.uniform,
            &#34;randint&#34;: random.randint,
            &#34;choice&#34;: random.choice
        })
        # Add NumPy as np
        self.context[&#34;np&#34;] = np  # Allow &#39;np.sin&#39;, &#39;np.cos&#39;, etc.
        # Define allowed operators
        self.operators = {
            ast.Add: operator.add,
            ast.Sub: operator.sub,
            ast.Mult: operator.mul,
            ast.Div: operator.truediv,
            ast.FloorDiv: operator.floordiv,
            ast.Mod: operator.mod,
            ast.Pow: operator.pow,
            ast.USub: operator.neg,  # Unary subtraction
        }

    def visit_Name(self, node):
        if node.id in self.context:
            return self.context[node.id]
        raise ValueError(f&#34;Variable or function &#39;{node.id}&#39; is not defined&#34;)

    def visit_Constant(self, node):
        return node.value

    def visit_BinOp(self, node):
        left = self.visit(node.left)
        right = self.visit(node.right)
        op_type = type(node.op)
        if isinstance(left, np.ndarray) and isinstance(right, np.ndarray) and isinstance(node.op, ast.MatMult):
            return np.matmul(left, right)
        if op_type in self.operators:
            return self.operators[op_type](left, right)
        raise ValueError(f&#34;Unsupported operator: {op_type}&#34;)

    def visit_UnaryOp(self, node):
        operand = self.visit(node.operand)
        op_type = type(node.op)
        if op_type in self.operators:
            return self.operators[op_type](operand)
        raise ValueError(f&#34;Unsupported unary operator: {op_type}&#34;)

    def visit_Call(self, node):
        func = self.visit(node.func)
        if callable(func):
            args = [self.visit(arg) for arg in node.args]
            kwargs = {kw.arg: self.visit(kw.value) for kw in node.keywords}
            return func(*args, **kwargs)
        raise ValueError(f&#34;Function &#39;{ast.dump(node.func)}&#39; is not callable&#34;)

    def visit_Attribute(self, node):
        value = self.visit(node.value)
        attr = node.attr
        if hasattr(value, attr):
            # If the attribute is &#34;T&#34;, return the transpose of the array
            if attr == &#34;T&#34; and isinstance(value, np.ndarray):
                return value.T
            # Check if the attribute is the &#39;@&#39; matrix multiplication operator
            if attr == &#34;@&#34; and isinstance(value, np.ndarray):
                return value @ value  # or handle accordingly with another operand
            return getattr(value, attr)
        raise ValueError(f&#34;Object &#39;{value}&#39; has no attribute &#39;{attr}&#39;&#34;)

    def visit_Subscript(self, node):
        value = self.visit(node.value)
        slice_obj = self.visit(node.slice)
        try:
            return value[slice_obj]
        except Exception as e:
            raise ValueError(f&#34;Invalid index {slice_obj} for object of type {type(value).__name__}: {e}&#34;)

    def visit_Index(self, node):
        return self.visit(node.value)

    def visit_Slice(self, node):
        lower = self.visit(node.lower) if node.lower else None
        upper = self.visit(node.upper) if node.upper else None
        step = self.visit(node.step) if node.step else None
        return slice(lower, upper, step)

    def visit_ExtSlice(self, node):
        dims = tuple(self.visit(dim) for dim in node.dims)
        return dims

    def visit_Tuple(self, node):
        return tuple(self.visit(elt) for elt in node.elts)

    def visit_List(self, node):
        return [self.visit(elt) for elt in node.elts]

    def visit_Dict(self, node):
        &#34;&#34;&#34;
        Evaluate a dictionary expression by safely evaluating each key and value.
        This allows expressions like: {&#34;a&#34;: ${v1}+${v2}, &#34;b&#34;: ${var}}.
        &#34;&#34;&#34;
        return {self.visit(key): self.visit(value) for key, value in zip(node.keys, node.values)}

    def generic_visit(self, node):
        raise ValueError(f&#34;Unsupported expression: {ast.dump(node)}&#34;)

    def evaluate(self, expression):
        tree = ast.parse(expression, mode=&#39;eval&#39;)
        return self.visit(tree.body)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>ast.NodeVisitor</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mstruct.SafeEvaluator.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, expression)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, expression):
    tree = ast.parse(expression, mode=&#39;eval&#39;)
    return self.visit(tree.body)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.generic_visit"><code class="name flex">
<span>def <span class="ident">generic_visit</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Called if no explicit visitor function exists for a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_visit(self, node):
    raise ValueError(f&#34;Unsupported expression: {ast.dump(node)}&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Attribute"><code class="name flex">
<span>def <span class="ident">visit_Attribute</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Attribute(self, node):
    value = self.visit(node.value)
    attr = node.attr
    if hasattr(value, attr):
        # If the attribute is &#34;T&#34;, return the transpose of the array
        if attr == &#34;T&#34; and isinstance(value, np.ndarray):
            return value.T
        # Check if the attribute is the &#39;@&#39; matrix multiplication operator
        if attr == &#34;@&#34; and isinstance(value, np.ndarray):
            return value @ value  # or handle accordingly with another operand
        return getattr(value, attr)
    raise ValueError(f&#34;Object &#39;{value}&#39; has no attribute &#39;{attr}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_BinOp"><code class="name flex">
<span>def <span class="ident">visit_BinOp</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_BinOp(self, node):
    left = self.visit(node.left)
    right = self.visit(node.right)
    op_type = type(node.op)
    if isinstance(left, np.ndarray) and isinstance(right, np.ndarray) and isinstance(node.op, ast.MatMult):
        return np.matmul(left, right)
    if op_type in self.operators:
        return self.operators[op_type](left, right)
    raise ValueError(f&#34;Unsupported operator: {op_type}&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Call"><code class="name flex">
<span>def <span class="ident">visit_Call</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Call(self, node):
    func = self.visit(node.func)
    if callable(func):
        args = [self.visit(arg) for arg in node.args]
        kwargs = {kw.arg: self.visit(kw.value) for kw in node.keywords}
        return func(*args, **kwargs)
    raise ValueError(f&#34;Function &#39;{ast.dump(node.func)}&#39; is not callable&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Constant"><code class="name flex">
<span>def <span class="ident">visit_Constant</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Constant(self, node):
    return node.value</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Dict"><code class="name flex">
<span>def <span class="ident">visit_Dict</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate a dictionary expression by safely evaluating each key and value.
This allows expressions like: {"a": ${v1}+${v2}, "b": ${var}}.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Dict(self, node):
    &#34;&#34;&#34;
    Evaluate a dictionary expression by safely evaluating each key and value.
    This allows expressions like: {&#34;a&#34;: ${v1}+${v2}, &#34;b&#34;: ${var}}.
    &#34;&#34;&#34;
    return {self.visit(key): self.visit(value) for key, value in zip(node.keys, node.values)}</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_ExtSlice"><code class="name flex">
<span>def <span class="ident">visit_ExtSlice</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_ExtSlice(self, node):
    dims = tuple(self.visit(dim) for dim in node.dims)
    return dims</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Index"><code class="name flex">
<span>def <span class="ident">visit_Index</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Index(self, node):
    return self.visit(node.value)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_List"><code class="name flex">
<span>def <span class="ident">visit_List</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_List(self, node):
    return [self.visit(elt) for elt in node.elts]</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Name"><code class="name flex">
<span>def <span class="ident">visit_Name</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Name(self, node):
    if node.id in self.context:
        return self.context[node.id]
    raise ValueError(f&#34;Variable or function &#39;{node.id}&#39; is not defined&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Slice"><code class="name flex">
<span>def <span class="ident">visit_Slice</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Slice(self, node):
    lower = self.visit(node.lower) if node.lower else None
    upper = self.visit(node.upper) if node.upper else None
    step = self.visit(node.step) if node.step else None
    return slice(lower, upper, step)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Subscript"><code class="name flex">
<span>def <span class="ident">visit_Subscript</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Subscript(self, node):
    value = self.visit(node.value)
    slice_obj = self.visit(node.slice)
    try:
        return value[slice_obj]
    except Exception as e:
        raise ValueError(f&#34;Invalid index {slice_obj} for object of type {type(value).__name__}: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_Tuple"><code class="name flex">
<span>def <span class="ident">visit_Tuple</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_Tuple(self, node):
    return tuple(self.visit(elt) for elt in node.elts)</code></pre>
</details>
</dd>
<dt id="mstruct.SafeEvaluator.visit_UnaryOp"><code class="name flex">
<span>def <span class="ident">visit_UnaryOp</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visit_UnaryOp(self, node):
    operand = self.visit(node.operand)
    op_type = type(node.op)
    if op_type in self.operators:
        return self.operators[op_type](operand)
    raise ValueError(f&#34;Unsupported unary operator: {op_type}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mstruct.param"><code class="flex name class">
<span>class <span class="ident">param</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-param">Class: <code><a title="mstruct.param" href="#mstruct.param">param</a></code></h1>
<p>A class derived from <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code> that introduces dynamic evaluation of field values.
The <code><a title="mstruct.param" href="#mstruct.param">param</a></code> class acts as a container for evaluated parameters, allowing expressions
to depend on other fields. It supports advanced evaluation, sorting of dependencies,
and text formatting.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Inherits all functionalities of <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code>.</li>
<li>Supports dynamic evaluation of field expressions.</li>
<li>Automatically resolves dependencies between fields.</li>
<li>Includes utility methods for text formatting and evaluation.</li>
</ul>
<h3 id="shorthands-for-pparam">Shorthands for <code>p=param(...)</code></h3>
<ul>
<li><code>s = p.eval()</code> returns the full evaluated structure</li>
<li><code>p.getval("field")</code> returns the evaluation for the field "field"</li>
<li><code>s = p()</code> returns the full evaluated structure as <code>p.eval()</code></li>
<li><code>s = p("field1","field2"...)</code> returns the evaluated substructure for fields "field1", "field2"</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage-with-evaluation">Basic Usage with Evaluation</h4>
<pre><code class="language-python">s = param(a=1, b=2, c='${a} + ${b} # evaluate me if you can', d=&quot;$this is a string&quot;, e=&quot;1000 # this is my number&quot;)
s.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 3)
#      d: $this is a string (= this is a string)
#      e: 1000 # this is my number (= 1000)
# --------

s.a = 10
s.eval()
# Output:
# --------
#      a: 10
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 12)
#      d: $this is a string (= this is a string)
#      e: 1000 # this is my number (= 1000)
# --------
</code></pre>
<h4 id="handling-text-parameters">Handling Text Parameters</h4>
<pre><code class="language-python">s = param()
s.mypath = &quot;$/this/folder&quot;
s.myfile = &quot;$file&quot;
s.myext = &quot;$ext&quot;
s.fullfile = &quot;$${mypath}/${myfile}.${myext}&quot;
s.eval()
# Output:
# --------
#    mypath: $/this/folder (= /this/folder)
#    myfile: $file (= file)
#     myext: $ext (= ext)
#  fullfile: $${mypath}/${myfile}.${myext} (= /this/folder/file.ext)
# --------
</code></pre>
<hr>
<h3 id="text-evaluation-and-formatting">Text Evaluation and Formatting</h3>
<h4 id="evaluate-strings">Evaluate Strings</h4>
<pre><code class="language-python">s = param(a=1, b=2)
result = s.eval(&quot;this is a string with ${a} and ${b}&quot;)
print(result)  # &quot;this is a string with 1 and 2&quot;
</code></pre>
<h4 id="prevent-evaluation">Prevent Evaluation</h4>
<pre><code class="language-python">definitions = param(a=1, b=&quot;${a}*10+${a}&quot;, c=&quot;\${a}+10&quot;, d='\${myparam}')
text = definitions.formateval(&quot;this is my text ${a}, ${b}, \${myvar}=${c}+${d}&quot;)
print(text)  # &quot;this is my text 1, 11, \${myvar}=\${a}+10+${myparam}&quot;
</code></pre>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="rearranging-and-sorting-definitions">Rearranging and Sorting Definitions</h4>
<pre><code class="language-python">s = param(
    a=1,
    f=&quot;${e}/3&quot;,
    e=&quot;${a}*${c}&quot;,
    c=&quot;${a}+${b}&quot;,
    b=2,
    d=&quot;${c}*2&quot;
)
s.sortdefinitions()
s.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} (= 3)
#      d: ${c} * 2 (= 6)
#      e: ${a} * ${c} (= 3)
#      f: ${e} / 3 (= 1.0)
# --------
</code></pre>
<h4 id="internal-evaluation-and-recursion-with">Internal Evaluation and Recursion with !</h4>
<pre><code class="language-python">p=param()
p.a = [0,1,2]
p.b = '![1,2,&quot;test&quot;,&quot;${a[1]}&quot;]'
p
# Output:
#  -------------:----------------------------------------
#          a: [0, 1, 2]
#          b: ![1,2,&quot;test&quot;,&quot;${a[1]}&quot;]
#           = [1, 2, 'test', '1']
#  -------------:----------------------------------------
# Out: parameter list (param object) with 2 definitions
</code></pre>
<h4 id="error-handling">Error Handling</h4>
<pre><code class="language-python">p = param(b=&quot;${a}+1&quot;, c=&quot;${a}+${d}&quot;, a=1)
p.disp()
# Output:
# --------
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
#      a: 1
# --------
</code></pre>
<p>Sorting unresolved definitions raises errors unless explicitly suppressed:</p>
<pre><code class="language-python">p.sortdefinitions(raiseerror=False)
# WARNING: unable to interpret 1/3 expressions in &quot;definitions&quot;
</code></pre>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eval()</code></td>
<td>Evaluate all field expressions.</td>
</tr>
<tr>
<td><code>formateval(string)</code></td>
<td>Format and evaluate a string with field placeholders.</td>
</tr>
<tr>
<td><code>protect(string)</code></td>
<td>Escape variable placeholders in a string.</td>
</tr>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Sort definitions to resolve dependencies.</td>
</tr>
<tr>
<td><code>escape(string)</code></td>
<td>Protect escaped variables in a string.</td>
</tr>
<tr>
<td><code>safe_fstring(string)</code></td>
<td>evaluate safely complex mathemical expressions.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="overloaded-methods-and-operators">Overloaded Methods and Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenation of two parameter lists, sorting definitions.</li>
<li><code>-</code>: Subtraction of fields.</li>
<li><code>len()</code>: Number of fields.</li>
<li><code>in</code>: Check for field existence.</li>
</ul>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>The <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> class simplifies handling of partial definitions and inherits from <code><a title="mstruct.param" href="#mstruct.param">param</a></code>.</li>
<li>Use <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> when definitions need to be stacked irrespective of execution order.</li>
</ul>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class param(struct):
    &#34;&#34;&#34;
    Class: `param`
    ==============

    A class derived from `struct` that introduces dynamic evaluation of field values.
    The `param` class acts as a container for evaluated parameters, allowing expressions
    to depend on other fields. It supports advanced evaluation, sorting of dependencies,
    and text formatting.

    ---

    ### Features
    - Inherits all functionalities of `struct`.
    - Supports dynamic evaluation of field expressions.
    - Automatically resolves dependencies between fields.
    - Includes utility methods for text formatting and evaluation.

    ### Shorthands for `p=param(...)`
    - `s = p.eval()` returns the full evaluated structure
    - `p.getval(&#34;field&#34;)` returns the evaluation for the field &#34;field&#34;
    - `s = p()` returns the full evaluated structure as `p.eval()`
    - `s = p(&#34;field1&#34;,&#34;field2&#34;...)` returns the evaluated substructure for fields &#34;field1&#34;, &#34;field2&#34;

    ---

    ### Examples

    #### Basic Usage with Evaluation
    ```python
    s = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;, d=&#34;$this is a string&#34;, e=&#34;1000 # this is my number&#34;)
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------

    s.a = 10
    s.eval()
    # Output:
    # --------
    #      a: 10
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 12)
    #      d: $this is a string (= this is a string)
    #      e: 1000 # this is my number (= 1000)
    # --------
    ```

    #### Handling Text Parameters
    ```python
    s = param()
    s.mypath = &#34;$/this/folder&#34;
    s.myfile = &#34;$file&#34;
    s.myext = &#34;$ext&#34;
    s.fullfile = &#34;$${mypath}/${myfile}.${myext}&#34;
    s.eval()
    # Output:
    # --------
    #    mypath: $/this/folder (= /this/folder)
    #    myfile: $file (= file)
    #     myext: $ext (= ext)
    #  fullfile: $${mypath}/${myfile}.${myext} (= /this/folder/file.ext)
    # --------
    ```

    ---

    ### Text Evaluation and Formatting

    #### Evaluate Strings
    ```python
    s = param(a=1, b=2)
    result = s.eval(&#34;this is a string with ${a} and ${b}&#34;)
    print(result)  # &#34;this is a string with 1 and 2&#34;
    ```

    #### Prevent Evaluation
    ```python
    definitions = param(a=1, b=&#34;${a}*10+${a}&#34;, c=&#34;\\${a}+10&#34;, d=&#39;\\${myparam}&#39;)
    text = definitions.formateval(&#34;this is my text ${a}, ${b}, \\${myvar}=${c}+${d}&#34;)
    print(text)  # &#34;this is my text 1, 11, \\${myvar}=\\${a}+10+${myparam}&#34;
    ```

    ---

    ### Advanced Usage

    #### Rearranging and Sorting Definitions
    ```python
    s = param(
        a=1,
        f=&#34;${e}/3&#34;,
        e=&#34;${a}*${c}&#34;,
        c=&#34;${a}+${b}&#34;,
        b=2,
        d=&#34;${c}*2&#34;
    )
    s.sortdefinitions()
    s.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} (= 3)
    #      d: ${c} * 2 (= 6)
    #      e: ${a} * ${c} (= 3)
    #      f: ${e} / 3 (= 1.0)
    # --------
    ```

    #### Internal Evaluation and Recursion with !
    ```python
    p=param()
    p.a = [0,1,2]
    p.b = &#39;![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]&#39;
    p
    # Output:
    #  -------------:----------------------------------------
    #          a: [0, 1, 2]
    #          b: ![1,2,&#34;test&#34;,&#34;${a[1]}&#34;]
    #           = [1, 2, &#39;test&#39;, &#39;1&#39;]
    #  -------------:----------------------------------------
    # Out: parameter list (param object) with 2 definitions
    ```

    #### Error Handling
    ```python
    p = param(b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;, a=1)
    p.disp()
    # Output:
    # --------
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      a: 1
    # --------
    ```

    Sorting unresolved definitions raises errors unless explicitly suppressed:
    ```python
    p.sortdefinitions(raiseerror=False)
    # WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
    ```

    ---

    ### Utility Methods
    | Method                 | Description                                             |
    |------------------------|---------------------------------------------------------|
    | `eval()`               | Evaluate all field expressions.                         |
    | `formateval(string)`   | Format and evaluate a string with field placeholders.   |
    | `protect(string)`      | Escape variable placeholders in a string.               |
    | `sortdefinitions()`    | Sort definitions to resolve dependencies.               |
    | `escape(string)`       | Protect escaped variables in a string.                  |
    | `safe_fstring(string)` | evaluate safely complex mathemical expressions.         |

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two parameter lists, sorting definitions.
    - `-`: Subtraction of fields.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Notes
    - The `paramauto` class simplifies handling of partial definitions and inherits from `param`.
    - Use `paramauto` when definitions need to be stacked irrespective of execution order.
    &#34;&#34;&#34;

    # override
    _type = &#34;param&#34;
    _fulltype = &#34;parameter list&#34;
    _ftype = &#34;definition&#34;
    _evalfeature = True    # This class can be evaluated with .eval()
    _returnerror = True    # This class returns an error in the evaluation string (added on 2024-09-06)


    # magic constructor
    def __init__(self,_protection=False,_evaluation=True,
                 sortdefinitions=False,debug=False,**kwargs):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        super().__init__(debug=debug,**kwargs)
        self._protection = _protection
        self._evaluation = _evaluation
        self._needs_sorting = False # defers sorting
        if sortdefinitions: self.sortdefinitions()

    # escape definitions if needed
    @staticmethod
    def escape(s):
        &#34;&#34;&#34;
            escape \\${} as ${{}} --&gt; keep variable names
            convert ${} as {} --&gt; prepare Python replacement

            Examples:
                escape(&#34;\\${a}&#34;)
                returns (&#39;${{a}}&#39;, True)

                escape(&#34;  \\${abc} ${a} \\${bc}&#34;)
                returns (&#39;  ${{abc}} {a} ${{bc}}&#39;, True)

                escape(&#34;${a}&#34;)
                Out[94]: (&#39;{a}&#39;, False)

                escape(&#34;${tata}&#34;)
                returns (&#39;{tata}&#39;, False)

        &#34;&#34;&#34;
        if not isinstance(s,str):
            raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)
        se, start, found = &#34;&#34;, 0, True
        while found:
            pos0 = s.find(r&#34;\${&#34;,start)
            found = pos0&gt;=0
            if found:
                pos1 = s.find(&#34;}&#34;,pos0)
                found = pos1&gt;=0
                if found:
                    se += s[start:pos0].replace(&#34;${&#34;,&#34;{&#34;)+&#34;${{&#34;+s[pos0+3:pos1]+&#34;}}&#34;
                    start=pos1+1
        result = se+s[start:].replace(&#34;${&#34;,&#34;{&#34;)
        if isinstance(s,pstr): result = pstr(result)
        return result,start&gt;0

    # protect variables in a string
    def protect(self,s=&#34;&#34;):
        &#34;&#34;&#34; protect $variable as ${variable} &#34;&#34;&#34;
        if isinstance(s,str):
            t = s.replace(r&#34;\$&#34;,&#34;££&#34;) # &amp;&amp; is a placeholder
            escape = t!=s
            for k in self.keyssorted():
                t = t.replace(&#34;$&#34;+k,&#34;${&#34;+k+&#34;}&#34;)
            if escape: t = t.replace(&#34;££&#34;,r&#34;\$&#34;)
            if isinstance(s,pstr): t = pstr(t)
            return t, escape
        raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)


    # lines starting with # (hash) are interpreted as comments
    # ${variable} or {variable} are substituted by variable.value
    # any line starting with $ is assumed to be a string (no interpretation)
    # ^ is accepted in formula(replaced by **))
    def eval(self,s=&#34;&#34;,protection=False):
        &#34;&#34;&#34;
            Eval method for structure such as MS.alias

                s = p.eval() or s = p.eval(string)

                where :
                    p is a param object
                    s is a structure with evaluated fields
                    string is only used to determine whether definitions have been forgotten

        &#34;&#34;&#34;
        # handle deferred sorting
        if self._needs_sorting:
            self.sortdefinitions(raiseerror=False, silentmode=True)
        # the argument s is only used by formateval() for error management
        tmp = struct(debug=self._debug)
        # evaluator without context
        evaluator_nocontext = SafeEvaluator() # for global evaluation without context

        # main string evaluator
        def evalstr(value,key=&#34;&#34;):
            # replace ${variable} (Bash, Lammps syntax) by {variable} (Python syntax)
            # use \${variable} to prevent replacement (espace with \)
            # Protect variables if required
            ispstr = isinstance(value,pstr)
            valuesafe = pstr.eval(value,ispstr=ispstr) # value.strip()
            if valuesafe==&#34;${&#34;+key+&#34;}&#34;: # circular reference (it cannot be evaluated)
                return valuesafe
            if protection or self._protection:
                valuesafe, escape0 = self.protect(valuesafe)
            else:
                escape0 = False
            # replace ${var} by {var} once basic substitutions have been applied
            valuesafe_priorescape = tmp.numrepl(valuesafe) # minimal substitution
            valuesafe, escape = param.escape(valuesafe_priorescape)
            escape = escape or escape0
            # replace &#34;^&#34; (Matlab, Lammps exponent) by &#34;**&#34; (Python syntax)
            valuesafe = pstr.eval(valuesafe.replace(&#34;^&#34;,&#34;**&#34;),ispstr=ispstr)
            # Remove all content after #
            # if the first character is &#39;#&#39;, it is not comment (e.g. MarkDown titles)
            poscomment = valuesafe.find(&#34;#&#34;)
            if poscomment&gt;0: valuesafe = valuesafe[0:poscomment].strip()
            # Matrix shorthand replacement
            # $[[1,2,${a}]]+$[[10,20,30]] --&gt; np.array([[1,2,${a}]])+np.array([[10,20,30]])
            valuesafe = param.replace_matrix_shorthand(valuesafe)
            # Literal string starts with $ (no interpretation), ! (evaluation)
            if not self._evaluation:
                return pstr.eval(tmp.format(valuesafe,escape),ispstr=ispstr)
            elif valuesafe.startswith(&#34;!&#34;): # &lt;---------- FORECED LITERAL EVALUATION (error messages are returned)
                try:
                    #vtmp = ast.literal_eval(valuesafe[1:])
                    evaluator = SafeEvaluator(tmp)
                    vtmp = evaluate_with_placeholders(valuesafe[1:],evaluator,evaluator_nocontext)
                    if isinstance(vtmp,list):
                        for i,item in enumerate(vtmp):
                            if isinstance(item,str) and not is_literal_string(item):
                                try:
                                    vtmp[i] = tmp.format(item, raiseerror=False) # in case substitions/interpolations are needed
                                    try:
                                        vtmp[i] = evaluator_nocontext.evaluate(vtmp[i]) # full evaluation without context
                                    except Exception as othererr:
                                        if self._debug:
                                            print(f&#34;DEBUG {key}: Error evaluating: {vtmp[i]}\n&lt; {othererr} &gt;&#34;)
                                except Exception as ve:
                                    vtmp[i] = f&#34;Error in &lt;{item}&gt;: {ve.__class__.__name__} - {str(ve)}&#34;
                    return vtmp
                except (SyntaxError, ValueError) as e:
                    return f&#34;Error: {e.__class__.__name__} - {str(e)}&#34;
            elif valuesafe.startswith(&#34;$&#34;) and not escape:
                return tmp.format(valuesafe[1:].lstrip()) # discard $
            elif valuesafe.startswith(&#34;%&#34;):
                return tmp.format(valuesafe[1:].lstrip()) # discard %
            else: # string empty or which can be evaluated
                if valuesafe==&#34;&#34;:
                    return valuesafe # empty content
                else:
                    if isinstance(value,pstr): # keep path
                        return pstr.topath(tmp.format(valuesafe,escape=escape))
                    elif escape:  # partial evaluation
                        return tmp.format(valuesafe,escape=True)
                    else: # full evaluation (if it fails the last string content is returned) &lt;---------- FULL EVALUTION will be tried
                        try:
                            resstr = tmp.format(valuesafe,raiseerror=False)
                        except (KeyError,NameError) as nameerr:
                            try: # nested indexing (guess)
                                resstr = param.safe_fstring(
                                param.replace_matrix_shorthand(valuesafe_priorescape),tmp)
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluate_with_placeholders(resstr,
                                          evaluator,evaluator_nocontext,raiseerror=True)
                            except Exception as othererr:
                                if self._returnerror: # added on 2024-09-06
                                    strnameerr = str(nameerr).replace(&#34;&#39;&#34;,&#34;&#34;)
                                    if self._debug:
                                        print(f&#39;Key Error for &#34;{key}&#34; &lt; {othererr} &gt;&#39;)
                                    return &#39;&lt; undef %s &#34;${%s}&#34; &gt;&#39; % (self._ftype,strnameerr)
                                else:
                                    return value #we keep the original value
                            else:
                                return reseval
                        except SyntaxError as commonerr:
                            return &#34;Syntax Error &lt; %s &gt;&#34; % commonerr
                        except TypeError  as commonerr:
                            try: # nested indexing (guess)
                                resstr = param.safe_fstring(
                                param.replace_matrix_shorthand(valuesafe_priorescape),tmp)
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluate_with_placeholders(resstr,
                                          evaluator,evaluator_nocontext,raiseerror=True)
                            except Exception as othererr:
                                if self._debug:
                                    print(f&#39;Type Error for &#34;{key}&#34; &lt; {othererr} &gt;&#39;)
                                return &#34;Type Error &lt; %s &gt;&#34; % commonerr
                            else:
                                return reseval
                        except (IndexError,AttributeError):
                            try:
                                resstr = param.safe_fstring(
                                    param.replace_matrix_shorthand(valuesafe_priorescape),tmp)
                            except Exception as fstrerr:
                                return &#34;Index Error &lt; %s &gt;&#34; % fstrerr
                            else:
                                try:
                                    # reseval = eval(resstr)
                                    # reseval = ast.literal_eval(resstr)
                                    # Use SafeEvaluator to evaluate the final expression
                                    evaluator = SafeEvaluator(tmp)
                                    reseval = evaluator.evaluate(resstr)
                                except Exception as othererr:
                                    #tmp.setattr(key,&#34;Mathematical Error around/in ${}: &lt; %s &gt;&#34; % othererr)
                                    if self._debug:
                                        print(f&#34;DEBUG {key}: Error evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                    return resstr
                                else:
                                    return reseval
                        except ValueError as valerr: # forced evaluation within ${}
                            try:
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluate_with_placeholders(valuesafe_priorescape,evaluator,evaluator_nocontext,raiseerror=True)
                            except SyntaxError as synerror:
                                if self._debug:
                                    print(f&#34;DEBUG {key}: Error evaluating: {valuesafe_priorescape}\n&lt; {synerror} &gt;&#34;)
                                return evaluate_with_placeholders(valuesafe_priorescape,evaluator,evaluator_nocontext,raiseerror=False)
                            except Exception as othererr:
                                if self._debug:
                                    print(f&#34;DEBUG {key}: Error evaluating: {valuesafe_priorescape}\n&lt; {othererr} &gt;&#34;)
                                return &#34;Error in ${}: &lt; %s &gt;&#34; % valerr
                            else:
                                return reseval

                        except Exception as othererr:
                            return &#34;Error in ${}: &lt; %s &gt;&#34; % othererr
                        else:
                            try:
                                # reseval = eval(resstr)
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluate_with_placeholders(resstr,evaluator,evaluator_nocontext)
                            except Exception as othererr:
                                #tmp.setattr(key,&#34;Eval Error &lt; %s &gt;&#34; % othererr)
                                if self._debug:
                                    print(f&#34;DEBUG {key}: Error evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                return resstr.replace(&#34;\n&#34;,&#34;,&#34;) # \n replaced by ,
                            else:
                                return reseval

        # evalstr() refactored for error management
        def safe_evalstr(x,key=&#34;&#34;):
            xeval = evalstr(x,key)
            if isinstance(xeval,str):
                try:
                    evaluator = SafeEvaluator(tmp)
                    return evaluate_with_placeholders(xeval,evaluator,evaluator_nocontext)
                except Exception as e:
                    if self._debug:
                        print(f&#34;DEBUG {key}: Error evaluating &#39;{x}&#39;: {e}&#34;)
                    return xeval  # default fallback value
            else:
                return xeval

        # Evaluate all DEFINITIONS
        for key,value in self.items():
            # strings are assumed to be expressions on one single line
            if isinstance(value,str):
                tmp.setattr(key,evalstr(value,key))
            elif isinstance(value,_numeric_types): # already a number
                if isinstance(value,list):
                    valuelist = [safe_evalstr(x,key) if isinstance(x,str) else x for x in value]
                    tmp.setattr(key,valuelist)
                else:
                    tmp.setattr(key, value) # store the value with the key
            elif isinstance(value, dict):
                # For dictionaries, evaluate each entry using its own key (sub_key)
                new_dict = {}
                for sub_key, sub_value in value.items():
                    if isinstance(sub_value, str):
                        new_dict[sub_key] = safe_evalstr(sub_value,key)
                    elif isinstance(sub_value, list):
                        # If an entry is a list, apply safe_evalstr to each string element within it
                        new_dict[sub_key] = [safe_evalstr(x, sub_key) if isinstance(x, str) else x
                                             for x in sub_value]
                    else:
                        new_dict[sub_key] = sub_value
                tmp.setattr(key, new_dict)
            else: # unsupported types
                if s.find(&#34;{&#34;+key+&#34;}&#34;)&gt;=0:
                    print(f&#39;*** WARNING ***\n\tIn the {self._ftype}:&#34;\n{s}\n&#34;&#39;)
                else:
                    print(f&#39;unable to interpret the &#34;{key}&#34; of type {type(value)}&#39;)
        return tmp

    # formateval obeys to following rules
    # lines starting with # (hash) are interpreted as comments
    def formateval(self,s,protection=False,fullevaluation=True):
        &#34;&#34;&#34;
            format method with evaluation feature

                txt = p.formateval(&#34;this my text with ${variable1}, ${variable2} &#34;)

                where:
                    p is a param object

                Example:
                    definitions = param(a=1,b=&#34;${a}&#34;,c=&#34;\\${a}&#34;)
                    text = definitions.formateval(&#34;this my text ${a}, ${b}, ${c}&#34;)
                    print(text)

        &#34;&#34;&#34;
        tmp = self.eval(s,protection=protection)
        evaluator = SafeEvaluator(tmp) # used when fullevaluation=True
        evaluator_nocontext = SafeEvaluator() # for global evaluation without context
        # Do all replacements in s (keep comments)
        if len(tmp)==0:
            return s
        else:
            ispstr = isinstance(s,pstr)
            ssafe, escape = param.escape(s)
            slines = ssafe.split(&#34;\n&#34;)
            slines_priorescape = s.split(&#34;\n&#34;)
            for i in range(len(slines)):
                poscomment = slines[i].find(&#34;#&#34;)
                if poscomment&gt;=0:
                    while (poscomment&gt;0) and (slines[i][poscomment-1]==&#34; &#34;):
                        poscomment -= 1
                    comment = slines[i][poscomment:len(slines[i])]
                    slines[i]  = slines[i][0:poscomment]
                else:
                    comment = &#34;&#34;
                # Protect variables if required
                if protection or self._protection:
                    slines[i], escape2 = self.protect(slines[i])
                # conversion
                if ispstr:
                    slines[i] = pstr.eval(tmp.format(slines[i],escape=escape),ispstr=ispstr)
                else:
                    if fullevaluation:
                        try:
                            resstr =tmp.format(slines[i],escape=escape)
                        except:
                            resstr = param.safe_fstring(slines[i],tmp,varprefix=&#34;&#34;)
                        try:
                            #reseval = evaluator.evaluate(resstr)
                            reseval = evaluate_with_placeholders(slines_priorescape[i],evaluator,evaluator_nocontext,raiseerror=True)
                            slines[i] = str(reseval)+&#34; &#34;+comment if comment else str(reseval)
                        except:
                            slines[i] = resstr + comment
                    else:
                        slines[i] = tmp.format(slines[i],escape=escape)+comment
                # convert starting % into # to authorize replacement in comments
                if len(slines[i])&gt;0:
                    if slines[i][0] == &#34;%&#34;: slines[i]=&#34;#&#34;+slines[i][1:]
            return &#34;\n&#34;.join(slines)


    # return the value instead of formula
    def getval(self,key):
        &#34;&#34;&#34; returns the evaluated value &#34;&#34;&#34;
        s = self.eval()
        return getattr(s,key)

    # override () for subindexing structure with key names
    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extract an evaluated sub-structure based on the specified keys,
        keeping the same class type.

        Parameters:
        -----------
        *keys : str
            The keys for the fields to include in the sub-structure.

        Returns:
        --------
        struct
            An evaluated instance of class struct, containing
            only the specified keys with evaluated values.

        Usage:
        ------
        sub_struct = p(&#39;key1&#39;, &#39;key2&#39;, ...)
        &#34;&#34;&#34;
        s = self.eval()
        if keys:
            return s(*keys)
        else:
            return s

    # returns the equivalent structure evaluated
    def tostruct(self,protection=False):
        &#34;&#34;&#34;
            generate the evaluated structure
                tostruct(protection=False)
        &#34;&#34;&#34;
        return self.eval(protection=protection)

    # returns the equivalent paramauto instance
    def toparamauto(self):
        &#34;&#34;&#34;
            convert a param instance into a paramauto instance
                toparamauto()
        &#34;&#34;&#34;
        return paramauto(**self)

    # returns the equivalent structure evaluated
    def tostatic(self):
        &#34;&#34;&#34; convert dynamic a param() object to a static struct() object.
            note: no interpretation
            note: use tostruct() to interpret them and convert it to struct
            note: tostatic().struct2param() makes it reversible
        &#34;&#34;&#34;
        return struct.fromkeysvalues(self.keys(),self.values(),makeparam=False)

    # Matlab vector/list conversion
    @staticmethod
    def expand_ranges(text,numfmt=&#34;.4g&#34;):
        &#34;&#34;&#34;
        Expands MATLAB-style ranges in a string.

        Args:
            text: The input string containing ranges.
            numfmt: numeric format to be used for the string conversion (default=&#34;.4g&#34;)

        Returns:
            The string with ranges expanded, or the original string if no valid ranges are found
            or if expansion leads to more than 100 elements. Returns an error message if the input
            format is invalid.
        &#34;&#34;&#34;
        def expand_range(match):
            try:
                parts = match.group(1).split(&#39;:&#39;)
                if len(parts) == 2:
                    start, stop = map(float, parts)
                    step = 1.0
                elif len(parts) == 3:
                    start, step, stop = map(float, parts)
                else:
                    return match.group(0)  # Return original if format is invalid
                if step == 0:
                    return &#34;Error: &lt;Step cannot be zero.&gt;&#34;
                if (stop - start) / step &gt; 1e6:
                    return &#34;Error: &lt;Range is too large.&gt;&#34;
                if step &gt; 0:
                    num_elements = int(np.floor((stop - start)/step)+1)
                else:
                     num_elements = int(np.floor((start - stop)/-step)+1)
                if num_elements &gt; 100:
                    return match.group(0)  # Return original if too many elements
                expanded_range = np.arange(start, stop + np.sign(step)*1e-9, step) #adding a small number to include the stop in case of integer steps
                return &#39;[&#39; + &#39;,&#39;.join(f&#39;{x:{numfmt}}&#39; for x in expanded_range) + &#39;]&#39;
            except ValueError:
                return &#34;Error: &lt;Invalid range format.&gt;&#34;
        pattern = r&#39;(\b(?:-?\d+(?:\.\d*)?|-?\.\d+)(?::(?:-?\d+(?:\.\d*)?|-?\.\d+)){1,2})\b&#39;
        expanded_text = re.sub(pattern, expand_range, text)
        #check for errors generated by the function
        if &#34;Error:&#34; in expanded_text:
            return expanded_text
        return expanded_text

    # Matlab syntax conversion
    @staticmethod
    def convert_matlab_like_arrays(text):
        &#34;&#34;&#34;
        Converts Matlab-like array syntax (including hybrid notations) into
        a NumPy-esque list syntax in multiple passes.

        Steps:
          1) Convert 2D Matlab arrays (containing semicolons) into Python-like nested lists.
          2) Convert bracketed row vectors (no semicolons or nested brackets) into double-bracket format.
          3) Replace spaces with commas under specific conditions and remove duplicates.

        Args:
            text (str): Input string that may contain Matlab-like arrays.

        Returns:
            str: Transformed text with arrays converted to a Python/NumPy-like syntax.

        Examples:

            examples = [
                &#34;[1, 2  ${var1}          ; 4, 5     ${var2}]&#34;,
                &#34;[1,2,3]&#34;,
                &#34;[1 2 ,  3]&#34;,
                &#34;[1;2; 3]&#34;,
                &#34;[[-0.5, 0.5;-0.5, 0.5],[ -0.5,  0.5; -0.5,  0.5]]&#34;,
                &#34;[[1,2;3,4],[5,6; 7,8]]&#34;,
                &#34;[1, 2, 3; 4, 5, 6]&#34;,  # Hybrid
                &#34;[[Already, in, Python]]&#34;,  # Already Python-like?
                &#34;Not an array&#34;
            ]

            for ex in examples:
                converted = param.convert_matlab_like_arrays(ex)
                print(f&#34;Matlab: {ex}\nNumPy : {converted}\n&#34;)

        &#34;&#34;&#34;
        # --------------------------------------------------------------------------
        # Step 1: Detect innermost [ ... ; ... ] blocks and convert them
        # --------------------------------------------------------------------------
        def convert_matrices_with_semicolons(txt):
            &#34;&#34;&#34;
            Repeatedly find the innermost bracket pair that contains a semicolon
            and convert it to a Python-style nested list, row by row.
            &#34;&#34;&#34;
            # Pattern to find innermost [ ... ; ... ] without nested brackets
            pattern = r&#39;\[[^\[\]]*?;[^\[\]]*?\]&#39;
            while True:
                match = re.search(pattern, txt)
                if not match:
                    break  # No more [ ... ; ... ] blocks to convert
                inner_block = match.group(0)
                # Remove the outer brackets
                inner_content = inner_block[1:-1].strip()
                # Split into rows by semicolon
                rows = [row.strip() for row in inner_content.split(&#39;;&#39;)]
                converted_rows = []
                for row in rows:
                    # Replace multiple spaces with a single space
                    row_clean = re.sub(r&#39;\s+&#39;, &#39; &#39;, row)
                    # Split row by commas or spaces
                    row_elems = re.split(r&#39;[,\s]+&#39;, row_clean)
                    row_elems = [elem for elem in row_elems if elem]  # Remove empty strings
                    # Join elements with commas and encapsulate in brackets
                    converted_rows.append(&#34;[&#34; + &#34;,&#34;.join(row_elems) + &#34;]&#34;)
                # Join the row lists and encapsulate them in brackets
                replacement = &#34;[&#34; + &#34;,&#34;.join(converted_rows) + &#34;]&#34;
                # Replace the original Matlab matrix with the Python list
                txt = txt[:match.start()] + replacement + txt[match.end():]
            return txt
        # --------------------------------------------------------------------------
        # Step 2: Convert row vectors without semicolons or nested brackets
        #         into double-bracket format, e.g. [1,2,3] -&gt; [[1,2,3]]
        # --------------------------------------------------------------------------
        def convert_row_vectors(txt):
            &#34;&#34;&#34;
            Convert [1,2,3] or [1 2 3] into [[1,2,3]] if the bracket does not contain
            semicolons, nor nested brackets. We do this iteratively, skipping any
            bracket blocks that don&#39;t qualify, rather than stopping.
            &#34;&#34;&#34;
            # We only want bracket blocks that are NOT preceded by &#39;[&#39; or &#39;,&#39;
            # do not contain semicolons or nested brackets
            # and are not followed by &#39;]&#39; or &#39;,&#39;
            pattern = r&#34;(?&lt;!\[)(?&lt;!,)\([^();]*\)(?!\s*\])(?!\s*\,)&#34;
            startpos = 0
            while True:
                match = re.search(pattern, txt[startpos:])
                if not match:
                    break  # No more bracket blocks to check
                # Compute absolute positions in txt
                mstart = startpos + match.start()
                mend   = startpos + match.end()
                block  = txt[mstart:mend]
                # we need to be sure that [ ] are present around the block even if separated by spaces
                if mstart == 0 or mend == len(txt) - 1:
                    break
                if not (re.match(r&#34;\[\s*$&#34;, txt[:mstart]) and re.match(r&#34;^\s*\]&#34;, txt[mend+1:])):
                    break
                # Double-check that this bracket does not contain semicolons or nested brackets
                # If it does, we skip it (just advance the search) to avoid messing up matrices.
                # That is, we do not transform it into double brackets.
                if &#39;;&#39; in block or &#39;[&#39; in block[1:-1] or &#39;]&#39; in block[1:-1]:
                    # Move beyond this match and keep searching
                    startpos = mend
                    continue
                # It&#39;s a pure row vector (no semicolons, no nested brackets)
                new_block = &#34;[&#34; + block + &#34;]&#34;  # e.g. [1,2,3] -&gt; [[1,2,3]]
                txt = txt[:mstart] + new_block + txt[mend:]
                # Update search position to avoid re-matching inside the newly inserted text
                startpos = mstart + len(new_block)
            return txt
        # --------------------------------------------------------------------------
        # Step 3: Replace spaces with commas under specific conditions and clean up
        # --------------------------------------------------------------------------
        def replace_spaces_safely(txt):
            &#34;&#34;&#34;
            Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas.
            Then remove multiple consecutive commas and trailing commas before closing brackets.
            &#34;&#34;&#34;
            # 1) Replace spaces with commas if not preceded by [,\s
            #    and followed by digit or $
            txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
            # 2) Remove multiple consecutive commas
            txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
            # 3) Remove trailing commas before closing brackets
            txt = re.sub(r&#39;,+\]&#39;, &#39;]&#39;, txt)
            return txt

        def replace_spaces_with_commas(txt):
            &#34;&#34;&#34;
            Replaces spaces with commas only when they&#39;re within array shorthands and not preceded by a comma, opening bracket, or whitespace,
            and are followed by a digit or &#39;$&#39;. Also collapses multiple commas into one and strips leading/trailing commas.

            Parameters:
            ----------
            txt : str
                The text to process.

            Returns:
            -------
            str
                The processed text with appropriate commas.
            &#34;&#34;&#34;
            # Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas
            txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
            # Remove multiple consecutive commas
            txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
            # Strip leading and trailing commas
            txt = txt.strip(&#39;,&#39;)
            # Replace residual multiple consecutive spaces with a single space
            return re.sub(r&#39;\s+&#39;, &#39; &#39;, txt)

        # --------------------------------------------------------------------------
        # Apply Step 1: Convert matrices with semicolons
        # --------------------------------------------------------------------------
        text_cv = convert_matrices_with_semicolons(text)
        # --------------------------------------------------------------------------
        # Apply Step 2: Convert row vectors (no semicolons/nested brackets)
        # --------------------------------------------------------------------------
        text_cv = convert_row_vectors(text_cv)
        # --------------------------------------------------------------------------
        # Apply Step 3: Replace spaces with commas and clean up
        # --------------------------------------------------------------------------
        if text_cv != text:
            return replace_spaces_with_commas(text_cv) # old method: replace_spaces_safely(text_cv)
        else:
            return text



    @classmethod
    def replace_matrix_shorthand(cls,valuesafe):
        &#34;&#34;&#34;
        Transforms custom shorthand notations for NumPy arrays within a string into valid NumPy array constructors.
        Supports up to 4-dimensional arrays and handles variable references.

        **Shorthand Patterns:**
        - **1D**: `$[1 2 3]` → `np.atleast_2d(np.array([1,2,3]))`
        - **2D**: `$[[1 2],[3 4]]` → `np.array([[1,2],[3,4]])`
        - **3D**: `$[[[1 2],[3 4]],[[5 6],[7 8]]]` → `np.array([[[1,2],[3,4]],[[5,6],[7,8]]])`
        - **4D**: `$[[[[1 2]]]]` → `np.array([[[[1,2]]]])`
        - **Variable References**: `@{var}` → `np.atleast_2d(np.array(${var}))`

        **Parameters:**
        ----------
        valuesafe : str
            The input string containing shorthand notations for NumPy arrays and variable references.

        **Returns:**
        -------
        str
            The transformed string with shorthands replaced by valid NumPy array constructors.

        **Raises:**
        -------
        ValueError
            If there are unmatched brackets in any shorthand.

        **Examples:**
        --------
        &gt;&gt;&gt; # 1D shorthand
        &gt;&gt;&gt; s = &#34;$[1 2 3]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.atleast_2d(np.array([1,2,3]))&#39;

        &gt;&gt;&gt; # 2D shorthand with mixed spacing
        &gt;&gt;&gt; s = &#34;$[[1, 2], [3 4]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[1,2],[3,4]])&#39;

        &gt;&gt;&gt; # 3D array with partial spacing
        &gt;&gt;&gt; s = &#34;$[[[1  2], [3 4]], [[5 6], [7 8]]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[1,2],[3,4]],[[5,6],[7,8]]])&#39;

        &gt;&gt;&gt; # 4D array
        &gt;&gt;&gt; s = &#34;$[[[[1 2]]]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[[1,2]]]])&#39;

        &gt;&gt;&gt; # Combined with variable references
        &gt;&gt;&gt; s = &#34;@{a} + $[[${b}, 2],[ 3  4]]&#34;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.atleast_2d(np.array(${a})) + np.array([[${b},2],[3,4]])&#39;

        &gt;&gt;&gt; # Complex ND array with scaling
        &gt;&gt;&gt; s = &#39;$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*0.001&#39;
        &gt;&gt;&gt; param.replace_matrix_shorthand(s)
        &#39;np.array([[[-0.5,-0.5],[-0.5,-0.5]],[[0.5,0.5],[0.5,0.5]]])*0.001&#39;
        &#34;&#34;&#34;

        numfmt = f&#34;.{cls._precision}g&#34;

        def replace_spaces_with_commas(txt):
            &#34;&#34;&#34;
            Replaces spaces with commas only when they&#39;re not preceded by a comma, opening bracket, or whitespace,
            and are followed by a digit or &#39;$&#39;. Also collapses multiple commas into one and strips leading/trailing commas.

            Parameters:
            ----------
            txt : str
                The text to process.

            Returns:
            -------
            str
                The processed text with appropriate commas.
            &#34;&#34;&#34;
            # Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas
            txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
            # Remove multiple consecutive commas
            txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
            return txt.strip(&#39;,&#39;)

        def build_pass_list(string):
            &#34;&#34;&#34;
            Determines which dimensions (1D..4D) appear in the string by searching for:
             - 4D: $[[[[
             - 3D: $[[[
             - 2D: $[[
             - 1D: $[

            Returns a sorted list in descending order, e.g., [4, 3, 2, 1].

            Parameters:
            ----------
            string : str
                The input string to scan.

            Returns:
            -------
            list
                A list of integers representing the dimensions found, sorted descending.
            &#34;&#34;&#34;
            dims_found = set()
            if re.search(r&#39;\$\[\[\[\[&#39;, string):
                dims_found.add(4)
            if re.search(r&#39;\$\[\[\[&#39;, string):
                dims_found.add(3)
            if re.search(r&#39;\$\[\[&#39;, string):
                dims_found.add(2)
            if re.search(r&#39;\$\[&#39;, string):
                dims_found.add(1)
            return sorted(dims_found, reverse=True)

        # Step 0: convert eventual Matlab syntax for row and column vectors into NumPy syntax
        valuesafe = param.expand_ranges(valuesafe,numfmt)  # expands start:stop and start:step:stop syntax
        valuesafe = param.convert_matlab_like_arrays(valuesafe) # vectors and matrices conversion
        # Step 1: Handle @{var} -&gt; np.atleast_2d(np.array(${var}))
        valuesafe = re.sub(r&#39;@\{([^\{\}]+)\}&#39;, r&#39;np.atleast_2d(np.array(${\1}))&#39;, valuesafe)
        # Step 2: Build pass list from largest dimension to smallest
        pass_list = build_pass_list(valuesafe)
        # Step 3: Define patterns and replacements for each dimension
        dimension_patterns = {
            4: (r&#39;\$\[\[\[\[(.*?)\]\]\]\]&#39;, &#39;np.array([[[[{content}]]]])&#39;),   # 4D
            3: (r&#39;\$\[\[\[(.*?)\]\]\]&#39;, &#39;np.array([[[{content}]]])&#39;),         # 3D
            2: (r&#39;\$\[\[(.*?)\]\]&#39;, &#39;np.array([[{content}]])&#39;),               # 2D
            1: (r&#39;\$\[(.*?)\]&#39;, &#39;np.atleast_2d(np.array([{content}]))&#39;)       # 1D
        }
        # Step 4: Iterate over each dimension and perform replacements
        for dim in pass_list:
            pattern, replacement_fmt = dimension_patterns[dim]
            # Find all non-overlapping matches for the current dimension
            matches = list(re.finditer(pattern, valuesafe))
            for match in matches:
                full_match = match.group(0)       # Entire matched shorthand
                inner_content = match.group(1)    # Content inside the brackets
                # Replace spaces with commas as per rules
                processed_content = replace_spaces_with_commas(inner_content.strip())
                # Create the replacement string
                replacement = replacement_fmt.format(content=processed_content)
                # Replace the shorthand in the string
                valuesafe = valuesafe.replace(full_match, replacement)
        # Step 5: Verify that all shorthands have been replaced by checking for remaining &#39;$[&#39;
        if re.search(r&#39;\$\[&#39;, valuesafe):
            raise ValueError(&#34;Unmatched or improperly formatted brackets detected in the input string.&#34;)
        return valuesafe



    # Safe fstring
    @staticmethod
    def safe_fstring(template, context,varprefix=&#34;$&#34;):
        &#34;&#34;&#34;Safely evaluate expressions in ${} using SafeEvaluator.&#34;&#34;&#34;
        evaluator = SafeEvaluator(context)
        # Process template string in combination with safe_fstring()
        # it is required to have an output compatible with eval()

        def process_template(valuesafe):
            &#34;&#34;&#34;
            Processes the input string by:
            1. Stripping leading and trailing whitespace.
            2. Removing comments (any text after &#39;#&#39; unless &#39;#&#39; is the first character).
            3. Replacing &#39;^&#39; with &#39;**&#39;.
            4. Replacing &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;. &lt;-- not applied anymore (brings confusion)

            Args:
                valuesafe (str): The input string to process.

            Returns:
                str: The processed string.
            &#34;&#34;&#34;
            # Step 1: Strip leading and trailing whitespace
            valuesafe = valuesafe.strip()
            # Step 2: Remove comments
            # This regex removes &#39;#&#39; and everything after it if &#39;#&#39; is not the first character
            # (?&lt;!^) is a negative lookbehind that ensures &#39;#&#39; is not at the start of the string
            valuesafe = re.sub(r&#39;(?&lt;!^)\#.*&#39;, &#39;&#39;, valuesafe)
            # Step 3: Replace &#39;^&#39; with &#39;**&#39;
            valuesafe = re.sub(r&#39;\^&#39;, &#39;**&#39;, valuesafe)
            # Step 4: Replace &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;
            # (?&lt;!\$)\{ matches &#39;{&#39; not preceded by &#39;$&#39;
            # valuesafe = re.sub(r&#39;(?&lt;!\$)\{&#39;, &#39;${&#39;, valuesafe)
            # Optional: Strip again to remove any trailing whitespace left after removing comments
            valuesafe = valuesafe.strip()
            return valuesafe

        # Adjusted display for NumPy arrays
        def serialize_result(result):
            &#34;&#34;&#34;
            Serialize the result into a string that can be evaluated in Python.
            Handles NumPy arrays by converting them to lists with commas.
            Handles other iterable types appropriately.
            &#34;&#34;&#34;
            if isinstance(result, np.ndarray):
                return str(result.tolist())
            elif isinstance(result, (list, tuple, dict)):
                return str(result)
            else:
                return str(result)
        # Regular expression to find ${expr} patterns
        escaped_varprefix = re.escape(varprefix)
        pattern = re.compile(escaped_varprefix+r&#39;\{([^{}]+)\}&#39;)
        def replacer(match):
            expr = match.group(1)
            try:
                result = evaluator.evaluate(expr)
                serialized = serialize_result(result)
                return serialized
            except Exception as e:
                return f&#34;&lt;Error: {e}&gt;&#34;
        return pattern.sub(replacer, process_template(template))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mstruct.struct" href="#mstruct.struct">struct</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mstruct.param.convert_matlab_like_arrays"><code class="name flex">
<span>def <span class="ident">convert_matlab_like_arrays</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts Matlab-like array syntax (including hybrid notations) into
a NumPy-esque list syntax in multiple passes.</p>
<pre><code>    Steps:
      1) Convert 2D Matlab arrays (containing semicolons) into Python-like nested lists.
      2) Convert bracketed row vectors (no semicolons or nested brackets) into double-bracket format.
      3) Replace spaces with commas under specific conditions and remove duplicates.

    Args:
        text (str): Input string that may contain Matlab-like arrays.

    Returns:
        str: Transformed text with arrays converted to a Python/NumPy-like syntax.

    Examples:

        examples = [
            "[1, 2  ${var1}          ; 4, 5     ${var2}]",
            "[1,2,3]",
            "[1 2 ,  3]",
            "[1;2; 3]",
            "[[-0.5, 0.5;-0.5, 0.5],[ -0.5,  0.5; -0.5,  0.5]]",
            "[[1,2;3,4],[5,6; 7,8]]",
            "[1, 2, 3; 4, 5, 6]",  # Hybrid
            "[[Already, in, Python]]",  # Already Python-like?
            "Not an array"
        ]

        for ex in examples:
            converted = param.convert_matlab_like_arrays(ex)
            print(f"Matlab: {ex}
</code></pre>
<p>NumPy : {converted}
")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def convert_matlab_like_arrays(text):
    &#34;&#34;&#34;
    Converts Matlab-like array syntax (including hybrid notations) into
    a NumPy-esque list syntax in multiple passes.

    Steps:
      1) Convert 2D Matlab arrays (containing semicolons) into Python-like nested lists.
      2) Convert bracketed row vectors (no semicolons or nested brackets) into double-bracket format.
      3) Replace spaces with commas under specific conditions and remove duplicates.

    Args:
        text (str): Input string that may contain Matlab-like arrays.

    Returns:
        str: Transformed text with arrays converted to a Python/NumPy-like syntax.

    Examples:

        examples = [
            &#34;[1, 2  ${var1}          ; 4, 5     ${var2}]&#34;,
            &#34;[1,2,3]&#34;,
            &#34;[1 2 ,  3]&#34;,
            &#34;[1;2; 3]&#34;,
            &#34;[[-0.5, 0.5;-0.5, 0.5],[ -0.5,  0.5; -0.5,  0.5]]&#34;,
            &#34;[[1,2;3,4],[5,6; 7,8]]&#34;,
            &#34;[1, 2, 3; 4, 5, 6]&#34;,  # Hybrid
            &#34;[[Already, in, Python]]&#34;,  # Already Python-like?
            &#34;Not an array&#34;
        ]

        for ex in examples:
            converted = param.convert_matlab_like_arrays(ex)
            print(f&#34;Matlab: {ex}\nNumPy : {converted}\n&#34;)

    &#34;&#34;&#34;
    # --------------------------------------------------------------------------
    # Step 1: Detect innermost [ ... ; ... ] blocks and convert them
    # --------------------------------------------------------------------------
    def convert_matrices_with_semicolons(txt):
        &#34;&#34;&#34;
        Repeatedly find the innermost bracket pair that contains a semicolon
        and convert it to a Python-style nested list, row by row.
        &#34;&#34;&#34;
        # Pattern to find innermost [ ... ; ... ] without nested brackets
        pattern = r&#39;\[[^\[\]]*?;[^\[\]]*?\]&#39;
        while True:
            match = re.search(pattern, txt)
            if not match:
                break  # No more [ ... ; ... ] blocks to convert
            inner_block = match.group(0)
            # Remove the outer brackets
            inner_content = inner_block[1:-1].strip()
            # Split into rows by semicolon
            rows = [row.strip() for row in inner_content.split(&#39;;&#39;)]
            converted_rows = []
            for row in rows:
                # Replace multiple spaces with a single space
                row_clean = re.sub(r&#39;\s+&#39;, &#39; &#39;, row)
                # Split row by commas or spaces
                row_elems = re.split(r&#39;[,\s]+&#39;, row_clean)
                row_elems = [elem for elem in row_elems if elem]  # Remove empty strings
                # Join elements with commas and encapsulate in brackets
                converted_rows.append(&#34;[&#34; + &#34;,&#34;.join(row_elems) + &#34;]&#34;)
            # Join the row lists and encapsulate them in brackets
            replacement = &#34;[&#34; + &#34;,&#34;.join(converted_rows) + &#34;]&#34;
            # Replace the original Matlab matrix with the Python list
            txt = txt[:match.start()] + replacement + txt[match.end():]
        return txt
    # --------------------------------------------------------------------------
    # Step 2: Convert row vectors without semicolons or nested brackets
    #         into double-bracket format, e.g. [1,2,3] -&gt; [[1,2,3]]
    # --------------------------------------------------------------------------
    def convert_row_vectors(txt):
        &#34;&#34;&#34;
        Convert [1,2,3] or [1 2 3] into [[1,2,3]] if the bracket does not contain
        semicolons, nor nested brackets. We do this iteratively, skipping any
        bracket blocks that don&#39;t qualify, rather than stopping.
        &#34;&#34;&#34;
        # We only want bracket blocks that are NOT preceded by &#39;[&#39; or &#39;,&#39;
        # do not contain semicolons or nested brackets
        # and are not followed by &#39;]&#39; or &#39;,&#39;
        pattern = r&#34;(?&lt;!\[)(?&lt;!,)\([^();]*\)(?!\s*\])(?!\s*\,)&#34;
        startpos = 0
        while True:
            match = re.search(pattern, txt[startpos:])
            if not match:
                break  # No more bracket blocks to check
            # Compute absolute positions in txt
            mstart = startpos + match.start()
            mend   = startpos + match.end()
            block  = txt[mstart:mend]
            # we need to be sure that [ ] are present around the block even if separated by spaces
            if mstart == 0 or mend == len(txt) - 1:
                break
            if not (re.match(r&#34;\[\s*$&#34;, txt[:mstart]) and re.match(r&#34;^\s*\]&#34;, txt[mend+1:])):
                break
            # Double-check that this bracket does not contain semicolons or nested brackets
            # If it does, we skip it (just advance the search) to avoid messing up matrices.
            # That is, we do not transform it into double brackets.
            if &#39;;&#39; in block or &#39;[&#39; in block[1:-1] or &#39;]&#39; in block[1:-1]:
                # Move beyond this match and keep searching
                startpos = mend
                continue
            # It&#39;s a pure row vector (no semicolons, no nested brackets)
            new_block = &#34;[&#34; + block + &#34;]&#34;  # e.g. [1,2,3] -&gt; [[1,2,3]]
            txt = txt[:mstart] + new_block + txt[mend:]
            # Update search position to avoid re-matching inside the newly inserted text
            startpos = mstart + len(new_block)
        return txt
    # --------------------------------------------------------------------------
    # Step 3: Replace spaces with commas under specific conditions and clean up
    # --------------------------------------------------------------------------
    def replace_spaces_safely(txt):
        &#34;&#34;&#34;
        Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas.
        Then remove multiple consecutive commas and trailing commas before closing brackets.
        &#34;&#34;&#34;
        # 1) Replace spaces with commas if not preceded by [,\s
        #    and followed by digit or $
        txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
        # 2) Remove multiple consecutive commas
        txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
        # 3) Remove trailing commas before closing brackets
        txt = re.sub(r&#39;,+\]&#39;, &#39;]&#39;, txt)
        return txt

    def replace_spaces_with_commas(txt):
        &#34;&#34;&#34;
        Replaces spaces with commas only when they&#39;re within array shorthands and not preceded by a comma, opening bracket, or whitespace,
        and are followed by a digit or &#39;$&#39;. Also collapses multiple commas into one and strips leading/trailing commas.

        Parameters:
        ----------
        txt : str
            The text to process.

        Returns:
        -------
        str
            The processed text with appropriate commas.
        &#34;&#34;&#34;
        # Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas
        txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
        # Remove multiple consecutive commas
        txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
        # Strip leading and trailing commas
        txt = txt.strip(&#39;,&#39;)
        # Replace residual multiple consecutive spaces with a single space
        return re.sub(r&#39;\s+&#39;, &#39; &#39;, txt)

    # --------------------------------------------------------------------------
    # Apply Step 1: Convert matrices with semicolons
    # --------------------------------------------------------------------------
    text_cv = convert_matrices_with_semicolons(text)
    # --------------------------------------------------------------------------
    # Apply Step 2: Convert row vectors (no semicolons/nested brackets)
    # --------------------------------------------------------------------------
    text_cv = convert_row_vectors(text_cv)
    # --------------------------------------------------------------------------
    # Apply Step 3: Replace spaces with commas and clean up
    # --------------------------------------------------------------------------
    if text_cv != text:
        return replace_spaces_with_commas(text_cv) # old method: replace_spaces_safely(text_cv)
    else:
        return text</code></pre>
</details>
</dd>
<dt id="mstruct.param.escape"><code class="name flex">
<span>def <span class="ident">escape</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>escape \${} as ${{}} &ndash;&gt; keep variable names
convert ${} as {} &ndash;&gt; prepare Python replacement</p>
<h2 id="examples">Examples</h2>
<p>escape("\${a}")
returns ('${{a}}', True)</p>
<p>escape("
\${abc} ${a} \${bc}")
returns ('
${{abc}} {a} ${{bc}}', True)</p>
<p>escape("${a}")
Out[94]: ('{a}', False)</p>
<p>escape("${tata}")
returns ('{tata}', False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def escape(s):
    &#34;&#34;&#34;
        escape \\${} as ${{}} --&gt; keep variable names
        convert ${} as {} --&gt; prepare Python replacement

        Examples:
            escape(&#34;\\${a}&#34;)
            returns (&#39;${{a}}&#39;, True)

            escape(&#34;  \\${abc} ${a} \\${bc}&#34;)
            returns (&#39;  ${{abc}} {a} ${{bc}}&#39;, True)

            escape(&#34;${a}&#34;)
            Out[94]: (&#39;{a}&#39;, False)

            escape(&#34;${tata}&#34;)
            returns (&#39;{tata}&#39;, False)

    &#34;&#34;&#34;
    if not isinstance(s,str):
        raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)
    se, start, found = &#34;&#34;, 0, True
    while found:
        pos0 = s.find(r&#34;\${&#34;,start)
        found = pos0&gt;=0
        if found:
            pos1 = s.find(&#34;}&#34;,pos0)
            found = pos1&gt;=0
            if found:
                se += s[start:pos0].replace(&#34;${&#34;,&#34;{&#34;)+&#34;${{&#34;+s[pos0+3:pos1]+&#34;}}&#34;
                start=pos1+1
    result = se+s[start:].replace(&#34;${&#34;,&#34;{&#34;)
    if isinstance(s,pstr): result = pstr(result)
    return result,start&gt;0</code></pre>
</details>
</dd>
<dt id="mstruct.param.expand_ranges"><code class="name flex">
<span>def <span class="ident">expand_ranges</span></span>(<span>text, numfmt='.4g')</span>
</code></dt>
<dd>
<div class="desc"><p>Expands MATLAB-style ranges in a string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>The input string containing ranges.</dd>
<dt><strong><code>numfmt</code></strong></dt>
<dd>numeric format to be used for the string conversion (default=".4g")</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The string with ranges expanded, or the original string if no valid ranges are found
or if expansion leads to more than 100 elements. Returns an error message if the input
format is invalid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def expand_ranges(text,numfmt=&#34;.4g&#34;):
    &#34;&#34;&#34;
    Expands MATLAB-style ranges in a string.

    Args:
        text: The input string containing ranges.
        numfmt: numeric format to be used for the string conversion (default=&#34;.4g&#34;)

    Returns:
        The string with ranges expanded, or the original string if no valid ranges are found
        or if expansion leads to more than 100 elements. Returns an error message if the input
        format is invalid.
    &#34;&#34;&#34;
    def expand_range(match):
        try:
            parts = match.group(1).split(&#39;:&#39;)
            if len(parts) == 2:
                start, stop = map(float, parts)
                step = 1.0
            elif len(parts) == 3:
                start, step, stop = map(float, parts)
            else:
                return match.group(0)  # Return original if format is invalid
            if step == 0:
                return &#34;Error: &lt;Step cannot be zero.&gt;&#34;
            if (stop - start) / step &gt; 1e6:
                return &#34;Error: &lt;Range is too large.&gt;&#34;
            if step &gt; 0:
                num_elements = int(np.floor((stop - start)/step)+1)
            else:
                 num_elements = int(np.floor((start - stop)/-step)+1)
            if num_elements &gt; 100:
                return match.group(0)  # Return original if too many elements
            expanded_range = np.arange(start, stop + np.sign(step)*1e-9, step) #adding a small number to include the stop in case of integer steps
            return &#39;[&#39; + &#39;,&#39;.join(f&#39;{x:{numfmt}}&#39; for x in expanded_range) + &#39;]&#39;
        except ValueError:
            return &#34;Error: &lt;Invalid range format.&gt;&#34;
    pattern = r&#39;(\b(?:-?\d+(?:\.\d*)?|-?\.\d+)(?::(?:-?\d+(?:\.\d*)?|-?\.\d+)){1,2})\b&#39;
    expanded_text = re.sub(pattern, expand_range, text)
    #check for errors generated by the function
    if &#34;Error:&#34; in expanded_text:
        return expanded_text
    return expanded_text</code></pre>
</details>
</dd>
<dt id="mstruct.param.replace_matrix_shorthand"><code class="name flex">
<span>def <span class="ident">replace_matrix_shorthand</span></span>(<span>valuesafe)</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms custom shorthand notations for NumPy arrays within a string into valid NumPy array constructors.
Supports up to 4-dimensional arrays and handles variable references.</p>
<p><strong>Shorthand Patterns:</strong>
- <strong>1D</strong>: <code>$[1 2 3]</code> → <code>np.atleast_2d(np.array([1,2,3]))</code>
- <strong>2D</strong>: <code>$[[1 2],[3 4]]</code> → <code>np.array([[1,2],[3,4]])</code>
- <strong>3D</strong>: <code>$[[[1 2],[3 4]],[[5 6],[7 8]]]</code> → <code>np.array([[[1,2],[3,4]],[[5,6],[7,8]]])</code>
- <strong>4D</strong>: <code>$[[[[1 2]]]]</code> → <code>np.array([[[[1,2]]]])</code>
- <strong>Variable References</strong>: <code>@{var}</code> → <code>np.atleast_2d(np.array(${var}))</code></p>
<h2 id="parameters"><strong>Parameters:</strong></h2>
<p>valuesafe : str
The input string containing shorthand notations for NumPy arrays and variable references.</p>
<h2 id="returns"><strong>Returns:</strong></h2>
<p>str
The transformed string with shorthands replaced by valid NumPy array constructors.</p>
<h2 id="raises"><strong>Raises:</strong></h2>
<p>ValueError
If there are unmatched brackets in any shorthand.</p>
<h2 id="examples"><strong>Examples:</strong></h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 1D shorthand
&gt;&gt;&gt; s = &quot;$[1 2 3]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.atleast_2d(np.array([1,2,3]))'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 2D shorthand with mixed spacing
&gt;&gt;&gt; s = &quot;$[[1, 2], [3 4]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[1,2],[3,4]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 3D array with partial spacing
&gt;&gt;&gt; s = &quot;$[[[1  2], [3 4]], [[5 6], [7 8]]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[[1,2],[3,4]],[[5,6],[7,8]]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # 4D array
&gt;&gt;&gt; s = &quot;$[[[[1 2]]]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[[[1,2]]]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Combined with variable references
&gt;&gt;&gt; s = &quot;@{a} + $[[${b}, 2],[ 3  4]]&quot;
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.atleast_2d(np.array(${a})) + np.array([[${b},2],[3,4]])'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Complex ND array with scaling
&gt;&gt;&gt; s = '$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*0.001'
&gt;&gt;&gt; param.replace_matrix_shorthand(s)
'np.array([[[-0.5,-0.5],[-0.5,-0.5]],[[0.5,0.5],[0.5,0.5]]])*0.001'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def replace_matrix_shorthand(cls,valuesafe):
    &#34;&#34;&#34;
    Transforms custom shorthand notations for NumPy arrays within a string into valid NumPy array constructors.
    Supports up to 4-dimensional arrays and handles variable references.

    **Shorthand Patterns:**
    - **1D**: `$[1 2 3]` → `np.atleast_2d(np.array([1,2,3]))`
    - **2D**: `$[[1 2],[3 4]]` → `np.array([[1,2],[3,4]])`
    - **3D**: `$[[[1 2],[3 4]],[[5 6],[7 8]]]` → `np.array([[[1,2],[3,4]],[[5,6],[7,8]]])`
    - **4D**: `$[[[[1 2]]]]` → `np.array([[[[1,2]]]])`
    - **Variable References**: `@{var}` → `np.atleast_2d(np.array(${var}))`

    **Parameters:**
    ----------
    valuesafe : str
        The input string containing shorthand notations for NumPy arrays and variable references.

    **Returns:**
    -------
    str
        The transformed string with shorthands replaced by valid NumPy array constructors.

    **Raises:**
    -------
    ValueError
        If there are unmatched brackets in any shorthand.

    **Examples:**
    --------
    &gt;&gt;&gt; # 1D shorthand
    &gt;&gt;&gt; s = &#34;$[1 2 3]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.atleast_2d(np.array([1,2,3]))&#39;

    &gt;&gt;&gt; # 2D shorthand with mixed spacing
    &gt;&gt;&gt; s = &#34;$[[1, 2], [3 4]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[1,2],[3,4]])&#39;

    &gt;&gt;&gt; # 3D array with partial spacing
    &gt;&gt;&gt; s = &#34;$[[[1  2], [3 4]], [[5 6], [7 8]]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[[1,2],[3,4]],[[5,6],[7,8]]])&#39;

    &gt;&gt;&gt; # 4D array
    &gt;&gt;&gt; s = &#34;$[[[[1 2]]]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[[[1,2]]]])&#39;

    &gt;&gt;&gt; # Combined with variable references
    &gt;&gt;&gt; s = &#34;@{a} + $[[${b}, 2],[ 3  4]]&#34;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.atleast_2d(np.array(${a})) + np.array([[${b},2],[3,4]])&#39;

    &gt;&gt;&gt; # Complex ND array with scaling
    &gt;&gt;&gt; s = &#39;$[[[-0.5, -0.5],[-0.5, -0.5]],[[ 0.5,  0.5],[ 0.5,  0.5]]]*0.001&#39;
    &gt;&gt;&gt; param.replace_matrix_shorthand(s)
    &#39;np.array([[[-0.5,-0.5],[-0.5,-0.5]],[[0.5,0.5],[0.5,0.5]]])*0.001&#39;
    &#34;&#34;&#34;

    numfmt = f&#34;.{cls._precision}g&#34;

    def replace_spaces_with_commas(txt):
        &#34;&#34;&#34;
        Replaces spaces with commas only when they&#39;re not preceded by a comma, opening bracket, or whitespace,
        and are followed by a digit or &#39;$&#39;. Also collapses multiple commas into one and strips leading/trailing commas.

        Parameters:
        ----------
        txt : str
            The text to process.

        Returns:
        -------
        str
            The processed text with appropriate commas.
        &#34;&#34;&#34;
        # Replace spaces not preceded by &#39;,&#39;, &#39;[&#39;, or whitespace and followed by digit or &#39;$&#39; with commas
        txt = re.sub(r&#39;(?&lt;![,\[\s])\s+(?=[\d\$])&#39;, &#39;,&#39;, txt)
        # Remove multiple consecutive commas
        txt = re.sub(r&#39;,+&#39;, &#39;,&#39;, txt)
        return txt.strip(&#39;,&#39;)

    def build_pass_list(string):
        &#34;&#34;&#34;
        Determines which dimensions (1D..4D) appear in the string by searching for:
         - 4D: $[[[[
         - 3D: $[[[
         - 2D: $[[
         - 1D: $[

        Returns a sorted list in descending order, e.g., [4, 3, 2, 1].

        Parameters:
        ----------
        string : str
            The input string to scan.

        Returns:
        -------
        list
            A list of integers representing the dimensions found, sorted descending.
        &#34;&#34;&#34;
        dims_found = set()
        if re.search(r&#39;\$\[\[\[\[&#39;, string):
            dims_found.add(4)
        if re.search(r&#39;\$\[\[\[&#39;, string):
            dims_found.add(3)
        if re.search(r&#39;\$\[\[&#39;, string):
            dims_found.add(2)
        if re.search(r&#39;\$\[&#39;, string):
            dims_found.add(1)
        return sorted(dims_found, reverse=True)

    # Step 0: convert eventual Matlab syntax for row and column vectors into NumPy syntax
    valuesafe = param.expand_ranges(valuesafe,numfmt)  # expands start:stop and start:step:stop syntax
    valuesafe = param.convert_matlab_like_arrays(valuesafe) # vectors and matrices conversion
    # Step 1: Handle @{var} -&gt; np.atleast_2d(np.array(${var}))
    valuesafe = re.sub(r&#39;@\{([^\{\}]+)\}&#39;, r&#39;np.atleast_2d(np.array(${\1}))&#39;, valuesafe)
    # Step 2: Build pass list from largest dimension to smallest
    pass_list = build_pass_list(valuesafe)
    # Step 3: Define patterns and replacements for each dimension
    dimension_patterns = {
        4: (r&#39;\$\[\[\[\[(.*?)\]\]\]\]&#39;, &#39;np.array([[[[{content}]]]])&#39;),   # 4D
        3: (r&#39;\$\[\[\[(.*?)\]\]\]&#39;, &#39;np.array([[[{content}]]])&#39;),         # 3D
        2: (r&#39;\$\[\[(.*?)\]\]&#39;, &#39;np.array([[{content}]])&#39;),               # 2D
        1: (r&#39;\$\[(.*?)\]&#39;, &#39;np.atleast_2d(np.array([{content}]))&#39;)       # 1D
    }
    # Step 4: Iterate over each dimension and perform replacements
    for dim in pass_list:
        pattern, replacement_fmt = dimension_patterns[dim]
        # Find all non-overlapping matches for the current dimension
        matches = list(re.finditer(pattern, valuesafe))
        for match in matches:
            full_match = match.group(0)       # Entire matched shorthand
            inner_content = match.group(1)    # Content inside the brackets
            # Replace spaces with commas as per rules
            processed_content = replace_spaces_with_commas(inner_content.strip())
            # Create the replacement string
            replacement = replacement_fmt.format(content=processed_content)
            # Replace the shorthand in the string
            valuesafe = valuesafe.replace(full_match, replacement)
    # Step 5: Verify that all shorthands have been replaced by checking for remaining &#39;$[&#39;
    if re.search(r&#39;\$\[&#39;, valuesafe):
        raise ValueError(&#34;Unmatched or improperly formatted brackets detected in the input string.&#34;)
    return valuesafe</code></pre>
</details>
</dd>
<dt id="mstruct.param.safe_fstring"><code class="name flex">
<span>def <span class="ident">safe_fstring</span></span>(<span>template, context, varprefix='$')</span>
</code></dt>
<dd>
<div class="desc"><p>Safely evaluate expressions in ${} using SafeEvaluator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def safe_fstring(template, context,varprefix=&#34;$&#34;):
    &#34;&#34;&#34;Safely evaluate expressions in ${} using SafeEvaluator.&#34;&#34;&#34;
    evaluator = SafeEvaluator(context)
    # Process template string in combination with safe_fstring()
    # it is required to have an output compatible with eval()

    def process_template(valuesafe):
        &#34;&#34;&#34;
        Processes the input string by:
        1. Stripping leading and trailing whitespace.
        2. Removing comments (any text after &#39;#&#39; unless &#39;#&#39; is the first character).
        3. Replacing &#39;^&#39; with &#39;**&#39;.
        4. Replacing &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;. &lt;-- not applied anymore (brings confusion)

        Args:
            valuesafe (str): The input string to process.

        Returns:
            str: The processed string.
        &#34;&#34;&#34;
        # Step 1: Strip leading and trailing whitespace
        valuesafe = valuesafe.strip()
        # Step 2: Remove comments
        # This regex removes &#39;#&#39; and everything after it if &#39;#&#39; is not the first character
        # (?&lt;!^) is a negative lookbehind that ensures &#39;#&#39; is not at the start of the string
        valuesafe = re.sub(r&#39;(?&lt;!^)\#.*&#39;, &#39;&#39;, valuesafe)
        # Step 3: Replace &#39;^&#39; with &#39;**&#39;
        valuesafe = re.sub(r&#39;\^&#39;, &#39;**&#39;, valuesafe)
        # Step 4: Replace &#39;{&#39; with &#39;${&#39; if &#39;{&#39; is not preceded by &#39;$&#39;
        # (?&lt;!\$)\{ matches &#39;{&#39; not preceded by &#39;$&#39;
        # valuesafe = re.sub(r&#39;(?&lt;!\$)\{&#39;, &#39;${&#39;, valuesafe)
        # Optional: Strip again to remove any trailing whitespace left after removing comments
        valuesafe = valuesafe.strip()
        return valuesafe

    # Adjusted display for NumPy arrays
    def serialize_result(result):
        &#34;&#34;&#34;
        Serialize the result into a string that can be evaluated in Python.
        Handles NumPy arrays by converting them to lists with commas.
        Handles other iterable types appropriately.
        &#34;&#34;&#34;
        if isinstance(result, np.ndarray):
            return str(result.tolist())
        elif isinstance(result, (list, tuple, dict)):
            return str(result)
        else:
            return str(result)
    # Regular expression to find ${expr} patterns
    escaped_varprefix = re.escape(varprefix)
    pattern = re.compile(escaped_varprefix+r&#39;\{([^{}]+)\}&#39;)
    def replacer(match):
        expr = match.group(1)
        try:
            result = evaluator.evaluate(expr)
            serialized = serialize_result(result)
            return serialized
        except Exception as e:
            return f&#34;&lt;Error: {e}&gt;&#34;
    return pattern.sub(replacer, process_template(template))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mstruct.param.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>self, s='', protection=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Eval method for structure such as MS.alias</p>
<pre><code>s = p.eval() or s = p.eval(string)

where :
    p is a param object
    s is a structure with evaluated fields
    string is only used to determine whether definitions have been forgotten
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval(self,s=&#34;&#34;,protection=False):
    &#34;&#34;&#34;
        Eval method for structure such as MS.alias

            s = p.eval() or s = p.eval(string)

            where :
                p is a param object
                s is a structure with evaluated fields
                string is only used to determine whether definitions have been forgotten

    &#34;&#34;&#34;
    # handle deferred sorting
    if self._needs_sorting:
        self.sortdefinitions(raiseerror=False, silentmode=True)
    # the argument s is only used by formateval() for error management
    tmp = struct(debug=self._debug)
    # evaluator without context
    evaluator_nocontext = SafeEvaluator() # for global evaluation without context

    # main string evaluator
    def evalstr(value,key=&#34;&#34;):
        # replace ${variable} (Bash, Lammps syntax) by {variable} (Python syntax)
        # use \${variable} to prevent replacement (espace with \)
        # Protect variables if required
        ispstr = isinstance(value,pstr)
        valuesafe = pstr.eval(value,ispstr=ispstr) # value.strip()
        if valuesafe==&#34;${&#34;+key+&#34;}&#34;: # circular reference (it cannot be evaluated)
            return valuesafe
        if protection or self._protection:
            valuesafe, escape0 = self.protect(valuesafe)
        else:
            escape0 = False
        # replace ${var} by {var} once basic substitutions have been applied
        valuesafe_priorescape = tmp.numrepl(valuesafe) # minimal substitution
        valuesafe, escape = param.escape(valuesafe_priorescape)
        escape = escape or escape0
        # replace &#34;^&#34; (Matlab, Lammps exponent) by &#34;**&#34; (Python syntax)
        valuesafe = pstr.eval(valuesafe.replace(&#34;^&#34;,&#34;**&#34;),ispstr=ispstr)
        # Remove all content after #
        # if the first character is &#39;#&#39;, it is not comment (e.g. MarkDown titles)
        poscomment = valuesafe.find(&#34;#&#34;)
        if poscomment&gt;0: valuesafe = valuesafe[0:poscomment].strip()
        # Matrix shorthand replacement
        # $[[1,2,${a}]]+$[[10,20,30]] --&gt; np.array([[1,2,${a}]])+np.array([[10,20,30]])
        valuesafe = param.replace_matrix_shorthand(valuesafe)
        # Literal string starts with $ (no interpretation), ! (evaluation)
        if not self._evaluation:
            return pstr.eval(tmp.format(valuesafe,escape),ispstr=ispstr)
        elif valuesafe.startswith(&#34;!&#34;): # &lt;---------- FORECED LITERAL EVALUATION (error messages are returned)
            try:
                #vtmp = ast.literal_eval(valuesafe[1:])
                evaluator = SafeEvaluator(tmp)
                vtmp = evaluate_with_placeholders(valuesafe[1:],evaluator,evaluator_nocontext)
                if isinstance(vtmp,list):
                    for i,item in enumerate(vtmp):
                        if isinstance(item,str) and not is_literal_string(item):
                            try:
                                vtmp[i] = tmp.format(item, raiseerror=False) # in case substitions/interpolations are needed
                                try:
                                    vtmp[i] = evaluator_nocontext.evaluate(vtmp[i]) # full evaluation without context
                                except Exception as othererr:
                                    if self._debug:
                                        print(f&#34;DEBUG {key}: Error evaluating: {vtmp[i]}\n&lt; {othererr} &gt;&#34;)
                            except Exception as ve:
                                vtmp[i] = f&#34;Error in &lt;{item}&gt;: {ve.__class__.__name__} - {str(ve)}&#34;
                return vtmp
            except (SyntaxError, ValueError) as e:
                return f&#34;Error: {e.__class__.__name__} - {str(e)}&#34;
        elif valuesafe.startswith(&#34;$&#34;) and not escape:
            return tmp.format(valuesafe[1:].lstrip()) # discard $
        elif valuesafe.startswith(&#34;%&#34;):
            return tmp.format(valuesafe[1:].lstrip()) # discard %
        else: # string empty or which can be evaluated
            if valuesafe==&#34;&#34;:
                return valuesafe # empty content
            else:
                if isinstance(value,pstr): # keep path
                    return pstr.topath(tmp.format(valuesafe,escape=escape))
                elif escape:  # partial evaluation
                    return tmp.format(valuesafe,escape=True)
                else: # full evaluation (if it fails the last string content is returned) &lt;---------- FULL EVALUTION will be tried
                    try:
                        resstr = tmp.format(valuesafe,raiseerror=False)
                    except (KeyError,NameError) as nameerr:
                        try: # nested indexing (guess)
                            resstr = param.safe_fstring(
                            param.replace_matrix_shorthand(valuesafe_priorescape),tmp)
                            evaluator = SafeEvaluator(tmp)
                            reseval = evaluate_with_placeholders(resstr,
                                      evaluator,evaluator_nocontext,raiseerror=True)
                        except Exception as othererr:
                            if self._returnerror: # added on 2024-09-06
                                strnameerr = str(nameerr).replace(&#34;&#39;&#34;,&#34;&#34;)
                                if self._debug:
                                    print(f&#39;Key Error for &#34;{key}&#34; &lt; {othererr} &gt;&#39;)
                                return &#39;&lt; undef %s &#34;${%s}&#34; &gt;&#39; % (self._ftype,strnameerr)
                            else:
                                return value #we keep the original value
                        else:
                            return reseval
                    except SyntaxError as commonerr:
                        return &#34;Syntax Error &lt; %s &gt;&#34; % commonerr
                    except TypeError  as commonerr:
                        try: # nested indexing (guess)
                            resstr = param.safe_fstring(
                            param.replace_matrix_shorthand(valuesafe_priorescape),tmp)
                            evaluator = SafeEvaluator(tmp)
                            reseval = evaluate_with_placeholders(resstr,
                                      evaluator,evaluator_nocontext,raiseerror=True)
                        except Exception as othererr:
                            if self._debug:
                                print(f&#39;Type Error for &#34;{key}&#34; &lt; {othererr} &gt;&#39;)
                            return &#34;Type Error &lt; %s &gt;&#34; % commonerr
                        else:
                            return reseval
                    except (IndexError,AttributeError):
                        try:
                            resstr = param.safe_fstring(
                                param.replace_matrix_shorthand(valuesafe_priorescape),tmp)
                        except Exception as fstrerr:
                            return &#34;Index Error &lt; %s &gt;&#34; % fstrerr
                        else:
                            try:
                                # reseval = eval(resstr)
                                # reseval = ast.literal_eval(resstr)
                                # Use SafeEvaluator to evaluate the final expression
                                evaluator = SafeEvaluator(tmp)
                                reseval = evaluator.evaluate(resstr)
                            except Exception as othererr:
                                #tmp.setattr(key,&#34;Mathematical Error around/in ${}: &lt; %s &gt;&#34; % othererr)
                                if self._debug:
                                    print(f&#34;DEBUG {key}: Error evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                                return resstr
                            else:
                                return reseval
                    except ValueError as valerr: # forced evaluation within ${}
                        try:
                            evaluator = SafeEvaluator(tmp)
                            reseval = evaluate_with_placeholders(valuesafe_priorescape,evaluator,evaluator_nocontext,raiseerror=True)
                        except SyntaxError as synerror:
                            if self._debug:
                                print(f&#34;DEBUG {key}: Error evaluating: {valuesafe_priorescape}\n&lt; {synerror} &gt;&#34;)
                            return evaluate_with_placeholders(valuesafe_priorescape,evaluator,evaluator_nocontext,raiseerror=False)
                        except Exception as othererr:
                            if self._debug:
                                print(f&#34;DEBUG {key}: Error evaluating: {valuesafe_priorescape}\n&lt; {othererr} &gt;&#34;)
                            return &#34;Error in ${}: &lt; %s &gt;&#34; % valerr
                        else:
                            return reseval

                    except Exception as othererr:
                        return &#34;Error in ${}: &lt; %s &gt;&#34; % othererr
                    else:
                        try:
                            # reseval = eval(resstr)
                            evaluator = SafeEvaluator(tmp)
                            reseval = evaluate_with_placeholders(resstr,evaluator,evaluator_nocontext)
                        except Exception as othererr:
                            #tmp.setattr(key,&#34;Eval Error &lt; %s &gt;&#34; % othererr)
                            if self._debug:
                                print(f&#34;DEBUG {key}: Error evaluating: {resstr}\n&lt; {othererr} &gt;&#34;)
                            return resstr.replace(&#34;\n&#34;,&#34;,&#34;) # \n replaced by ,
                        else:
                            return reseval

    # evalstr() refactored for error management
    def safe_evalstr(x,key=&#34;&#34;):
        xeval = evalstr(x,key)
        if isinstance(xeval,str):
            try:
                evaluator = SafeEvaluator(tmp)
                return evaluate_with_placeholders(xeval,evaluator,evaluator_nocontext)
            except Exception as e:
                if self._debug:
                    print(f&#34;DEBUG {key}: Error evaluating &#39;{x}&#39;: {e}&#34;)
                return xeval  # default fallback value
        else:
            return xeval

    # Evaluate all DEFINITIONS
    for key,value in self.items():
        # strings are assumed to be expressions on one single line
        if isinstance(value,str):
            tmp.setattr(key,evalstr(value,key))
        elif isinstance(value,_numeric_types): # already a number
            if isinstance(value,list):
                valuelist = [safe_evalstr(x,key) if isinstance(x,str) else x for x in value]
                tmp.setattr(key,valuelist)
            else:
                tmp.setattr(key, value) # store the value with the key
        elif isinstance(value, dict):
            # For dictionaries, evaluate each entry using its own key (sub_key)
            new_dict = {}
            for sub_key, sub_value in value.items():
                if isinstance(sub_value, str):
                    new_dict[sub_key] = safe_evalstr(sub_value,key)
                elif isinstance(sub_value, list):
                    # If an entry is a list, apply safe_evalstr to each string element within it
                    new_dict[sub_key] = [safe_evalstr(x, sub_key) if isinstance(x, str) else x
                                         for x in sub_value]
                else:
                    new_dict[sub_key] = sub_value
            tmp.setattr(key, new_dict)
        else: # unsupported types
            if s.find(&#34;{&#34;+key+&#34;}&#34;)&gt;=0:
                print(f&#39;*** WARNING ***\n\tIn the {self._ftype}:&#34;\n{s}\n&#34;&#39;)
            else:
                print(f&#39;unable to interpret the &#34;{key}&#34; of type {type(value)}&#39;)
    return tmp</code></pre>
</details>
</dd>
<dt id="mstruct.param.formateval"><code class="name flex">
<span>def <span class="ident">formateval</span></span>(<span>self, s, protection=False, fullevaluation=True)</span>
</code></dt>
<dd>
<div class="desc"><p>format method with evaluation feature</p>
<pre><code>txt = p.formateval("this my text with ${variable1}, ${variable2} ")

where:
    p is a param object

Example:
    definitions = param(a=1,b="${a}",c="\${a}")
    text = definitions.formateval("this my text ${a}, ${b}, ${c}")
    print(text)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formateval(self,s,protection=False,fullevaluation=True):
    &#34;&#34;&#34;
        format method with evaluation feature

            txt = p.formateval(&#34;this my text with ${variable1}, ${variable2} &#34;)

            where:
                p is a param object

            Example:
                definitions = param(a=1,b=&#34;${a}&#34;,c=&#34;\\${a}&#34;)
                text = definitions.formateval(&#34;this my text ${a}, ${b}, ${c}&#34;)
                print(text)

    &#34;&#34;&#34;
    tmp = self.eval(s,protection=protection)
    evaluator = SafeEvaluator(tmp) # used when fullevaluation=True
    evaluator_nocontext = SafeEvaluator() # for global evaluation without context
    # Do all replacements in s (keep comments)
    if len(tmp)==0:
        return s
    else:
        ispstr = isinstance(s,pstr)
        ssafe, escape = param.escape(s)
        slines = ssafe.split(&#34;\n&#34;)
        slines_priorescape = s.split(&#34;\n&#34;)
        for i in range(len(slines)):
            poscomment = slines[i].find(&#34;#&#34;)
            if poscomment&gt;=0:
                while (poscomment&gt;0) and (slines[i][poscomment-1]==&#34; &#34;):
                    poscomment -= 1
                comment = slines[i][poscomment:len(slines[i])]
                slines[i]  = slines[i][0:poscomment]
            else:
                comment = &#34;&#34;
            # Protect variables if required
            if protection or self._protection:
                slines[i], escape2 = self.protect(slines[i])
            # conversion
            if ispstr:
                slines[i] = pstr.eval(tmp.format(slines[i],escape=escape),ispstr=ispstr)
            else:
                if fullevaluation:
                    try:
                        resstr =tmp.format(slines[i],escape=escape)
                    except:
                        resstr = param.safe_fstring(slines[i],tmp,varprefix=&#34;&#34;)
                    try:
                        #reseval = evaluator.evaluate(resstr)
                        reseval = evaluate_with_placeholders(slines_priorescape[i],evaluator,evaluator_nocontext,raiseerror=True)
                        slines[i] = str(reseval)+&#34; &#34;+comment if comment else str(reseval)
                    except:
                        slines[i] = resstr + comment
                else:
                    slines[i] = tmp.format(slines[i],escape=escape)+comment
            # convert starting % into # to authorize replacement in comments
            if len(slines[i])&gt;0:
                if slines[i][0] == &#34;%&#34;: slines[i]=&#34;#&#34;+slines[i][1:]
        return &#34;\n&#34;.join(slines)</code></pre>
</details>
</dd>
<dt id="mstruct.param.getval"><code class="name flex">
<span>def <span class="ident">getval</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the evaluated value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getval(self,key):
    &#34;&#34;&#34; returns the evaluated value &#34;&#34;&#34;
    s = self.eval()
    return getattr(s,key)</code></pre>
</details>
</dd>
<dt id="mstruct.param.protect"><code class="name flex">
<span>def <span class="ident">protect</span></span>(<span>self, s='')</span>
</code></dt>
<dd>
<div class="desc"><p>protect $variable as ${variable}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protect(self,s=&#34;&#34;):
    &#34;&#34;&#34; protect $variable as ${variable} &#34;&#34;&#34;
    if isinstance(s,str):
        t = s.replace(r&#34;\$&#34;,&#34;££&#34;) # &amp;&amp; is a placeholder
        escape = t!=s
        for k in self.keyssorted():
            t = t.replace(&#34;$&#34;+k,&#34;${&#34;+k+&#34;}&#34;)
        if escape: t = t.replace(&#34;££&#34;,r&#34;\$&#34;)
        if isinstance(s,pstr): t = pstr(t)
        return t, escape
    raise TypeError(f&#39;the argument must be string not {type(s)}&#39;)</code></pre>
</details>
</dd>
<dt id="mstruct.param.toparamauto"><code class="name flex">
<span>def <span class="ident">toparamauto</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>convert a param instance into a paramauto instance
toparamauto()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toparamauto(self):
    &#34;&#34;&#34;
        convert a param instance into a paramauto instance
            toparamauto()
    &#34;&#34;&#34;
    return paramauto(**self)</code></pre>
</details>
</dd>
<dt id="mstruct.param.tostatic"><code class="name flex">
<span>def <span class="ident">tostatic</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>convert dynamic a param() object to a static struct() object.
note: no interpretation
note: use tostruct() to interpret them and convert it to struct
note: tostatic().struct2param() makes it reversible</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tostatic(self):
    &#34;&#34;&#34; convert dynamic a param() object to a static struct() object.
        note: no interpretation
        note: use tostruct() to interpret them and convert it to struct
        note: tostatic().struct2param() makes it reversible
    &#34;&#34;&#34;
    return struct.fromkeysvalues(self.keys(),self.values(),makeparam=False)</code></pre>
</details>
</dd>
<dt id="mstruct.param.tostruct"><code class="name flex">
<span>def <span class="ident">tostruct</span></span>(<span>self, protection=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generate the evaluated structure
tostruct(protection=False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tostruct(self,protection=False):
    &#34;&#34;&#34;
        generate the evaluated structure
            tostruct(protection=False)
    &#34;&#34;&#34;
    return self.eval(protection=protection)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mstruct.struct" href="#mstruct.struct">struct</a></b></code>:
<ul class="hlist">
<li><code><a title="mstruct.struct.check" href="#mstruct.struct.check">check</a></code></li>
<li><code><a title="mstruct.struct.clear" href="#mstruct.struct.clear">clear</a></code></li>
<li><code><a title="mstruct.struct.dict2struct" href="#mstruct.struct.dict2struct">dict2struct</a></code></li>
<li><code><a title="mstruct.struct.disp" href="#mstruct.struct.disp">disp</a></code></li>
<li><code><a title="mstruct.struct.dispmax" href="#mstruct.struct.dispmax">dispmax</a></code></li>
<li><code><a title="mstruct.struct.format" href="#mstruct.struct.format">format</a></code></li>
<li><code><a title="mstruct.struct.format_array" href="#mstruct.struct.format_array">format_array</a></code></li>
<li><code><a title="mstruct.struct.format_legacy" href="#mstruct.struct.format_legacy">format_legacy</a></code></li>
<li><code><a title="mstruct.struct.fromkeys" href="#mstruct.struct.fromkeys">fromkeys</a></code></li>
<li><code><a title="mstruct.struct.fromkeysvalues" href="#mstruct.struct.fromkeysvalues">fromkeysvalues</a></code></li>
<li><code><a title="mstruct.struct.generator" href="#mstruct.struct.generator">generator</a></code></li>
<li><code><a title="mstruct.struct.getattr" href="#mstruct.struct.getattr">getattr</a></code></li>
<li><code><a title="mstruct.struct.hasattr" href="#mstruct.struct.hasattr">hasattr</a></code></li>
<li><code><a title="mstruct.struct.importfrom" href="#mstruct.struct.importfrom">importfrom</a></code></li>
<li><code><a title="mstruct.struct.isdefined" href="#mstruct.struct.isdefined">isdefined</a></code></li>
<li><code><a title="mstruct.struct.isempty" href="#mstruct.struct.isempty">isempty</a></code></li>
<li><code><a title="mstruct.struct.isexpression" href="#mstruct.struct.isexpression">isexpression</a></code></li>
<li><code><a title="mstruct.struct.isstrdefined" href="#mstruct.struct.isstrdefined">isstrdefined</a></code></li>
<li><code><a title="mstruct.struct.isstrexpression" href="#mstruct.struct.isstrexpression">isstrexpression</a></code></li>
<li><code><a title="mstruct.struct.items" href="#mstruct.struct.items">items</a></code></li>
<li><code><a title="mstruct.struct.keys" href="#mstruct.struct.keys">keys</a></code></li>
<li><code><a title="mstruct.struct.keyssorted" href="#mstruct.struct.keyssorted">keyssorted</a></code></li>
<li><code><a title="mstruct.struct.np2str" href="#mstruct.struct.np2str">np2str</a></code></li>
<li><code><a title="mstruct.struct.numrepl" href="#mstruct.struct.numrepl">numrepl</a></code></li>
<li><code><a title="mstruct.struct.read" href="#mstruct.struct.read">read</a></code></li>
<li><code><a title="mstruct.struct.scan" href="#mstruct.struct.scan">scan</a></code></li>
<li><code><a title="mstruct.struct.set" href="#mstruct.struct.set">set</a></code></li>
<li><code><a title="mstruct.struct.setattr" href="#mstruct.struct.setattr">setattr</a></code></li>
<li><code><a title="mstruct.struct.sortdefinitions" href="#mstruct.struct.sortdefinitions">sortdefinitions</a></code></li>
<li><code><a title="mstruct.struct.struct2dict" href="#mstruct.struct.struct2dict">struct2dict</a></code></li>
<li><code><a title="mstruct.struct.struct2param" href="#mstruct.struct.struct2param">struct2param</a></code></li>
<li><code><a title="mstruct.struct.update" href="#mstruct.struct.update">update</a></code></li>
<li><code><a title="mstruct.struct.validkeys" href="#mstruct.struct.validkeys">validkeys</a></code></li>
<li><code><a title="mstruct.struct.values" href="#mstruct.struct.values">values</a></code></li>
<li><code><a title="mstruct.struct.write" href="#mstruct.struct.write">write</a></code></li>
<li><code><a title="mstruct.struct.zip" href="#mstruct.struct.zip">zip</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mstruct.paramauto"><code class="flex name class">
<span>class <span class="ident">paramauto</span></span>
<span>(</span><span>sortdefinitions=False, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-paramauto">Class: <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code></h1>
<p>A subclass of <code><a title="mstruct.param" href="#mstruct.param">param</a></code> with enhanced handling for automatic sorting and evaluation
of definitions. The <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> class ensures that all fields are sorted to resolve
dependencies, allowing seamless stacking of partially defined objects.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Inherits all functionalities of <code><a title="mstruct.param" href="#mstruct.param">param</a></code>.</li>
<li>Automatically sorts definitions for dependency resolution.</li>
<li>Simplifies handling of partial definitions in dynamic structures.</li>
<li>Supports safe concatenation of definitions.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="automatic-dependency-sorting">Automatic Dependency Sorting</h4>
<p>Definitions are automatically sorted to resolve dependencies:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${b}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${b} (= 3)
# --------
</code></pre>
<h4 id="handling-missing-definitions">Handling Missing Definitions</h4>
<p>Unresolved dependencies raise warnings but do not block execution:</p>
<pre><code class="language-python">p = paramauto(a=1, b=&quot;${a}+1&quot;, c=&quot;${a}+${d}&quot;)
p.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 1 (= 2)
#      c: ${a} + ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-inheritance">Concatenation and Inheritance</h3>
<p>Concatenating <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> objects resolves definitions:</p>
<pre><code class="language-python">p1 = paramauto(a=1, b=&quot;${a}+2&quot;)
p2 = paramauto(c=&quot;${b}*3&quot;)
p3 = p1 + p2
p3.disp()
# Output:
# --------
#      a: 1
#      b: ${a} + 2 (= 3)
#      c: ${b} * 3 (= 9)
# --------
</code></pre>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Automatically sorts fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate all fields, resolving dependencies.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display all fields with their resolved values.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="overloaded-operators">Overloaded Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenates two <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> objects, resolving dependencies.</li>
<li><code>+=</code>: Updates the current object with another, resolving dependencies.</li>
<li><code>len()</code>: Number of fields.</li>
<li><code>in</code>: Check for field existence.</li>
</ul>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="partial-definitions">Partial Definitions</h4>
<p>The <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> class simplifies handling of partially defined fields:</p>
<pre><code class="language-python">p = paramauto(a=&quot;${d}&quot;, b=&quot;${a}+1&quot;)
p.disp()
# Warning: Unable to resolve dependencies.
# --------
#      a: ${d} (= &lt; undef definition &quot;${d}&quot; &gt;)
#      b: ${a} + 1 (= &lt; undef definition &quot;${d}&quot; &gt;)
# --------

p.d = 10
p.disp()
# Dependencies are resolved:
# --------
#      d: 10
#      a: ${d} (= 10)
#      b: ${a} + 1 (= 11)
# --------
</code></pre>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>The <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> class is computationally more intensive than <code><a title="mstruct.param" href="#mstruct.param">param</a></code> due to automatic sorting.</li>
<li>It is ideal for managing dynamic systems with complex interdependencies.</li>
</ul>
<h3 id="examples_1">Examples</h3>
<pre><code>            p = paramauto()
            p.b = "${aa}"
            p.disp()
        yields
            WARNING: unable to interpret 1/1 expressions in "definitions"
              -----------:----------------------------------------
                        b: ${aa}
                         = &lt; undef definition "${aa}" &gt;
              -----------:----------------------------------------
              p.aa = 2
              p.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
            -----------:----------------------------------------
            q = paramauto(c="${aa}+${b}")+p
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 2
                      b: ${aa}
                       = 2
                      c: ${aa}+${b}
                       = 4
            -----------:----------------------------------------
            q.aa = 30
            q.disp()
        yields
            -----------:----------------------------------------
                     aa: 30
                      b: ${aa}
                       = 30
                      c: ${aa}+${b}
                       = 60
            -----------:----------------------------------------
            q.aa = "${d}"
            q.disp()
        yields multiple errors (recursion)
        WARNING: unable to interpret 3/3 expressions in "definitions"
          -----------:----------------------------------------
                   aa: ${d}
                     = &lt; undef definition "${d}" &gt;
                    b: ${aa}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                    c: ${aa}+${b}
                     = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
          -----------:----------------------------------------
            q.d = 100
            q.disp()
        yields
          -----------:----------------------------------------
                    d: 100
                   aa: ${d}
                     = 100
                    b: ${aa}
                     = 100
                    c: ${aa}+${b}
                     = 200
          -----------:----------------------------------------


    Example:

        p = paramauto(b="${a}+1",c="${a}+${d}",a=1)
        p.disp()
    generates:
        WARNING: unable to interpret 1/3 expressions in "definitions"
          -----------:----------------------------------------
                    a: 1
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = &lt; undef definition "${d}" &gt;
          -----------:----------------------------------------
    setting p.d
        p.d = 2
        p.disp()
    produces
          -----------:----------------------------------------
                    a: 1
                    d: 2
                    b: ${a}+1
                     = 2
                    c: ${a}+${d}
                     = 3
          -----------:----------------------------------------
</code></pre>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class paramauto(param):
    &#34;&#34;&#34;
    Class: `paramauto`
    ==================

    A subclass of `param` with enhanced handling for automatic sorting and evaluation
    of definitions. The `paramauto` class ensures that all fields are sorted to resolve
    dependencies, allowing seamless stacking of partially defined objects.

    ---

    ### Features
    - Inherits all functionalities of `param`.
    - Automatically sorts definitions for dependency resolution.
    - Simplifies handling of partial definitions in dynamic structures.
    - Supports safe concatenation of definitions.

    ---

    ### Examples

    #### Automatic Dependency Sorting
    Definitions are automatically sorted to resolve dependencies:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${b}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${b} (= 3)
    # --------
    ```

    #### Handling Missing Definitions
    Unresolved dependencies raise warnings but do not block execution:
    ```python
    p = paramauto(a=1, b=&#34;${a}+1&#34;, c=&#34;${a}+${d}&#34;)
    p.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 1 (= 2)
    #      c: ${a} + ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------
    ```

    ---

    ### Concatenation and Inheritance
    Concatenating `paramauto` objects resolves definitions:
    ```python
    p1 = paramauto(a=1, b=&#34;${a}+2&#34;)
    p2 = paramauto(c=&#34;${b}*3&#34;)
    p3 = p1 + p2
    p3.disp()
    # Output:
    # --------
    #      a: 1
    #      b: ${a} + 2 (= 3)
    #      c: ${b} * 3 (= 9)
    # --------
    ```

    ---

    ### Utility Methods

    | Method                | Description                                            |
    |-----------------------|--------------------------------------------------------|
    | `sortdefinitions()`   | Automatically sorts fields to resolve dependencies.    |
    | `eval()`              | Evaluate all fields, resolving dependencies.           |
    | `disp()`              | Display all fields with their resolved values.         |

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `+`: Concatenates two `paramauto` objects, resolving dependencies.
    - `+=`: Updates the current object with another, resolving dependencies.
    - `len()`: Number of fields.
    - `in`: Check for field existence.

    ---

    ### Advanced Usage

    #### Partial Definitions
    The `paramauto` class simplifies handling of partially defined fields:
    ```python
    p = paramauto(a=&#34;${d}&#34;, b=&#34;${a}+1&#34;)
    p.disp()
    # Warning: Unable to resolve dependencies.
    # --------
    #      a: ${d} (= &lt; undef definition &#34;${d}&#34; &gt;)
    #      b: ${a} + 1 (= &lt; undef definition &#34;${d}&#34; &gt;)
    # --------

    p.d = 10
    p.disp()
    # Dependencies are resolved:
    # --------
    #      d: 10
    #      a: ${d} (= 10)
    #      b: ${a} + 1 (= 11)
    # --------
    ```

    ---

    ### Notes
    - The `paramauto` class is computationally more intensive than `param` due to automatic sorting.
    - It is ideal for managing dynamic systems with complex interdependencies.

    ### Examples
                    p = paramauto()
                    p.b = &#34;${aa}&#34;
                    p.disp()
                yields
                    WARNING: unable to interpret 1/1 expressions in &#34;definitions&#34;
                      -----------:----------------------------------------
                                b: ${aa}
                                 = &lt; undef definition &#34;${aa}&#34; &gt;
                      -----------:----------------------------------------
                      p.aa = 2
                      p.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                    -----------:----------------------------------------
                    q = paramauto(c=&#34;${aa}+${b}&#34;)+p
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 2
                              b: ${aa}
                               = 2
                              c: ${aa}+${b}
                               = 4
                    -----------:----------------------------------------
                    q.aa = 30
                    q.disp()
                yields
                    -----------:----------------------------------------
                             aa: 30
                              b: ${aa}
                               = 30
                              c: ${aa}+${b}
                               = 60
                    -----------:----------------------------------------
                    q.aa = &#34;${d}&#34;
                    q.disp()
                yields multiple errors (recursion)
                WARNING: unable to interpret 3/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                           aa: ${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                            b: ${aa}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                            c: ${aa}+${b}
                             = Eval Error &lt; invalid [...] (&lt;string&gt;, line 1) &gt;
                  -----------:----------------------------------------
                    q.d = 100
                    q.disp()
                yields
                  -----------:----------------------------------------
                            d: 100
                           aa: ${d}
                             = 100
                            b: ${aa}
                             = 100
                            c: ${aa}+${b}
                             = 200
                  -----------:----------------------------------------


            Example:

                p = paramauto(b=&#34;${a}+1&#34;,c=&#34;${a}+${d}&#34;,a=1)
                p.disp()
            generates:
                WARNING: unable to interpret 1/3 expressions in &#34;definitions&#34;
                  -----------:----------------------------------------
                            a: 1
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = &lt; undef definition &#34;${d}&#34; &gt;
                  -----------:----------------------------------------
            setting p.d
                p.d = 2
                p.disp()
            produces
                  -----------:----------------------------------------
                            a: 1
                            d: 2
                            b: ${a}+1
                             = 2
                            c: ${a}+${d}
                             = 3
                  -----------:----------------------------------------

    &#34;&#34;&#34;

    def __add__(self,p):
        return super().__add__(p,sortdefinitions=True,raiseerror=False)
        self._needs_sorting = True

    def __iadd__(self,p):
        return super().__iadd__(p,sortdefinitions=True,raiseerror=False)
        self._needs_sorting = True

    def __repr__(self):
        self.sortdefinitions(raiseerror=False)
        #super(param,self).__repr__()
        super().__repr__()
        return str(self)

    def setattr(self,key,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0 and key in self:
            delattr(self, key)
        else:
            self.__dict__[key] = value
            self.__dict__[&#34;_needs_sorting&#34;] = True

    def sortdefinitions(self, raiseerror=True, silentmode=True):
        if self._needs_sorting:
            super().sortdefinitions(raiseerror=raiseerror, silentmode=silentmode)
            self._needs_sorting = False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mstruct.param" href="#mstruct.param">param</a></li>
<li><a title="mstruct.struct" href="#mstruct.struct">struct</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mstruct.param" href="#mstruct.param">param</a></b></code>:
<ul class="hlist">
<li><code><a title="mstruct.param.check" href="#mstruct.struct.check">check</a></code></li>
<li><code><a title="mstruct.param.clear" href="#mstruct.struct.clear">clear</a></code></li>
<li><code><a title="mstruct.param.convert_matlab_like_arrays" href="#mstruct.param.convert_matlab_like_arrays">convert_matlab_like_arrays</a></code></li>
<li><code><a title="mstruct.param.dict2struct" href="#mstruct.struct.dict2struct">dict2struct</a></code></li>
<li><code><a title="mstruct.param.disp" href="#mstruct.struct.disp">disp</a></code></li>
<li><code><a title="mstruct.param.dispmax" href="#mstruct.struct.dispmax">dispmax</a></code></li>
<li><code><a title="mstruct.param.escape" href="#mstruct.param.escape">escape</a></code></li>
<li><code><a title="mstruct.param.eval" href="#mstruct.param.eval">eval</a></code></li>
<li><code><a title="mstruct.param.expand_ranges" href="#mstruct.param.expand_ranges">expand_ranges</a></code></li>
<li><code><a title="mstruct.param.format" href="#mstruct.struct.format">format</a></code></li>
<li><code><a title="mstruct.param.format_array" href="#mstruct.struct.format_array">format_array</a></code></li>
<li><code><a title="mstruct.param.format_legacy" href="#mstruct.struct.format_legacy">format_legacy</a></code></li>
<li><code><a title="mstruct.param.formateval" href="#mstruct.param.formateval">formateval</a></code></li>
<li><code><a title="mstruct.param.fromkeys" href="#mstruct.struct.fromkeys">fromkeys</a></code></li>
<li><code><a title="mstruct.param.fromkeysvalues" href="#mstruct.struct.fromkeysvalues">fromkeysvalues</a></code></li>
<li><code><a title="mstruct.param.generator" href="#mstruct.struct.generator">generator</a></code></li>
<li><code><a title="mstruct.param.getattr" href="#mstruct.struct.getattr">getattr</a></code></li>
<li><code><a title="mstruct.param.getval" href="#mstruct.param.getval">getval</a></code></li>
<li><code><a title="mstruct.param.hasattr" href="#mstruct.struct.hasattr">hasattr</a></code></li>
<li><code><a title="mstruct.param.importfrom" href="#mstruct.struct.importfrom">importfrom</a></code></li>
<li><code><a title="mstruct.param.isdefined" href="#mstruct.struct.isdefined">isdefined</a></code></li>
<li><code><a title="mstruct.param.isempty" href="#mstruct.struct.isempty">isempty</a></code></li>
<li><code><a title="mstruct.param.isexpression" href="#mstruct.struct.isexpression">isexpression</a></code></li>
<li><code><a title="mstruct.param.isstrdefined" href="#mstruct.struct.isstrdefined">isstrdefined</a></code></li>
<li><code><a title="mstruct.param.isstrexpression" href="#mstruct.struct.isstrexpression">isstrexpression</a></code></li>
<li><code><a title="mstruct.param.items" href="#mstruct.struct.items">items</a></code></li>
<li><code><a title="mstruct.param.keys" href="#mstruct.struct.keys">keys</a></code></li>
<li><code><a title="mstruct.param.keyssorted" href="#mstruct.struct.keyssorted">keyssorted</a></code></li>
<li><code><a title="mstruct.param.np2str" href="#mstruct.struct.np2str">np2str</a></code></li>
<li><code><a title="mstruct.param.numrepl" href="#mstruct.struct.numrepl">numrepl</a></code></li>
<li><code><a title="mstruct.param.protect" href="#mstruct.param.protect">protect</a></code></li>
<li><code><a title="mstruct.param.read" href="#mstruct.struct.read">read</a></code></li>
<li><code><a title="mstruct.param.replace_matrix_shorthand" href="#mstruct.param.replace_matrix_shorthand">replace_matrix_shorthand</a></code></li>
<li><code><a title="mstruct.param.safe_fstring" href="#mstruct.param.safe_fstring">safe_fstring</a></code></li>
<li><code><a title="mstruct.param.scan" href="#mstruct.struct.scan">scan</a></code></li>
<li><code><a title="mstruct.param.set" href="#mstruct.struct.set">set</a></code></li>
<li><code><a title="mstruct.param.setattr" href="#mstruct.struct.setattr">setattr</a></code></li>
<li><code><a title="mstruct.param.sortdefinitions" href="#mstruct.struct.sortdefinitions">sortdefinitions</a></code></li>
<li><code><a title="mstruct.param.struct2dict" href="#mstruct.struct.struct2dict">struct2dict</a></code></li>
<li><code><a title="mstruct.param.struct2param" href="#mstruct.struct.struct2param">struct2param</a></code></li>
<li><code><a title="mstruct.param.toparamauto" href="#mstruct.param.toparamauto">toparamauto</a></code></li>
<li><code><a title="mstruct.param.tostatic" href="#mstruct.param.tostatic">tostatic</a></code></li>
<li><code><a title="mstruct.param.tostruct" href="#mstruct.param.tostruct">tostruct</a></code></li>
<li><code><a title="mstruct.param.update" href="#mstruct.struct.update">update</a></code></li>
<li><code><a title="mstruct.param.validkeys" href="#mstruct.struct.validkeys">validkeys</a></code></li>
<li><code><a title="mstruct.param.values" href="#mstruct.struct.values">values</a></code></li>
<li><code><a title="mstruct.param.write" href="#mstruct.struct.write">write</a></code></li>
<li><code><a title="mstruct.param.zip" href="#mstruct.struct.zip">zip</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mstruct.pstr"><code class="flex name class">
<span>class <span class="ident">pstr</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-pstr">Class: <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code></h1>
<p>A specialized string class for handling paths and filenames, derived from <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code>.
The <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> class ensures compatibility with POSIX-style paths and provides enhanced
operations for path manipulation.</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Maintains POSIX-style paths.</li>
<li>Automatically handles trailing slashes.</li>
<li>Supports path concatenation using <code>/</code>.</li>
<li>Converts seamlessly back to <code>str</code> for compatibility with string methods.</li>
<li>Includes additional utility methods for path evaluation and formatting.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage">Basic Usage</h4>
<pre><code class="language-python">a = pstr(&quot;this/is/mypath//&quot;)
b = pstr(&quot;mylocalfolder/myfile.ext&quot;)
c = a / b
print(c)  # this/is/mypath/mylocalfolder/myfile.ext
</code></pre>
<h4 id="keeping-trailing-slashes">Keeping Trailing Slashes</h4>
<pre><code class="language-python">a = pstr(&quot;this/is/mypath//&quot;)
print(a)  # this/is/mypath/
</code></pre>
<hr>
<h3 id="path-operations">Path Operations</h3>
<h4 id="path-concatenation">Path Concatenation</h4>
<p>Use the <code>/</code> operator to concatenate paths:</p>
<pre><code class="language-python">a = pstr(&quot;folder/subfolder&quot;)
b = pstr(&quot;file.txt&quot;)
c = a / b
print(c)  # folder/subfolder/file.txt
</code></pre>
<h4 id="path-evaluation">Path Evaluation</h4>
<p>Evaluate or convert paths while preserving the <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> type:</p>
<pre><code class="language-python">result = pstr.eval(&quot;some/path/afterreplacement&quot;, ispstr=True)
print(result)  # some/path/afterreplacement
</code></pre>
<hr>
<h3 id="advanced-usage">Advanced Usage</h3>
<h4 id="using-string-methods">Using String Methods</h4>
<p>Methods like <code>replace()</code> convert <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> back to <code>str</code>. To retain the <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> type:</p>
<pre><code class="language-python">new_path = pstr.eval(a.replace(&quot;mypath&quot;, &quot;newpath&quot;), ispstr=True)
print(new_path)  # this/is/newpath/
</code></pre>
<h4 id="handling-posix-paths">Handling POSIX Paths</h4>
<p>The <code><a title="mstruct.pstr.topath" href="#mstruct.pstr.topath">pstr.topath()</a></code> method ensures the path remains POSIX-compliant:</p>
<pre><code class="language-python">path = pstr(&quot;C:\Windows\Path&quot;)
posix_path = path.topath()
print(posix_path)  # C:/Windows/Path
</code></pre>
<hr>
<h3 id="overloaded-operators">Overloaded Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>/</code>: Concatenates two paths (<code>__truediv__</code>).</li>
<li><code>+</code>: Concatenates strings as paths, resulting in a <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> object (<code>__add__</code>).</li>
<li><code>+=</code>: Adds to an existing <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> object (<code>__iadd__</code>).</li>
</ul>
<hr>
<h3 id="utility-methods">Utility Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>eval(value)</code></td>
<td>Evaluates the path or string for compatibility with <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code>.</td>
</tr>
<tr>
<td><code>topath()</code></td>
<td>Returns the POSIX-compliant path.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="notes">Notes</h3>
<ul>
<li>Use <code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> for consistent and safe handling of file paths across different platforms.</li>
<li>Converts back to <code>str</code> when using non-<code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code> specific methods to ensure compatibility.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pstr(str):
    &#34;&#34;&#34;
    Class: `pstr`
    =============

    A specialized string class for handling paths and filenames, derived from `struct`.
    The `pstr` class ensures compatibility with POSIX-style paths and provides enhanced
    operations for path manipulation.

    ---

    ### Features
    - Maintains POSIX-style paths.
    - Automatically handles trailing slashes.
    - Supports path concatenation using `/`.
    - Converts seamlessly back to `str` for compatibility with string methods.
    - Includes additional utility methods for path evaluation and formatting.

    ---

    ### Examples

    #### Basic Usage
    ```python
    a = pstr(&#34;this/is/mypath//&#34;)
    b = pstr(&#34;mylocalfolder/myfile.ext&#34;)
    c = a / b
    print(c)  # this/is/mypath/mylocalfolder/myfile.ext
    ```

    #### Keeping Trailing Slashes
    ```python
    a = pstr(&#34;this/is/mypath//&#34;)
    print(a)  # this/is/mypath/
    ```

    ---

    ### Path Operations

    #### Path Concatenation
    Use the `/` operator to concatenate paths:
    ```python
    a = pstr(&#34;folder/subfolder&#34;)
    b = pstr(&#34;file.txt&#34;)
    c = a / b
    print(c)  # folder/subfolder/file.txt
    ```

    #### Path Evaluation
    Evaluate or convert paths while preserving the `pstr` type:
    ```python
    result = pstr.eval(&#34;some/path/afterreplacement&#34;, ispstr=True)
    print(result)  # some/path/afterreplacement
    ```

    ---

    ### Advanced Usage

    #### Using String Methods
    Methods like `replace()` convert `pstr` back to `str`. To retain the `pstr` type:
    ```python
    new_path = pstr.eval(a.replace(&#34;mypath&#34;, &#34;newpath&#34;), ispstr=True)
    print(new_path)  # this/is/newpath/
    ```

    #### Handling POSIX Paths
    The `pstr.topath()` method ensures the path remains POSIX-compliant:
    ```python
    path = pstr(&#34;C:\\Windows\\Path&#34;)
    posix_path = path.topath()
    print(posix_path)  # C:/Windows/Path
    ```

    ---

    ### Overloaded Operators

    #### Supported Operators
    - `/`: Concatenates two paths (`__truediv__`).
    - `+`: Concatenates strings as paths, resulting in a `pstr` object (`__add__`).
    - `+=`: Adds to an existing `pstr` object (`__iadd__`).

    ---

    ### Utility Methods

    | Method          | Description                                  |
    |------------------|----------------------------------------------|
    | `eval(value)`    | Evaluates the path or string for compatibility with `pstr`. |
    | `topath()`       | Returns the POSIX-compliant path.           |

    ---

    ### Notes
    - Use `pstr` for consistent and safe handling of file paths across different platforms.
    - Converts back to `str` when using non-`pstr` specific methods to ensure compatibility.
    &#34;&#34;&#34;

    def __repr__(self):
        result = self.topath()
        if result[-1] != &#34;/&#34; and self[-1] == &#34;/&#34;:
            result += &#34;/&#34;
        return result

    def topath(self):
        &#34;&#34;&#34; return a validated path &#34;&#34;&#34;
        value = pstr(PurePath(self))
        if value[-1] != &#34;/&#34; and self [-1]==&#34;/&#34;:
            value += &#34;/&#34;
        return value


    @staticmethod
    def eval(value,ispstr=False):
        &#34;&#34;&#34; evaluate the path of it os a path &#34;&#34;&#34;
        if isinstance(value,pstr):
            return value.topath()
        elif isinstance(value,PurePath) or ispstr:
            return pstr(value).topath()
        else:
            return value

    def __truediv__(self,value):
        &#34;&#34;&#34; overload / &#34;&#34;&#34;
        operand = pstr.eval(value)
        result = pstr(PurePath(self) / operand)
        if result[-1] != &#34;/&#34; and operand[-1] == &#34;/&#34;:
            result += &#34;/&#34;
        return result

    def __add__(self,value):
        return pstr(str(self)+value)

    def __iadd__(self,value):
        return pstr(str(self)+value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mstruct.pstr.eval"><code class="name flex">
<span>def <span class="ident">eval</span></span>(<span>value, ispstr=False)</span>
</code></dt>
<dd>
<div class="desc"><p>evaluate the path of it os a path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def eval(value,ispstr=False):
    &#34;&#34;&#34; evaluate the path of it os a path &#34;&#34;&#34;
    if isinstance(value,pstr):
        return value.topath()
    elif isinstance(value,PurePath) or ispstr:
        return pstr(value).topath()
    else:
        return value</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mstruct.pstr.topath"><code class="name flex">
<span>def <span class="ident">topath</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return a validated path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def topath(self):
    &#34;&#34;&#34; return a validated path &#34;&#34;&#34;
    value = pstr(PurePath(self))
    if value[-1] != &#34;/&#34; and self [-1]==&#34;/&#34;:
        value += &#34;/&#34;
    return value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mstruct.struct"><code class="flex name class">
<span>class <span class="ident">struct</span></span>
<span>(</span><span>debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><h1 id="class-struct">Class: <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code></h1>
<p>A lightweight class that mimics Matlab-like structures, with additional features
such as dynamic field creation, indexing, concatenation, and compatibility with
evaluated parameters (<code><a title="mstruct.param" href="#mstruct.param">param</a></code>).</p>
<hr>
<h3 id="features">Features</h3>
<ul>
<li>Dynamic creation of fields.</li>
<li>Indexing and iteration support for fields.</li>
<li>Concatenation and subtraction of structures.</li>
<li>Conversion to and from dictionaries.</li>
<li>Compatible with <code><a title="mstruct.param" href="#mstruct.param">param</a></code> and <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code> for evaluation and dependency handling.</li>
</ul>
<hr>
<h3 id="examples">Examples</h3>
<h4 id="basic-usage">Basic Usage</h4>
<pre><code class="language-python">s = struct(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
print(s.a)  # 1
s.d = 11    # Append a new field
delattr(s, 'd')  # Delete the field
</code></pre>
<h4 id="using-param-for-evaluation">Using <code><a title="mstruct.param" href="#mstruct.param">param</a></code> for Evaluation</h4>
<pre><code class="language-python">p = param(a=1, b=2, c='${a} + ${b} # evaluate me if you can')
p.eval()
# Output:
# --------
#      a: 1
#      b: 2
#      c: ${a} + ${b} # evaluate me if you can (= 3)
# --------
</code></pre>
<hr>
<h3 id="concatenation-and-subtraction">Concatenation and Subtraction</h3>
<p>Fields from the right-most structure overwrite existing values.</p>
<pre><code class="language-python">a = struct(a=1, b=2)
b = struct(c=3, d=&quot;d&quot;, e=&quot;e&quot;)
c = a + b
e = c - a
</code></pre>
<hr>
<h3 id="practical-shorthands">Practical Shorthands</h3>
<h4 id="constructing-a-structure-from-keys">Constructing a Structure from Keys</h4>
<pre><code class="language-python">s = struct.fromkeys([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;])
# Output:
# --------
#      a: None
#      b: None
#      c: None
#      d: None
# --------
</code></pre>
<h4 id="building-a-structure-from-variables-in-a-string">Building a Structure from Variables in a String</h4>
<pre><code class="language-python">s = struct.scan(&quot;${a} + ${b} * ${c} / ${d} --- ${ee}&quot;)
s.a = 1
s.b = &quot;test&quot;
s.c = [1, &quot;a&quot;, 2]
s.generator()
# Output:
# X = struct(
#      a=1,
#      b=&quot;test&quot;,
#      c=[1, 'a', 2],
#      d=None,
#      ee=None
# )
</code></pre>
<h4 id="indexing-and-iteration">Indexing and Iteration</h4>
<p>Structures can be indexed or sliced like lists.</p>
<pre><code class="language-python">c = a + b
c[0]      # Access the first field
c[-1]     # Access the last field
c[:2]     # Slice the structure
for field in c:
    print(field)
</code></pre>
<hr>
<h3 id="dynamic-dependency-management">Dynamic Dependency Management</h3>
<p><code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code> provides control over dependencies, sorting, and evaluation.</p>
<pre><code class="language-python">s = struct(d=3, e=&quot;${c} + {d}&quot;, c='${a} + ${b}', a=1, b=2)
s.sortdefinitions()
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}
#      e: ${c} + ${d}
# --------
</code></pre>
<p>For dynamic evaluation, use <code><a title="mstruct.param" href="#mstruct.param">param</a></code>:</p>
<pre><code class="language-python">p = param(sortdefinitions=True, d=3, e=&quot;${c} + ${d}&quot;, c='${a} + ${b}', a=1, b=2)
# Output:
# --------
#      d: 3
#      a: 1
#      b: 2
#      c: ${a} + ${b}  (= 3)
#      e: ${c} + ${d}  (= 6)
# --------
</code></pre>
<hr>
<h3 id="overloaded-methods-and-operators">Overloaded Methods and Operators</h3>
<h4 id="supported-operators">Supported Operators</h4>
<ul>
<li><code>+</code>: Concatenation of two structures (<code>__add__</code>).</li>
<li><code>-</code>: Subtraction of fields (<code>__sub__</code>).</li>
<li><code>&lt;&lt;</code>: Import values from another structure (<code>__lshift__</code>)</li>
<li><code>len()</code>: Number of fields (<code>__len__</code>).</li>
<li><code>in</code>: Check for field existence (<code>__contains__</code>).</li>
</ul>
<h4 id="method-overview">Method Overview</h4>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>check(default)</code></td>
<td>Populate fields with defaults if missing.</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>Remove all fields.</td>
</tr>
<tr>
<td><code>dict2struct(dico)</code></td>
<td>Create a structure from a dictionary.</td>
</tr>
<tr>
<td><code>disp()</code></td>
<td>Display the structure.</td>
</tr>
<tr>
<td><code>eval()</code></td>
<td>Evaluate expressions within fields.</td>
</tr>
<tr>
<td><code>fromkeys(keys)</code></td>
<td>Create a structure from a list of keys.</td>
</tr>
<tr>
<td><code>generator()</code></td>
<td>Generate Python code representing the structure.</td>
</tr>
<tr>
<td><code>importfrom()</code></td>
<td>Import undefined values from another struct or dict.</td>
</tr>
<tr>
<td><code>items()</code></td>
<td>Return key-value pairs.</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>Return all keys in the structure.</td>
</tr>
<tr>
<td><code>read(file)</code></td>
<td>Load structure fields from a file.</td>
</tr>
<tr>
<td><code>scan(string)</code></td>
<td>Extract variables from a string and populate fields.</td>
</tr>
<tr>
<td><code>sortdefinitions()</code></td>
<td>Sort fields to resolve dependencies.</td>
</tr>
<tr>
<td><code>struct2dict()</code></td>
<td>Convert the structure to a dictionary.</td>
</tr>
<tr>
<td><code>validkeys()</code></td>
<td>Return valid keys</td>
</tr>
<tr>
<td><code>values()</code></td>
<td>Return all field values.</td>
</tr>
<tr>
<td><code>write(file)</code></td>
<td>Save the structure to a file.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="dynamic-properties">Dynamic Properties</h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isempty</code></td>
<td><code>True</code> if the structure is empty.</td>
</tr>
<tr>
<td><code>isdefined</code></td>
<td><code>True</code> if all fields are defined.</td>
</tr>
</tbody>
</table>
<hr>
<p>constructor, use debug=True to report eval errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class struct():
    &#34;&#34;&#34;
    Class: `struct`
    ================

    A lightweight class that mimics Matlab-like structures, with additional features
    such as dynamic field creation, indexing, concatenation, and compatibility with
    evaluated parameters (`param`).

    ---

    ### Features
    - Dynamic creation of fields.
    - Indexing and iteration support for fields.
    - Concatenation and subtraction of structures.
    - Conversion to and from dictionaries.
    - Compatible with `param` and `paramauto` for evaluation and dependency handling.

    ---

    ### Examples

    #### Basic Usage
    ```python
    s = struct(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    print(s.a)  # 1
    s.d = 11    # Append a new field
    delattr(s, &#39;d&#39;)  # Delete the field
    ```

    #### Using `param` for Evaluation
    ```python
    p = param(a=1, b=2, c=&#39;${a} + ${b} # evaluate me if you can&#39;)
    p.eval()
    # Output:
    # --------
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b} # evaluate me if you can (= 3)
    # --------
    ```

    ---

    ### Concatenation and Subtraction
    Fields from the right-most structure overwrite existing values.
    ```python
    a = struct(a=1, b=2)
    b = struct(c=3, d=&#34;d&#34;, e=&#34;e&#34;)
    c = a + b
    e = c - a
    ```

    ---

    ### Practical Shorthands

    #### Constructing a Structure from Keys
    ```python
    s = struct.fromkeys([&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;])
    # Output:
    # --------
    #      a: None
    #      b: None
    #      c: None
    #      d: None
    # --------
    ```

    #### Building a Structure from Variables in a String
    ```python
    s = struct.scan(&#34;${a} + ${b} * ${c} / ${d} --- ${ee}&#34;)
    s.a = 1
    s.b = &#34;test&#34;
    s.c = [1, &#34;a&#34;, 2]
    s.generator()
    # Output:
    # X = struct(
    #      a=1,
    #      b=&#34;test&#34;,
    #      c=[1, &#39;a&#39;, 2],
    #      d=None,
    #      ee=None
    # )
    ```

    #### Indexing and Iteration
    Structures can be indexed or sliced like lists.
    ```python
    c = a + b
    c[0]      # Access the first field
    c[-1]     # Access the last field
    c[:2]     # Slice the structure
    for field in c:
        print(field)
    ```

    ---

    ### Dynamic Dependency Management
    `struct` provides control over dependencies, sorting, and evaluation.

    ```python
    s = struct(d=3, e=&#34;${c} + {d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    s.sortdefinitions()
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}
    #      e: ${c} + ${d}
    # --------
    ```

    For dynamic evaluation, use `param`:
    ```python
    p = param(sortdefinitions=True, d=3, e=&#34;${c} + ${d}&#34;, c=&#39;${a} + ${b}&#39;, a=1, b=2)
    # Output:
    # --------
    #      d: 3
    #      a: 1
    #      b: 2
    #      c: ${a} + ${b}  (= 3)
    #      e: ${c} + ${d}  (= 6)
    # --------
    ```

    ---

    ### Overloaded Methods and Operators
    #### Supported Operators
    - `+`: Concatenation of two structures (`__add__`).
    - `-`: Subtraction of fields (`__sub__`).
    - `&lt;&lt;`: Import values from another structure (`__lshift__`)
    - `len()`: Number of fields (`__len__`).
    - `in`: Check for field existence (`__contains__`).

    #### Method Overview
    | Method                | Description                                             |
    |-----------------------|---------------------------------------------------------|
    | `check(default)`      | Populate fields with defaults if missing.               |
    | `clear()`             | Remove all fields.                                      |
    | `dict2struct(dico)`   | Create a structure from a dictionary.                   |
    | `disp()`              | Display the structure.                                  |
    | `eval()`              | Evaluate expressions within fields.                     |
    | `fromkeys(keys)`      | Create a structure from a list of keys.                 |
    | `generator()`         | Generate Python code representing the structure.        |
    | `importfrom()`        | Import undefined values from another struct or dict.    |
    | `items()`             | Return key-value pairs.                                 |
    | `keys()`              | Return all keys in the structure.                       |
    | `read(file)`          | Load structure fields from a file.                      |
    | `scan(string)`        | Extract variables from a string and populate fields.    |
    | `sortdefinitions()`   | Sort fields to resolve dependencies.                    |
    | `struct2dict()`       | Convert the structure to a dictionary.                  |
    | `validkeys()`         | Return valid keys                                       |
    | `values()`            | Return all field values.                                |
    | `write(file)`         | Save the structure to a file.                           |

    ---

    ### Dynamic Properties
    | Property    | Description                            |
    |-------------|----------------------------------------|
    | `isempty`   | `True` if the structure is empty.      |
    | `isdefined` | `True` if all fields are defined.      |

    ---
    &#34;&#34;&#34;

    # attributes to be overdefined
    _type = &#34;struct&#34;        # object type
    _fulltype = &#34;structure&#34; # full name
    _ftype = &#34;field&#34;        # field name
    _evalfeature = False    # true if eval() is available
    _maxdisplay = 40        # maximum number of characters to display (should be even)
    _propertyasattribute = False
    _precision = 4
    _needs_sorting = False

    # attributes for the iterator method
    # Please keep it static, duplicate the object before changing _iter_
    _iter_ = 0

    # excluded attributes (keep the , in the Tupple if it is singleton)
    _excludedattr = {&#39;_iter_&#39;,&#39;__class__&#39;,&#39;_protection&#39;,&#39;_evaluation&#39;,&#39;_returnerror&#39;,&#39;_debug&#39;,&#39;_precision&#39;,&#39;_needs_sorting&#39;} # used by keys() and len()


    # Methods
    def __init__(self,debug=False,**kwargs):
        &#34;&#34;&#34; constructor, use debug=True to report eval errors&#34;&#34;&#34;
        # Optionally extend _excludedattr here
        self._excludedattr = self._excludedattr | {&#39;_excludedattr&#39;, &#39;_type&#39;, &#39;_fulltype&#39;,&#39;_ftype&#39;} # addition 2024-10-11
        self._debug = debug
        self.set(**kwargs)

    def zip(self):
        &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
        return zip(self.keys(),self.values())

    @staticmethod
    def dict2struct(dico,makeparam=False):
        &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
        if isinstance(dico,dict):
            s = param() if makeparam else struct()
            s.set(**dico)
            return s
        raise TypeError(&#34;the argument must be a dictionary&#34;)

    def struct2dict(self):
        &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
        return dict(self.zip())

    def struct2param(self,protection=False,evaluation=True):
        &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
        p = param(**self.struct2dict())
        for i in range(len(self)):
            if isinstance(self[i],pstr): p[i] = pstr(p[i])
        p._protection = protection
        p._evaluation = evaluation
        return p

    def set(self,**kwargs):
        &#34;&#34;&#34; initialization &#34;&#34;&#34;
        self.__dict__.update(kwargs)

    def setattr(self,key,value):
        &#34;&#34;&#34; set field and value &#34;&#34;&#34;
        if isinstance(value,list) and len(value)==0 and key in self:
            delattr(self, key)
        else:
            self.__dict__[key] = value

    def getattr(self,key):
        &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
        if key in self.__dict__:
            return self.__dict__[key]
        elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
             key not in self._excludedattr and \
             key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
            # If _propertyasattribute is True and it&#39;s a property, get its value
            return self.__class__.__dict__[key].fget(self)
        else:
            raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)

    def hasattr(self, key):
        &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
        return key in self.__dict__ or (
            getattr(self, &#39;_propertyasattribute&#39;, False) and
            key not in self._excludedattr and
            key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
        )

    def __getstate__(self):
        &#34;&#34;&#34; getstate for cooperative inheritance / duplication &#34;&#34;&#34;
        return self.__dict__.copy()

    def __setstate__(self,state):
        &#34;&#34;&#34; setstate for cooperative inheritance / duplication &#34;&#34;&#34;
        self.__dict__.update(state)

    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return pstr.eval(self.getattr(key))

    def __setattr__(self,key,value):
        &#34;&#34;&#34; set attribute override &#34;&#34;&#34;
        self.setattr(key,value)

    def __contains__(self,item):
        &#34;&#34;&#34; in override &#34;&#34;&#34;
        return self.hasattr(item)

    def keys(self):
        &#34;&#34;&#34; return the fields &#34;&#34;&#34;
        # keys() is used by struct() and its iterator
        return [key for key in self.__dict__.keys() if key not in self._excludedattr]

    def keyssorted(self,reverse=True):
        &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
        klist = self.keys()
        l = [len(k) for k in klist]
        return [k for _,k in sorted(zip(l,klist),reverse=reverse)]

    def values(self):
        &#34;&#34;&#34; return the values &#34;&#34;&#34;
        # values() is used by struct() and its iterator
        return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]

    @staticmethod
    def fromkeysvalues(keys,values,makeparam=False):
        &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
            use makeparam = True to create a param instead of struct
        &#34;&#34;&#34;
        if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
        if not isinstance(keys,_list_types): keys = [keys]
        if not isinstance(values,_list_types): values = [values]
        nk,nv = len(keys), len(values)
        s = param() if makeparam else struct()
        if nk&gt;0 and nv&gt;0:
            iv = 0
            for ik in range(nk):
                s.setattr(keys[ik], values[iv])
                iv = min(nv-1,iv+1)
            for ik in range(nk,nv):
                s.setattr(f&#34;key{ik}&#34;, values[ik])
        return s

    def items(self):
        &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
        return self.zip()

    def __getitem__(self,idx):
        &#34;&#34;&#34;
            s[i] returns the ith element of the structure
            s[:4] returns a structure with the four first fields
            s[[1,3]] returns the second and fourth elements
        &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                return self.getattr(self.keys()[idx])
            raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            out = struct.fromkeysvalues(self.keys()[idx], self.values()[idx])
            if isinstance(self,paramauto):
                return paramauto(**out)
            elif isinstance(self,param):
                return param(**out)
            else:
                return out
        elif isinstance(idx,(list,tuple)):
            k,v= self.keys(), self.values()
            nk = len(k)
            s = param() if isinstance(self,param) else struct()
            for i in idx:
                if isinstance(i,int):
                    if -nk &lt;= i &lt; nk:  # Allow standard Python negative indexing
                        i = i % nk  # Convert negative index to positive equivalent
                        s.setattr(k[i],v[i])
                    else:
                        raise IndexError(f&#34;idx must contain integers in range [-{nk}, {nk-1}], not {i}&#34;)
                elif isinstance(i,str):
                    if i in self:
                        s.setattr(i, self.getattr(i))
                    else:
                        raise KeyError((f&#39;idx &#34;{idx}&#34; is not a valid key&#39;))
                else:
                    TypeError(&#34;idx must contain only integers or strings&#34;)
            return s
        elif isinstance(idx,str):
            return self.getattr(idx)
        else:
            raise TypeError(&#34;The index must be an integer or a slice and not a %s&#34; % type(idx).__name__)

    def __setitem__(self,idx,value):
        &#34;&#34;&#34; set the ith element of the structure  &#34;&#34;&#34;
        if isinstance(idx,int):
            if idx&lt;len(self):
                self.setattr(self.keys()[idx], value)
            else:
                raise IndexError(f&#34;the {self._ftype} index should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,slice):
            k = self.keys()[idx]
            if len(value)&lt;=1:
                for i in range(len(k)): self.setattr(k[i], value)
            elif len(k) == len(value):
                for i in range(len(k)): self.setattr(k[i], value[i])
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of elements in the slice (%d)&#34; \
                       % (len(value),len(idx)))
        elif isinstance(idx,(list,tuple)):
            if len(value)&lt;=1:
                for i in range(len(idx)): self[idx[i]]=value
            elif len(idx) == len(value):
                for i in range(len(idx)): self[idx[i]]=value[i]
            else:
                raise IndexError(&#34;the number of values (%d) does not match the number of indices (%d)&#34; \
                                 % (len(value),len(idx)))

    def __len__(self):
        &#34;&#34;&#34; return the number of fields &#34;&#34;&#34;
        # len() is used by struct() and its iterator
        return len(self.keys())

    def __iter__(self):
        &#34;&#34;&#34; struct iterator &#34;&#34;&#34;
        # note that in the original object _iter_ is a static property not in dup
        dup = duplicate(self)
        dup._iter_ = 0
        return dup

    def __next__(self):
        &#34;&#34;&#34; increment iterator &#34;&#34;&#34;
        self._iter_ += 1
        if self._iter_&lt;=len(self):
            return self[self._iter_-1]
        self._iter_ = 0
        raise StopIteration(f&#34;Maximum {self._ftype} iteration reached {len(self)}&#34;)

    def __add__(self, s, sortdefinitions=False, raiseerror=True, silentmode=True):
        &#34;&#34;&#34;
        Add two structure objects, with precedence as follows:

          paramauto &gt; param &gt; struct

        In c = a + b, if b has a higher precedence than a then c will be of b&#39;s class,
        otherwise it will be of a&#39;s class.

        The new instance is created by copying the fields from the left-hand operand (a)
        and then updating with the fields from the right-hand operand (b).

        If self or s is of class paramauto, the current state of _needs_sorting is propagated
        but not forced to be true.

        &#34;&#34;&#34;
        if not isinstance(s, struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)

        # Define a helper to assign a precedence value.
        def get_precedence(obj):
            if isinstance(obj, paramauto):
                return 2
            elif isinstance(obj, param):
                return 1
            elif isinstance(obj, struct):
                return 0
            else:
                return 0  # fallback for unknown derivations

        # current classes
        leftprecedence = get_precedence(self)
        rightprecedence = get_precedence(s)
        # Determine which class to use for the duplicate.
        # If s (b) has a higher precedence than self (a), use s&#39;s class; otherwise, use self&#39;s.
        hi_class = self.__class__ if leftprecedence &gt;= rightprecedence else s.__class__
        # Create a new instance of the chosen class by copying self&#39;s fields.
        dup = hi_class(**self)
        # Update with the fields from s.
        dup.update(**s)
        if sortdefinitions: # defer sorting by preserving the state of _needs_sorting
            if leftprecedence &lt; rightprecedence == 2: # left is promoted
                dup._needs_sorting = s._needs_sorting
            elif rightprecedence &lt; leftprecedence == 2: # right is promoted
                dup._needs_sorting = self._needs_sorting
            elif leftprecedence == rightprecedence == 2: # left and right are equivalent
                dup._needs_sorting = self._needs_sorting or s._needs_sorting
            # dup.sortdefinitions(raiseerror=raiseerror, silentmode=silentmode)
        return dup

    def __iadd__(self,s,sortdefinitions=False,raiseerror=False, silentmode=True):
        &#34;&#34;&#34; iadd a structure
            set sortdefintions=True to sort definitions (to maintain executability)
        &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        self.update(**s)
        if sortdefinitions:
            self._needs_sorting = True
            # self.sortdefinitions(raiseerror=raiseerror,silentmode=silentmode)
        return self

    def __sub__(self,s):
        &#34;&#34;&#34; sub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        dup = duplicate(self)
        listofkeys = dup.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(dup,k)
        return dup

    def __isub__(self,s):
        &#34;&#34;&#34; isub a structure &#34;&#34;&#34;
        if not isinstance(s,struct):
            raise TypeError(f&#34;the second operand must be {self._type}&#34;)
        listofkeys = self.keys()
        for k in s.keys():
            if k in listofkeys:
                delattr(self,k)
        return self

    def dispmax(self,content):
        &#34;&#34;&#34; optimize display &#34;&#34;&#34;
        strcontent = str(content)
        if len(strcontent)&gt;self._maxdisplay:
            nchar = round(self._maxdisplay/2)
            return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
        else:
            return content

    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        if self.__dict__=={}:
            print(f&#34;empty {self._fulltype} ({self._type} object) with no {self._type}s&#34;)
            return f&#34;empty {self._fulltype}&#34;
        else:
            numfmt = f&#34;.{self._precision}g&#34;
            tmp = self.eval() if self._evalfeature else []
            keylengths = [len(key) for key in self.__dict__]
            width = max(10,max(keylengths)+2)
            fmt = &#34;%%%ss:&#34; % width
            fmteval = fmt[:-1]+&#34;=&#34;
            fmtcls =  fmt[:-1]+&#34;:&#34;
            line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
            print(line)
            for key,value in self.__dict__.items():
                if key not in self._excludedattr:
                    if isinstance(value,_numeric_types):
                        # old code (removed on 2025-01-18)
                        # if isinstance(value,pstr):
                        #     print(fmt % key,&#39;p&#34;&#39;+self.dispmax(value)+&#39;&#34;&#39;)
                        # if isinstance(value,str) and value==&#34;&#34;:
                        #     print(fmt % key,&#39;&#34;&#34;&#39;)
                        # else:
                        #     print(fmt % key,self.dispmax(value))
                        if isinstance(value,np.ndarray):
                            print(fmt % key, struct.format_array(value,numfmt=numfmt))
                        else:
                            print(fmt % key,self.dispmax(value))
                    elif isinstance(value,struct):
                        print(fmt % key,self.dispmax(value.__str__()))
                    elif isinstance(value,(type,dict)):
                        print(fmt % key,self.dispmax(str(value)))
                    else:
                        print(fmt % key,type(value))
                        print(fmtcls % &#34;&#34;,self.dispmax(str(value)))
                    if self._evalfeature:
                        if isinstance(self,paramauto):
                            try:
                                if isinstance(value,pstr):
                                    print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                                elif isinstance(value,str):
                                    if value == &#34;&#34;:
                                        print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                    else:
                                        print(fmteval % &#34;&#34;,self.dispmax(tmp.getattr(key)))
                            except Exception as err:
                                print(fmteval % &#34;&#34;,err.message, err.args)
                        else:
                            if isinstance(value,pstr):
                                print(fmteval % &#34;&#34;,&#39;p&#34;&#39;+self.dispmax(tmp.getattr(key))+&#39;&#34;&#39;)
                            elif isinstance(value,str):
                                if value == &#34;&#34;:
                                    print(fmteval % &#34;&#34;,self.dispmax(&#34;&lt;empty string&gt;&#34;))
                                else:
                                    calcvalue =tmp.getattr(key)
                                    if isinstance(calcvalue, str) and &#34;error&#34; in calcvalue.lower():
                                        print(fmteval % &#34;&#34;,calcvalue)
                                    else:
                                        if isinstance(calcvalue,np.ndarray):
                                            print(fmteval % &#34;&#34;, struct.format_array(calcvalue,numfmt=numfmt))
                                        else:
                                            print(fmteval % &#34;&#34;,self.dispmax(calcvalue))
                            elif isinstance(value,list):
                                calcvalue =tmp.getattr(key)
                                print(fmteval % &#34;&#34;,self.dispmax(str(calcvalue)))
            print(line)
            return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    def disp(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        self.__repr__()

    def __str__(self):
        return f&#34;{self._fulltype} ({self._type} object) with {len(self)} {self._ftype}s&#34;

    @property
    def isempty(self):
        &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
        return len(self)==0

    def clear(self):
        &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
        for k in self.keys(): delattr(self,k)

    def format(self, s, escape=False, raiseerror=True):
        &#34;&#34;&#34;
            Format a string with fields using {field} as placeholders.
            Handles expressions like ${variable1}.

            Args:
                s (str): The input string to format.
                escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
                raiseerror (bool): If True, raises errors for missing fields.

            Note:
                NumPy vectors and matrices are converted into their text representation (default behavior)
                If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

            Returns:
                str: The formatted string.
        &#34;&#34;&#34;
        tmp = self.np2str()
        if raiseerror:
            try:
                if escape:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.format_map(AttrErrorDict(self.__dict__))
                else:
                    try: # we try to evaluate with all np objects converted in to strings (default)
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                    except: # if an error occurs, we use the orginal content
                        return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
            except AttributeError as attr_err:
                # Handle AttributeError for expressions with operators
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                if self._debug:
                    print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
                return s_  # Revert to using &#39;${&#39; for unresolved expressions
            except IndexError as idx_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                if self._debug:
                    print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
                raise IndexError from idx_err
            except Exception as other_err:
                s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
                raise RuntimeError from other_err
        else:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except:  # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))

    def format_legacy(self,s,escape=False,raiseerror=True):
        &#34;&#34;&#34;
            format a string with field (use {field} as placeholders)
                s.replace(string), s.replace(string,escape=True)
                where:
                    s is a struct object
                    string is a string with possibly ${variable1}
                    escape is a flag to prevent ${} replaced by {}
        &#34;&#34;&#34;
        if raiseerror:
            try:
                if escape:
                    return s.format(**self.__dict__)
                else:
                    return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
            except KeyError as kerr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
                return s_ # instead of s (we put back $) - OV 2023/01/27
            except Exception as othererr:
                s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
                raise RuntimeError from othererr
        else:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)

    def fromkeys(self,keys):
        &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
        return self+struct(**dict.fromkeys(keys,None))

    @staticmethod
    def scan(s):
        &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
        tmp = struct()
        #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
        found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
        uniq = []
        for x in found:
            if x not in uniq: uniq.append(x)
        return tmp.fromkeys(uniq)

    @staticmethod
    def isstrexpression(s):
        &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        return re.search(r&#34;\$\{.*?\}&#34;,s) is not None

    @property
    def isexpression(self):
        &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        for k,v in self.items():
            if isinstance(v,str):
                s.setattr(k,struct.isstrexpression(v))
            else:
                s.setattr(k,False)
        return s

    @staticmethod
    def isstrdefined(s,ref):
        &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
        if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        if struct.isstrexpression(s):
            k = struct.scan(s).keys()
            allfound,i,nk = True,0,len(k)
            while (i&lt;nk) and allfound:
                allfound = k[i] in ref
                i += 1
            return allfound
        else:
            return False


    def isdefined(self,ref=None):
        &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
        s = param() if isinstance(self,param) else struct()
        k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
        nk = len(k)
        if ref is None:
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
                else:
                    s.setattr(k[i],True)
        else:
            if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
            for i in range(nk):
                if isexpr[i]:
                    s.setattr(k[i],struct.isstrdefined(v[i],ref))
                else:
                    s.setattr(k[i],True)
        return s


    def sortdefinitions(self,raiseerror=True,silentmode=False):
        &#34;&#34;&#34; sortdefintions sorts all definitions
            so that they can be executed as param().
            If any inconsistency is found, an error message is generated.

            Flags = default values
                raiseerror=True show erros of True
                silentmode=False no warning if True
        &#34;&#34;&#34;
        find = lambda xlist: [i for i, x in enumerate(xlist) if x]
        findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
        k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
        istatic = findnot(isexpr)
        idynamic = find(isexpr)
        static = struct.fromkeysvalues(
            [ k[i] for i in istatic ],
            [ v[i] for i in istatic ],
            makeparam = False)
        dynamic = struct.fromkeysvalues(
            [ k[i] for i in idynamic ],
            [ v[i] for i in idynamic ],
            makeparam=False)
        current = static # make static the current structure
        nmissing, anychange, errorfound = len(dynamic), False, False
        while nmissing:
            itst, found = 0, False
            while itst&lt;nmissing and not found:
                teststruct = current + dynamic[[itst]] # add the test field
                found = all(list(teststruct.isdefined()))
                ifound = itst
                itst += 1
            if found:
                current = teststruct # we accept the new field
                dynamic[ifound] = []
                nmissing -= 1
                anychange = True
            else:
                if raiseerror:
                    raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                                   (nmissing,len(self),self._ftype))
                else:
                    if (not errorfound) and (not silentmode):
                        print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                              (nmissing,len(self),self._ftype))
                    current = teststruct # we accept the new field (even if it cannot be interpreted)
                    dynamic[ifound] = []
                    nmissing -= 1
                    errorfound = True
        if anychange:
            self.clear() # reset all fields and assign them in the proper order
            k,v = current.keys(), current.values()
            for i in range(len(k)):
                self.setattr(k[i],v[i])


    def generator(self, printout=False):
        &#34;&#34;&#34;
        Generate Python code of the equivalent structure.

        This method converts the current structure (an instance of `param`, `paramauto`, or `struct`)
        into Python code that, when executed, recreates an equivalent structure. The generated code is
        formatted with one field per line.

        By default (when `printout` is False), the generated code is returned as a raw string that starts
        directly with, for example, `param(` (or `paramauto(` or `struct(`), with no &#34;X = &#34; prefix or leading
        newline. When `printout` is True, the generated code is printed to standard output and includes a prefix
        &#34;X = &#34; to indicate the variable name.

        Parameters:
            printout (bool): If True, the generated code is printed to standard output with the &#34;X = &#34; prefix.
                             If False (default), the code is returned as a raw string starting with, e.g.,
                             `param(`.

        Returns:
            str: The generated Python code representing the structure (regardless of whether it was printed).
        &#34;&#34;&#34;
        nk = len(self)
        tmp = self.np2str()
        # Compute the field format based on the maximum key length (with a minimum width of 10)
        fmt = &#34;%%%ss =&#34; % max(10, max([len(k) for k in self.keys()]) + 2)
        # Determine the appropriate class string for the current instance.
        if isinstance(self, param):
            classstr = &#34;param&#34;
        elif &#39;paramauto&#39; in globals() and isinstance(self, paramauto):
            classstr = &#34;paramauto&#34;
        else:
            classstr = &#34;struct&#34;

        lines = []
        if nk == 0:
            # For an empty structure.
            if printout:
                lines.append(f&#34;X = {classstr}()&#34;)
            else:
                lines.append(f&#34;{classstr}()&#34;)
        else:
            # Header: include &#34;X = &#34; only if printing.
            if printout:
                header = f&#34;X = {classstr}(&#34;
            else:
                header = f&#34;{classstr}(&#34;
            lines.append(header)
            # Iterate over keys to generate each field line.
            for i, k in enumerate(self.keys()):
                v = getattr(self, k)
                if isinstance(v, np.ndarray):
                    vtmp = getattr(tmp, k)
                    field = fmt % k + &#34; &#34; + vtmp
                elif isinstance(v, (int, float)) or v is None:
                    field = fmt % k + &#34; &#34; + str(v)
                elif isinstance(v, str):
                    field = fmt % k + &#34; &#34; + f&#39;&#34;{v}&#34;&#39;
                elif isinstance(v, (list, tuple, dict)):
                    field = fmt % k + &#34; &#34; + str(v)
                else:
                    field = fmt % k + &#34; &#34; + &#34;/* unsupported type */&#34;
                # Append a comma after each field except the last one.
                if i &lt; nk - 1:
                    field += &#34;,&#34;
                lines.append(field)
            # Create a closing line that aligns the closing parenthesis.
            closing_line = fmt[:-1] % &#34;)&#34;
            lines.append(closing_line)
        result = &#34;\n&#34;.join(lines)
        if printout:
            print(result)
            return None
        return result


    # copy and deep copy methpds for the class
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, duplicatedeep(v, memo))
        return copie


    # write a file
    def write(self, file, overwrite=True, mkdir=False):
        &#34;&#34;&#34;
            write the equivalent structure (not recursive for nested struct)
                write(filename, overwrite=True, mkdir=False)

            Parameters:
            - file: The file path to write to.
            - overwrite: Whether to overwrite the file if it exists (default: True).
            - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()

        # Check if the directory exists or if mkdir is set to True, create it
        if mkdir:
            file_path.parent.mkdir(parents=True, exist_ok=True)
        elif not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If overwrite is False and the file already exists, raise an exception
        if not overwrite and file_path.exists():
            raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
        # Convert to static if needed
        if isinstance(p,(param,paramauto)):
            tmp = self.tostatic()
        else:
            tmp = self
        # Open and write to the file using the resolved path
        with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
            print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
            for k, v in tmp.items():
                if v is None:
                    print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
                elif isinstance(v, (int, float)):
                    print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
                elif isinstance(v, str):
                    print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
                else:
                    print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)


    # read a file
    @staticmethod
    def read(file):
        &#34;&#34;&#34;
            read the equivalent structure
                read(filename)

            Parameters:
            - file: The file path to read from.
        &#34;&#34;&#34;
        # Create a Path object for the file to handle cross-platform paths
        file_path = Path(file).resolve()
        # Check if the parent directory exists, otherwise raise an error
        if not file_path.parent.exists():
            raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
        # If the file does not exist, raise an exception
        if not file_path.exists():
            raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
        # Open and read the file
        with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
            s = struct()  # Assuming struct is defined elsewhere
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                expr = line.split(sep=&#34;=&#34;)
                if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                    lhs = expr[0]
                    rhs = &#34;&#34;.join(expr[1:]).strip()
                    if len(rhs) == 0 or rhs == &#34;None&#34;:
                        v = None
                    else:
                        v = eval(rhs)
                    s.setattr(lhs, v)
        return s

    # argcheck
    def check(self,default):
        &#34;&#34;&#34;
        populate fields from a default structure
            check(defaultstruct)
            missing field, None and [] values are replaced by default ones

            Note: a.check(b) is equivalent to b+a except for [] and None values
        &#34;&#34;&#34;
        if not isinstance(default,struct):
            raise TypeError(&#34;the first argument must be a structure&#34;)
        for f in default.keys():
            ref = default.getattr(f)
            if f not in self:
                self.setattr(f, ref)
            else:
                current = self.getattr(f)
                if ((current is None)  or (current==[])) and \
                    ((ref is not None) and (ref!=[])):
                        self.setattr(f, ref)


    # update values based on key:value
    def update(self, **kwargs):
        &#34;&#34;&#34;
        Update multiple fields at once, while protecting certain attributes.

        Parameters:
        -----------
        **kwargs : dict
            The fields to update and their new values.

        Protected attributes defined in _excludedattr are not updated.

        Usage:
        ------
        s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
        &#34;&#34;&#34;
        protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())
        for key, value in kwargs.items():
            if key in protected_attributes:
                print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
            else:
                self.setattr(key, value)


    # override () for subindexing structure with key names
    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extract a sub-structure based on the specified keys,
        keeping the same class type.

        Parameters:
        -----------
        *keys : str
            The keys for the fields to include in the sub-structure.

        Returns:
        --------
        struct
            A new instance of the same class as the original, containing
            only the specified keys.

        Usage:
        ------
        sub_struct = s(&#39;key1&#39;, &#39;key2&#39;, ...)
        &#34;&#34;&#34;
        # Create a new instance of the same class
        sub_struct = self.__class__()

        # Get the full type and field type for error messages
        fulltype = getattr(self, &#39;_fulltype&#39;, &#39;structure&#39;)
        ftype = getattr(self, &#39;_ftype&#39;, &#39;field&#39;)

        # Add only the specified keys to the new sub-structure
        for key in keys:
            if key in self:
                sub_struct.setattr(key, self.getattr(key))
            else:
                raise KeyError(f&#34;{fulltype} does not contain the {ftype} &#39;{key}&#39;.&#34;)

        return sub_struct


    def __delattr__(self, key):
        &#34;&#34;&#34; Delete an instance attribute if it exists and is not a class or excluded attribute. &#34;&#34;&#34;
        if key in self._excludedattr:
            raise AttributeError(f&#34;Cannot delete excluded attribute &#39;{key}&#39;&#34;)
        elif key in self.__class__.__dict__:  # Check if it&#39;s a class attribute
            raise AttributeError(f&#34;Cannot delete class attribute &#39;{key}&#39;&#34;)
        elif key in self.__dict__:  # Delete only if in instance&#39;s __dict__
            del self.__dict__[key]
        else:
            raise AttributeError(f&#34;{self._type} has no attribute &#39;{key}&#39;&#34;)


    # A la Matlab display method of vectors, matrices and ND-arrays
    @staticmethod
    def format_array(value,numfmt=&#34;.4g&#34;):
        &#34;&#34;&#34;
        Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
        Recursively formats multi-dimensional arrays without introducing unwanted commas.

        Args:
            value (np.ndarray): The NumPy array to format.
            numfmt: numeric format to be used for the string conversion (default=&#34;.4g&#34;)

        Returns:
            str: A formatted string representation of the array.
        &#34;&#34;&#34;
        dtype_str = {
            np.float64: &#34;double&#34;,
            np.float32: &#34;single&#34;,
            np.int32: &#34;int32&#34;,
            np.int64: &#34;int64&#34;,
            np.complex64: &#34;complex single&#34;,
            np.complex128: &#34;complex double&#34;,
        }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

        max_display = 10  # Maximum number of elements to display

        def format_recursive(arr):
            &#34;&#34;&#34;
            Recursively formats the array based on its dimensions.

            Args:
                arr (np.ndarray): The array or sub-array to format.

            Returns:
                str: Formatted string of the array.
            &#34;&#34;&#34;
            if arr.ndim == 0:
                return f&#34;{arr.item()}&#34;

            if arr.ndim == 1:
                if len(arr) &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr) + &#34;]&#34;
                else:
                    return f&#34;[{len(arr)} elements]&#34;

            if arr.ndim == 2:
                if arr.shape[1] == 1:
                    # Column vector
                    if arr.shape[0] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in arr) + &#34;]T&#34;
                    else:
                        return f&#34;[{arr.shape[0]}×1 vector]&#34;
                elif arr.shape[0] == 1:
                    # Row vector
                    if arr.shape[1] &lt;= max_display:
                        return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr[0]) + &#34;]&#34;
                    else:
                        return f&#34;[1×{arr.shape[1]} vector]&#34;
                else:
                    # General matrix
                    return f&#34;[{arr.shape[0]}×{arr.shape[1]} matrix]&#34;

            # For higher dimensions
            shape_str = &#34;×&#34;.join(map(str, arr.shape))
            if arr.size &lt;= max_display:
                # Show full content
                if arr.ndim &gt; 2:
                    # Represent multi-dimensional arrays with nested brackets
                    return &#34;[&#34; + &#34; &#34;.join(format_recursive(subarr) for subarr in arr) + f&#34;] ({shape_str} {dtype_str})&#34;
            return f&#34;[{shape_str} array ({dtype_str})]&#34;

        if value.size == 0:
            return &#34;[]&#34;

        if value.ndim == 0 or value.size == 1:
            return f&#34;{value.item()} ({dtype_str})&#34;

        if value.ndim == 1 or value.ndim == 2:
            # Use existing logic for vectors and matrices
            if value.ndim == 1:
                if len(value) &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{len(value)}×1 {dtype_str}]&#34;
            elif value.ndim == 2:
                rows, cols = value.shape
                if cols == 1:  # Column vector
                    if rows &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[{rows}×1 {dtype_str}]&#34;
                elif rows == 1:  # Row vector
                    if cols &lt;= max_display:
                        formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                    else:
                        formatted = f&#34;[1×{cols} {dtype_str}]&#34;
                else:  # General matrix
                    formatted = f&#34;[{rows}×{cols} {dtype_str}]&#34;
            return formatted

        # For higher-dimensional arrays
        if value.size &lt;= max_display:
            formatted = format_recursive(value)
        else:
            shape_str = &#34;×&#34;.join(map(str, value.shape))
            formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

        return formatted


    # convert all NumPy entries to &#34;nestable&#34; expressions
    def np2str(self):
        &#34;&#34;&#34; Convert all NumPy entries of s into their string representations, handling both lists and dictionaries. &#34;&#34;&#34;
        out = struct()
        def format_numpy_result(value):
            &#34;&#34;&#34;
            Converts a NumPy array or scalar into a string representation:
            - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
            - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
            - If the value is a list or dict, the conversion is applied recursively.
            - Non-ndarray inputs that are not list/dict are returned without modification.

            Args:
                value (np.ndarray, scalar, list, dict, or other): The value to format.

            Returns:
                str, list, dict, or original type: A properly formatted string for NumPy arrays/scalars,
                a recursively converted list/dict, or the original value.
            &#34;&#34;&#34;
            if isinstance(value, dict):
                # Recursively process each key in the dictionary.
                new_dict = {}
                for k, v in value.items():
                    new_dict[k] = format_numpy_result(v)
                return new_dict
            elif isinstance(value, list):
                # Recursively process each element in the list.
                return [format_numpy_result(x) for x in value]
            elif isinstance(value, tuple):
                return tuple(format_numpy_result(x) for x in value)
            elif isinstance(value, struct):
                return value.npstr()
            elif np.isscalar(value):
                # For scalars: if numeric, use str() to avoid extra quotes.
                if isinstance(value, (int, float, complex, str)) or value is None:
                    return value
                else:
                    return repr(value)
            elif isinstance(value, np.ndarray):
                # Check if the array has exactly one element.
                if value.size == 1:
                    # Extract the scalar value.
                    return repr(value.item())
                # Convert the array to a nested list.
                nested_list = value.tolist()
                # Recursively format the nested list into a valid string.
                def list_to_string(lst):
                    if isinstance(lst, list):
                        return &#34;[&#34; + &#34;,&#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                    else:
                        return repr(lst)
                return list_to_string(nested_list)
            else:
                # Return the input unmodified if not a NumPy array, list, dict, or scalar.
                return str(value) # str() preferred over repr() for concision
        # Process all entries in self.
        for key, value in self.items():
            out.setattr(key, format_numpy_result(value))
        return out

    # minimal replacement of placeholders by numbers or their string representations
    def numrepl(self, text):
        r&#34;&#34;&#34;
        Replace all placeholders of the form ${key} in the given text by the corresponding
        numeric value from the instance fields, under the following conditions:

        1. &#39;key&#39; must be a valid field in self (i.e., if key in self).
        2. The value corresponding to &#39;key&#39; is either:
             - an int,
             - a float, or
             - a string that represents a valid number (e.g., &#34;1&#34; or &#34;1.0&#34;).

        Only when these conditions are met, the placeholder is substituted.
        The conversion preserves the original type: if the stored value is int, then the
        substitution will be done as an integer (e.g., 1 and not 1.0). Otherwise, if it is
        a float then it will be substituted as a float.

        Any placeholder for which the above conditions are not met remains unchanged.

        Placeholders are recognized by the pattern &#34;${&lt;key&gt;}&#34; where &lt;key&gt; is captured as all
        text until the next &#34;}&#34; (optionally allowing whitespace inside the braces).
        &#34;&#34;&#34;
        # Pattern: match &#34;${&#34;, then optional whitespace, capture all characters until &#34;}&#34;,
        # then optional whitespace, then &#34;}&#34;.
        placeholder_pattern = re.compile(r&#34;\$\{\s*([^}]+?)\s*\}&#34;)

        def replace_match(match):
            key = match.group(1)
            # Check if the key exists in self.
            if key in self:
                value = self[key]
                # If the value is already numeric, substitute directly.
                if isinstance(value, (int, float)):
                    return str(value)
                # If the value is a string, try to interpret it as a numeric value.
                elif isinstance(value, str):
                    s = value.strip()
                    # Check if s is a valid integer representation.
                    if re.fullmatch(r&#34;[+-]?\d+&#34;, s):
                        try:
                            num = int(s)
                            return str(num)
                        except ValueError:
                            # Should not occur because the regex already matched.
                            return match.group(0)
                    # Check if s is a valid float representation (including scientific notation).
                    elif re.fullmatch(r&#34;[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?&#34;, s):
                        try:
                            num = float(s)
                            return str(num)
                        except ValueError:
                            return match.group(0)
            # If key not in self or value is not numeric (or numeric string), leave placeholder intact.
            return match.group(0)

        # Replace all placeholders in the text using the replacer function.
        return placeholder_pattern.sub(replace_match, text)

    # import method
    def importfrom(self, s, nonempty=True, replacedefaultvar=True):
        &#34;&#34;&#34;
        Import values from &#39;s&#39; into self according to the following rules:

        - Only fields that already exist in self are considered.
        - If s is a dictionary, it is converted to a struct via struct(**s).
        - If the current value of a field in self is empty (None, &#34;&#34;, [] or ()),
          then that field is updated from s.
        - If nonempty is True (default), then only non-empty values from s are imported.
        - If replacedefaultvar is True (default), then if a field in self exactly equals
          &#34;${key}&#34; (with key being the field name), it is replaced by the corresponding
          value from s if it is empty.
        - Raises a TypeError if s is not a dict or struct (i.e. if it doesn’t support keys()).
        &#34;&#34;&#34;
        # If s is a dictionary, convert it to a struct instance.
        if isinstance(s, dict):
            s = struct(**s)
        elif not hasattr(s, &#34;keys&#34;):
            raise TypeError(f&#34;s must be a struct or a dictionary not a type {type(s).__name__}&#34;)

        for key in self.keys():
            if key in s:
                s_value = getattr(s, key)
                current_value = getattr(self, key)
                if is_empty(current_value) or (replacedefaultvar and current_value == &#34;${&#34; + key + &#34;}&#34;):
                    if nonempty:
                        if not is_empty(s_value):
                            setattr(self, key, s_value)
                    else:
                        setattr(self, key, s_value)

    # importfrom with copy
    def __lshift__(self, other):
        &#34;&#34;&#34;
        Allows the syntax:

            s = s1 &lt;&lt; s2

        where a new instance is created as a copy of s1 (preserving its type, whether
        struct, param, or paramauto) and then updated with the values from s2 using
        importfrom.
        &#34;&#34;&#34;
        # Create a new instance preserving the type of self.
        new_instance = type(self)(**{k: getattr(self, k) for k in self.keys()})
        # Import values from other (s2) into the new instance.
        new_instance.importfrom(other)
        return new_instance

    # returns only valid keys
    def validkeys(self, list_of_keys):
        &#34;&#34;&#34;
        Validate and return the subset of keys from the provided list that are valid in the instance.

        Parameters:
        -----------
        list_of_keys : list
            A list of keys (as strings) to check against the instance’s attributes.

        Returns:
        --------
        list
            A list of keys from list_of_keys that are valid (i.e., exist as attributes in the instance).

        Raises:
        -------
        TypeError
            If list_of_keys is not a list or if any element in list_of_keys is not a string.

        Example:
        --------
        &gt;&gt;&gt; s = struct()
        &gt;&gt;&gt; s.foo = 42
        &gt;&gt;&gt; s.bar = &#34;hello&#34;
        &gt;&gt;&gt; valid = s.validkeys([&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;])
        &gt;&gt;&gt; print(valid)   # Output: [&#39;foo&#39;, &#39;bar&#39;] assuming &#39;baz&#39; is not defined in s
        &#34;&#34;&#34;
        # Check that list_of_keys is a list
        if not isinstance(list_of_keys, list):
            raise TypeError(&#34;list_of_keys must be a list&#34;)

        # Check that every entry in the list is a string
        for key in list_of_keys:
            if not isinstance(key, str):
                raise TypeError(&#34;Each key in list_of_keys must be a string&#34;)

        # Assuming valid keys are those present in the instance&#39;s __dict__
        return [key for key in list_of_keys if key in self]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mstruct.param" href="#mstruct.param">param</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="mstruct.struct.dict2struct"><code class="name flex">
<span>def <span class="ident">dict2struct</span></span>(<span>dico, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>create a structure from a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def dict2struct(dico,makeparam=False):
    &#34;&#34;&#34; create a structure from a dictionary &#34;&#34;&#34;
    if isinstance(dico,dict):
        s = param() if makeparam else struct()
        s.set(**dico)
        return s
    raise TypeError(&#34;the argument must be a dictionary&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.format_array"><code class="name flex">
<span>def <span class="ident">format_array</span></span>(<span>value, numfmt='.4g')</span>
</code></dt>
<dd>
<div class="desc"><p>Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
Recursively formats multi-dimensional arrays without introducing unwanted commas.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The NumPy array to format.</dd>
<dt><strong><code>numfmt</code></strong></dt>
<dd>numeric format to be used for the string conversion (default=".4g")</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representation of the array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def format_array(value,numfmt=&#34;.4g&#34;):
    &#34;&#34;&#34;
    Format NumPy array for display with distinctions for scalars, row/column vectors, and ND arrays.
    Recursively formats multi-dimensional arrays without introducing unwanted commas.

    Args:
        value (np.ndarray): The NumPy array to format.
        numfmt: numeric format to be used for the string conversion (default=&#34;.4g&#34;)

    Returns:
        str: A formatted string representation of the array.
    &#34;&#34;&#34;
    dtype_str = {
        np.float64: &#34;double&#34;,
        np.float32: &#34;single&#34;,
        np.int32: &#34;int32&#34;,
        np.int64: &#34;int64&#34;,
        np.complex64: &#34;complex single&#34;,
        np.complex128: &#34;complex double&#34;,
    }.get(value.dtype.type, str(value.dtype))  # Default to dtype name if not in the map

    max_display = 10  # Maximum number of elements to display

    def format_recursive(arr):
        &#34;&#34;&#34;
        Recursively formats the array based on its dimensions.

        Args:
            arr (np.ndarray): The array or sub-array to format.

        Returns:
            str: Formatted string of the array.
        &#34;&#34;&#34;
        if arr.ndim == 0:
            return f&#34;{arr.item()}&#34;

        if arr.ndim == 1:
            if len(arr) &lt;= max_display:
                return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr) + &#34;]&#34;
            else:
                return f&#34;[{len(arr)} elements]&#34;

        if arr.ndim == 2:
            if arr.shape[1] == 1:
                # Column vector
                if arr.shape[0] &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in arr) + &#34;]T&#34;
                else:
                    return f&#34;[{arr.shape[0]}×1 vector]&#34;
            elif arr.shape[0] == 1:
                # Row vector
                if arr.shape[1] &lt;= max_display:
                    return &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in arr[0]) + &#34;]&#34;
                else:
                    return f&#34;[1×{arr.shape[1]} vector]&#34;
            else:
                # General matrix
                return f&#34;[{arr.shape[0]}×{arr.shape[1]} matrix]&#34;

        # For higher dimensions
        shape_str = &#34;×&#34;.join(map(str, arr.shape))
        if arr.size &lt;= max_display:
            # Show full content
            if arr.ndim &gt; 2:
                # Represent multi-dimensional arrays with nested brackets
                return &#34;[&#34; + &#34; &#34;.join(format_recursive(subarr) for subarr in arr) + f&#34;] ({shape_str} {dtype_str})&#34;
        return f&#34;[{shape_str} array ({dtype_str})]&#34;

    if value.size == 0:
        return &#34;[]&#34;

    if value.ndim == 0 or value.size == 1:
        return f&#34;{value.item()} ({dtype_str})&#34;

    if value.ndim == 1 or value.ndim == 2:
        # Use existing logic for vectors and matrices
        if value.ndim == 1:
            if len(value) &lt;= max_display:
                formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value) + f&#34;] ({dtype_str})&#34;
            else:
                formatted = f&#34;[{len(value)}×1 {dtype_str}]&#34;
        elif value.ndim == 2:
            rows, cols = value.shape
            if cols == 1:  # Column vector
                if rows &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v[0]:{numfmt}}&#34; for v in value) + f&#34;]T ({dtype_str})&#34;
                else:
                    formatted = f&#34;[{rows}×1 {dtype_str}]&#34;
            elif rows == 1:  # Row vector
                if cols &lt;= max_display:
                    formatted = &#34;[&#34; + &#34; &#34;.join(f&#34;{v:{numfmt}}&#34; for v in value[0]) + f&#34;] ({dtype_str})&#34;
                else:
                    formatted = f&#34;[1×{cols} {dtype_str}]&#34;
            else:  # General matrix
                formatted = f&#34;[{rows}×{cols} {dtype_str}]&#34;
        return formatted

    # For higher-dimensional arrays
    if value.size &lt;= max_display:
        formatted = format_recursive(value)
    else:
        shape_str = &#34;×&#34;.join(map(str, value.shape))
        formatted = f&#34;[{shape_str} array ({dtype_str})]&#34;

    return formatted</code></pre>
</details>
</dd>
<dt id="mstruct.struct.fromkeysvalues"><code class="name flex">
<span>def <span class="ident">fromkeysvalues</span></span>(<span>keys, values, makeparam=False)</span>
</code></dt>
<dd>
<div class="desc"><p>struct.keysvalues(keys,values) creates a structure from keys and values
use makeparam = True to create a param instead of struct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fromkeysvalues(keys,values,makeparam=False):
    &#34;&#34;&#34; struct.keysvalues(keys,values) creates a structure from keys and values
        use makeparam = True to create a param instead of struct
    &#34;&#34;&#34;
    if keys is None: raise AttributeError(&#34;the keys must not empty&#34;)
    if not isinstance(keys,_list_types): keys = [keys]
    if not isinstance(values,_list_types): values = [values]
    nk,nv = len(keys), len(values)
    s = param() if makeparam else struct()
    if nk&gt;0 and nv&gt;0:
        iv = 0
        for ik in range(nk):
            s.setattr(keys[ik], values[iv])
            iv = min(nv-1,iv+1)
        for ik in range(nk,nv):
            s.setattr(f&#34;key{ik}&#34;, values[ik])
    return s</code></pre>
</details>
</dd>
<dt id="mstruct.struct.isstrdefined"><code class="name flex">
<span>def <span class="ident">isstrdefined</span></span>(<span>s, ref)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrdefined(string,ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrdefined(s,ref):
    &#34;&#34;&#34; isstrdefined(string,ref) returns true if it is defined in ref  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
    if struct.isstrexpression(s):
        k = struct.scan(s).keys()
        allfound,i,nk = True,0,len(k)
        while (i&lt;nk) and allfound:
            allfound = k[i] in ref
            i += 1
        return allfound
    else:
        return False</code></pre>
</details>
</dd>
<dt id="mstruct.struct.isstrexpression"><code class="name flex">
<span>def <span class="ident">isstrexpression</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>isstrexpression(string) returns true if s contains an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isstrexpression(s):
    &#34;&#34;&#34; isstrexpression(string) returns true if s contains an expression  &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;s must a string&#34;)
    return re.search(r&#34;\$\{.*?\}&#34;,s) is not None</code></pre>
</details>
</dd>
<dt id="mstruct.struct.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>read the equivalent structure
read(filename)</p>
<p>Parameters:
- file: The file path to read from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def read(file):
    &#34;&#34;&#34;
        read the equivalent structure
            read(filename)

        Parameters:
        - file: The file path to read from.
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()
    # Check if the parent directory exists, otherwise raise an error
    if not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If the file does not exist, raise an exception
    if not file_path.exists():
        raise FileNotFoundError(f&#34;The file {file_path} does not exist.&#34;)
    # Open and read the file
    with file_path.open(mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
        s = struct()  # Assuming struct is defined elsewhere
        while True:
            line = f.readline()
            if not line:
                break
            line = line.strip()
            expr = line.split(sep=&#34;=&#34;)
            if len(line) &gt; 0 and line[0] != &#34;#&#34; and len(expr) &gt; 0:
                lhs = expr[0]
                rhs = &#34;&#34;.join(expr[1:]).strip()
                if len(rhs) == 0 or rhs == &#34;None&#34;:
                    v = None
                else:
                    v = eval(rhs)
                s.setattr(lhs, v)
    return s</code></pre>
</details>
</dd>
<dt id="mstruct.struct.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>scan(string) scan a string for variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def scan(s):
    &#34;&#34;&#34; scan(string) scan a string for variables &#34;&#34;&#34;
    if not isinstance(s,str): raise TypeError(&#34;scan() requires a string&#34;)
    tmp = struct()
    #return tmp.fromkeys(set(re.findall(r&#34;\$\{(.*?)\}&#34;,s)))
    found = re.findall(r&#34;\$\{(.*?)\}&#34;,s);
    uniq = []
    for x in found:
        if x not in uniq: uniq.append(x)
    return tmp.fromkeys(uniq)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="mstruct.struct.isempty"><code class="name">var <span class="ident">isempty</span></code></dt>
<dd>
<div class="desc"><p>isempty is set to True for an empty structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isempty(self):
    &#34;&#34;&#34; isempty is set to True for an empty structure &#34;&#34;&#34;
    return len(self)==0</code></pre>
</details>
</dd>
<dt id="mstruct.struct.isexpression"><code class="name">var <span class="ident">isexpression</span></code></dt>
<dd>
<div class="desc"><p>same structure with True if it is an expression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isexpression(self):
    &#34;&#34;&#34; same structure with True if it is an expression &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    for k,v in self.items():
        if isinstance(v,str):
            s.setattr(k,struct.isstrexpression(v))
        else:
            s.setattr(k,False)
    return s</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mstruct.struct.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, default)</span>
</code></dt>
<dd>
<div class="desc"><p>populate fields from a default structure
check(defaultstruct)
missing field, None and [] values are replaced by default ones</p>
<pre><code>Note: a.check(b) is equivalent to b+a except for [] and None values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(self,default):
    &#34;&#34;&#34;
    populate fields from a default structure
        check(defaultstruct)
        missing field, None and [] values are replaced by default ones

        Note: a.check(b) is equivalent to b+a except for [] and None values
    &#34;&#34;&#34;
    if not isinstance(default,struct):
        raise TypeError(&#34;the first argument must be a structure&#34;)
    for f in default.keys():
        ref = default.getattr(f)
        if f not in self:
            self.setattr(f, ref)
        else:
            current = self.getattr(f)
            if ((current is None)  or (current==[])) and \
                ((ref is not None) and (ref!=[])):
                    self.setattr(f, ref)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear() delete all fields while preserving the original class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34; clear() delete all fields while preserving the original class &#34;&#34;&#34;
    for k in self.keys(): delattr(self,k)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.disp"><code class="name flex">
<span>def <span class="ident">disp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>display method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disp(self):
    &#34;&#34;&#34; display method &#34;&#34;&#34;
    self.__repr__()</code></pre>
</details>
</dd>
<dt id="mstruct.struct.dispmax"><code class="name flex">
<span>def <span class="ident">dispmax</span></span>(<span>self, content)</span>
</code></dt>
<dd>
<div class="desc"><p>optimize display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dispmax(self,content):
    &#34;&#34;&#34; optimize display &#34;&#34;&#34;
    strcontent = str(content)
    if len(strcontent)&gt;self._maxdisplay:
        nchar = round(self._maxdisplay/2)
        return strcontent[:nchar]+&#34; [...] &#34;+strcontent[-nchar:]
    else:
        return content</code></pre>
</details>
</dd>
<dt id="mstruct.struct.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Format a string with fields using {field} as placeholders.
Handles expressions like ${variable1}.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>The input string to format.</dd>
<dt><strong><code>escape</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, prevents replacing '${' with '{'.</dd>
<dt><strong><code>raiseerror</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, raises errors for missing fields.</dd>
</dl>
<h2 id="note">Note</h2>
<p>NumPy vectors and matrices are converted into their text representation (default behavior)
If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The formatted string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, s, escape=False, raiseerror=True):
    &#34;&#34;&#34;
        Format a string with fields using {field} as placeholders.
        Handles expressions like ${variable1}.

        Args:
            s (str): The input string to format.
            escape (bool): If True, prevents replacing &#39;${&#39; with &#39;{&#39;.
            raiseerror (bool): If True, raises errors for missing fields.

        Note:
            NumPy vectors and matrices are converted into their text representation (default behavior)
            If expressions such ${var[1,2]} are used an error is expected, the original content will be used instead

        Returns:
            str: The formatted string.
    &#34;&#34;&#34;
    tmp = self.np2str()
    if raiseerror:
        try:
            if escape:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.format_map(AttrErrorDict(self.__dict__))
            else:
                try: # we try to evaluate with all np objects converted in to strings (default)
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
                except: # if an error occurs, we use the orginal content
                    return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))
        except AttributeError as attr_err:
            # Handle AttributeError for expressions with operators
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            if self._debug:
                print(f&#34;WARNING: the {self._ftype} {attr_err} is undefined in &#39;{s_}&#39;&#34;)
            return s_  # Revert to using &#39;${&#39; for unresolved expressions
        except IndexError as idx_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            if self._debug:
                print(f&#34;Index Error {idx_err} in &#39;{s_}&#39;&#34;)
            raise IndexError from idx_err
        except Exception as other_err:
            s_ = s.replace(&#34;{&#34;, &#34;${&#34;)
            raise RuntimeError from other_err
    else:
        if escape:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.format_map(AttrErrorDict(tmp.__dict__))
            except: # if an error occurs, we use the orginal content
                return s.format_map(AttrErrorDict(self.__dict__))
        else:
            try: # we try to evaluate with all np objects converted in to strings (default)
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(tmp.__dict__))
            except:  # if an error occurs, we use the orginal content
                return s.replace(&#34;${&#34;, &#34;{&#34;).format_map(AttrErrorDict(self.__dict__))</code></pre>
</details>
</dd>
<dt id="mstruct.struct.format_legacy"><code class="name flex">
<span>def <span class="ident">format_legacy</span></span>(<span>self, s, escape=False, raiseerror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>format a string with field (use {field} as placeholders)
s.replace(string), s.replace(string,escape=True)
where:
s is a struct object
string is a string with possibly ${variable1}
escape is a flag to prevent ${} replaced by {}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_legacy(self,s,escape=False,raiseerror=True):
    &#34;&#34;&#34;
        format a string with field (use {field} as placeholders)
            s.replace(string), s.replace(string,escape=True)
            where:
                s is a struct object
                string is a string with possibly ${variable1}
                escape is a flag to prevent ${} replaced by {}
    &#34;&#34;&#34;
    if raiseerror:
        try:
            if escape:
                return s.format(**self.__dict__)
            else:
                return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)
        except KeyError as kerr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            print(f&#34;WARNING: the {self._ftype} {kerr} is undefined in &#39;{s_}&#39;&#34;)
            return s_ # instead of s (we put back $) - OV 2023/01/27
        except Exception as othererr:
            s_ = s.replace(&#34;{&#34;,&#34;${&#34;)
            raise RuntimeError from othererr
    else:
        if escape:
            return s.format(**self.__dict__)
        else:
            return s.replace(&#34;${&#34;,&#34;{&#34;).format(**self.__dict__)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.fromkeys"><code class="name flex">
<span>def <span class="ident">fromkeys</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a structure from keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromkeys(self,keys):
    &#34;&#34;&#34; returns a structure from keys &#34;&#34;&#34;
    return self+struct(**dict.fromkeys(keys,None))</code></pre>
</details>
</dd>
<dt id="mstruct.struct.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self, printout=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Python code of the equivalent structure.</p>
<p>This method converts the current structure (an instance of <code><a title="mstruct.param" href="#mstruct.param">param</a></code>, <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code>, or <code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code>)
into Python code that, when executed, recreates an equivalent structure. The generated code is
formatted with one field per line.</p>
<p>By default (when <code>printout</code> is False), the generated code is returned as a raw string that starts
directly with, for example, <code><a title="mstruct.param" href="#mstruct.param">param</a>(</code> (or <code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a>(</code> or <code><a title="mstruct.struct" href="#mstruct.struct">struct</a>(</code>), with no "X = " prefix or leading
newline. When <code>printout</code> is True, the generated code is printed to standard output and includes a prefix
"X = " to indicate the variable name.</p>
<h2 id="parameters">Parameters</h2>
<p>printout (bool): If True, the generated code is printed to standard output with the "X = " prefix.
If False (default), the code is returned as a raw string starting with, e.g.,
<code><a title="mstruct.param" href="#mstruct.param">param</a>(</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated Python code representing the structure (regardless of whether it was printed).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self, printout=False):
    &#34;&#34;&#34;
    Generate Python code of the equivalent structure.

    This method converts the current structure (an instance of `param`, `paramauto`, or `struct`)
    into Python code that, when executed, recreates an equivalent structure. The generated code is
    formatted with one field per line.

    By default (when `printout` is False), the generated code is returned as a raw string that starts
    directly with, for example, `param(` (or `paramauto(` or `struct(`), with no &#34;X = &#34; prefix or leading
    newline. When `printout` is True, the generated code is printed to standard output and includes a prefix
    &#34;X = &#34; to indicate the variable name.

    Parameters:
        printout (bool): If True, the generated code is printed to standard output with the &#34;X = &#34; prefix.
                         If False (default), the code is returned as a raw string starting with, e.g.,
                         `param(`.

    Returns:
        str: The generated Python code representing the structure (regardless of whether it was printed).
    &#34;&#34;&#34;
    nk = len(self)
    tmp = self.np2str()
    # Compute the field format based on the maximum key length (with a minimum width of 10)
    fmt = &#34;%%%ss =&#34; % max(10, max([len(k) for k in self.keys()]) + 2)
    # Determine the appropriate class string for the current instance.
    if isinstance(self, param):
        classstr = &#34;param&#34;
    elif &#39;paramauto&#39; in globals() and isinstance(self, paramauto):
        classstr = &#34;paramauto&#34;
    else:
        classstr = &#34;struct&#34;

    lines = []
    if nk == 0:
        # For an empty structure.
        if printout:
            lines.append(f&#34;X = {classstr}()&#34;)
        else:
            lines.append(f&#34;{classstr}()&#34;)
    else:
        # Header: include &#34;X = &#34; only if printing.
        if printout:
            header = f&#34;X = {classstr}(&#34;
        else:
            header = f&#34;{classstr}(&#34;
        lines.append(header)
        # Iterate over keys to generate each field line.
        for i, k in enumerate(self.keys()):
            v = getattr(self, k)
            if isinstance(v, np.ndarray):
                vtmp = getattr(tmp, k)
                field = fmt % k + &#34; &#34; + vtmp
            elif isinstance(v, (int, float)) or v is None:
                field = fmt % k + &#34; &#34; + str(v)
            elif isinstance(v, str):
                field = fmt % k + &#34; &#34; + f&#39;&#34;{v}&#34;&#39;
            elif isinstance(v, (list, tuple, dict)):
                field = fmt % k + &#34; &#34; + str(v)
            else:
                field = fmt % k + &#34; &#34; + &#34;/* unsupported type */&#34;
            # Append a comma after each field except the last one.
            if i &lt; nk - 1:
                field += &#34;,&#34;
            lines.append(field)
        # Create a closing line that aligns the closing parenthesis.
        closing_line = fmt[:-1] % &#34;)&#34;
        lines.append(closing_line)
    result = &#34;\n&#34;.join(lines)
    if printout:
        print(result)
        return None
    return result</code></pre>
</details>
</dd>
<dt id="mstruct.struct.getattr"><code class="name flex">
<span>def <span class="ident">getattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get attribute override to access both instance attributes and properties if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getattr(self,key):
    &#34;&#34;&#34;Get attribute override to access both instance attributes and properties if allowed.&#34;&#34;&#34;
    if key in self.__dict__:
        return self.__dict__[key]
    elif getattr(self, &#39;_propertyasattribute&#39;, False) and \
         key not in self._excludedattr and \
         key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property):
        # If _propertyasattribute is True and it&#39;s a property, get its value
        return self.__class__.__dict__[key].fget(self)
    else:
        raise AttributeError(f&#39;the {self._ftype} &#34;{key}&#34; does not exist&#39;)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.hasattr"><code class="name flex">
<span>def <span class="ident">hasattr</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the field exists, considering properties as regular attributes if allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasattr(self, key):
    &#34;&#34;&#34;Return true if the field exists, considering properties as regular attributes if allowed.&#34;&#34;&#34;
    return key in self.__dict__ or (
        getattr(self, &#39;_propertyasattribute&#39;, False) and
        key not in self._excludedattr and
        key in self.__class__.__dict__ and isinstance(self.__class__.__dict__[key], property)
    )</code></pre>
</details>
</dd>
<dt id="mstruct.struct.importfrom"><code class="name flex">
<span>def <span class="ident">importfrom</span></span>(<span>self, s, nonempty=True, replacedefaultvar=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Import values from 's' into self according to the following rules:</p>
<ul>
<li>Only fields that already exist in self are considered.</li>
<li>If s is a dictionary, it is converted to a struct via struct(**s).</li>
<li>If the current value of a field in self is empty (None, "", [] or ()),
then that field is updated from s.</li>
<li>If nonempty is True (default), then only non-empty values from s are imported.</li>
<li>If replacedefaultvar is True (default), then if a field in self exactly equals
"${key}" (with key being the field name), it is replaced by the corresponding
value from s if it is empty.</li>
<li>Raises a TypeError if s is not a dict or struct (i.e. if it doesn’t support keys()).</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importfrom(self, s, nonempty=True, replacedefaultvar=True):
    &#34;&#34;&#34;
    Import values from &#39;s&#39; into self according to the following rules:

    - Only fields that already exist in self are considered.
    - If s is a dictionary, it is converted to a struct via struct(**s).
    - If the current value of a field in self is empty (None, &#34;&#34;, [] or ()),
      then that field is updated from s.
    - If nonempty is True (default), then only non-empty values from s are imported.
    - If replacedefaultvar is True (default), then if a field in self exactly equals
      &#34;${key}&#34; (with key being the field name), it is replaced by the corresponding
      value from s if it is empty.
    - Raises a TypeError if s is not a dict or struct (i.e. if it doesn’t support keys()).
    &#34;&#34;&#34;
    # If s is a dictionary, convert it to a struct instance.
    if isinstance(s, dict):
        s = struct(**s)
    elif not hasattr(s, &#34;keys&#34;):
        raise TypeError(f&#34;s must be a struct or a dictionary not a type {type(s).__name__}&#34;)

    for key in self.keys():
        if key in s:
            s_value = getattr(s, key)
            current_value = getattr(self, key)
            if is_empty(current_value) or (replacedefaultvar and current_value == &#34;${&#34; + key + &#34;}&#34;):
                if nonempty:
                    if not is_empty(s_value):
                        setattr(self, key, s_value)
                else:
                    setattr(self, key, s_value)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.isdefined"><code class="name flex">
<span>def <span class="ident">isdefined</span></span>(<span>self, ref=None)</span>
</code></dt>
<dd>
<div class="desc"><p>isdefined(ref) returns true if it is defined in ref</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdefined(self,ref=None):
    &#34;&#34;&#34; isdefined(ref) returns true if it is defined in ref &#34;&#34;&#34;
    s = param() if isinstance(self,param) else struct()
    k,v,isexpr = self.keys(), self.values(), self.isexpression.values()
    nk = len(k)
    if ref is None:
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],self[:i]))
            else:
                s.setattr(k[i],True)
    else:
        if not isinstance(ref,struct): raise TypeError(&#34;ref must be a structure&#34;)
        for i in range(nk):
            if isexpr[i]:
                s.setattr(k[i],struct.isstrdefined(v[i],ref))
            else:
                s.setattr(k[i],True)
    return s</code></pre>
</details>
</dd>
<dt id="mstruct.struct.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return all elements as iterable key, value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34; return all elements as iterable key, value &#34;&#34;&#34;
    return self.zip()</code></pre>
</details>
</dd>
<dt id="mstruct.struct.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the fields</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34; return the fields &#34;&#34;&#34;
    # keys() is used by struct() and its iterator
    return [key for key in self.__dict__.keys() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="mstruct.struct.keyssorted"><code class="name flex">
<span>def <span class="ident">keyssorted</span></span>(<span>self, reverse=True)</span>
</code></dt>
<dd>
<div class="desc"><p>sort keys by length()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keyssorted(self,reverse=True):
    &#34;&#34;&#34; sort keys by length() &#34;&#34;&#34;
    klist = self.keys()
    l = [len(k) for k in klist]
    return [k for _,k in sorted(zip(l,klist),reverse=reverse)]</code></pre>
</details>
</dd>
<dt id="mstruct.struct.np2str"><code class="name flex">
<span>def <span class="ident">np2str</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert all NumPy entries of s into their string representations, handling both lists and dictionaries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def np2str(self):
    &#34;&#34;&#34; Convert all NumPy entries of s into their string representations, handling both lists and dictionaries. &#34;&#34;&#34;
    out = struct()
    def format_numpy_result(value):
        &#34;&#34;&#34;
        Converts a NumPy array or scalar into a string representation:
        - Scalars and single-element arrays (any number of dimensions) are returned as scalars without brackets.
        - Arrays with more than one element are formatted with proper nesting and commas to make them valid `np.array()` inputs.
        - If the value is a list or dict, the conversion is applied recursively.
        - Non-ndarray inputs that are not list/dict are returned without modification.

        Args:
            value (np.ndarray, scalar, list, dict, or other): The value to format.

        Returns:
            str, list, dict, or original type: A properly formatted string for NumPy arrays/scalars,
            a recursively converted list/dict, or the original value.
        &#34;&#34;&#34;
        if isinstance(value, dict):
            # Recursively process each key in the dictionary.
            new_dict = {}
            for k, v in value.items():
                new_dict[k] = format_numpy_result(v)
            return new_dict
        elif isinstance(value, list):
            # Recursively process each element in the list.
            return [format_numpy_result(x) for x in value]
        elif isinstance(value, tuple):
            return tuple(format_numpy_result(x) for x in value)
        elif isinstance(value, struct):
            return value.npstr()
        elif np.isscalar(value):
            # For scalars: if numeric, use str() to avoid extra quotes.
            if isinstance(value, (int, float, complex, str)) or value is None:
                return value
            else:
                return repr(value)
        elif isinstance(value, np.ndarray):
            # Check if the array has exactly one element.
            if value.size == 1:
                # Extract the scalar value.
                return repr(value.item())
            # Convert the array to a nested list.
            nested_list = value.tolist()
            # Recursively format the nested list into a valid string.
            def list_to_string(lst):
                if isinstance(lst, list):
                    return &#34;[&#34; + &#34;,&#34;.join(list_to_string(item) for item in lst) + &#34;]&#34;
                else:
                    return repr(lst)
            return list_to_string(nested_list)
        else:
            # Return the input unmodified if not a NumPy array, list, dict, or scalar.
            return str(value) # str() preferred over repr() for concision
    # Process all entries in self.
    for key, value in self.items():
        out.setattr(key, format_numpy_result(value))
    return out</code></pre>
</details>
</dd>
<dt id="mstruct.struct.numrepl"><code class="name flex">
<span>def <span class="ident">numrepl</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace all placeholders of the form ${key} in the given text by the corresponding
numeric value from the instance fields, under the following conditions:</p>
<ol>
<li>'key' must be a valid field in self (i.e., if key in self).</li>
<li>The value corresponding to 'key' is either:<ul>
<li>an int,</li>
<li>a float, or</li>
<li>a string that represents a valid number (e.g., "1" or "1.0").</li>
</ul>
</li>
</ol>
<p>Only when these conditions are met, the placeholder is substituted.
The conversion preserves the original type: if the stored value is int, then the
substitution will be done as an integer (e.g., 1 and not 1.0). Otherwise, if it is
a float then it will be substituted as a float.</p>
<p>Any placeholder for which the above conditions are not met remains unchanged.</p>
<p>Placeholders are recognized by the pattern "${<key>}" where <key> is captured as all
text until the next "}" (optionally allowing whitespace inside the braces).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numrepl(self, text):
    r&#34;&#34;&#34;
    Replace all placeholders of the form ${key} in the given text by the corresponding
    numeric value from the instance fields, under the following conditions:

    1. &#39;key&#39; must be a valid field in self (i.e., if key in self).
    2. The value corresponding to &#39;key&#39; is either:
         - an int,
         - a float, or
         - a string that represents a valid number (e.g., &#34;1&#34; or &#34;1.0&#34;).

    Only when these conditions are met, the placeholder is substituted.
    The conversion preserves the original type: if the stored value is int, then the
    substitution will be done as an integer (e.g., 1 and not 1.0). Otherwise, if it is
    a float then it will be substituted as a float.

    Any placeholder for which the above conditions are not met remains unchanged.

    Placeholders are recognized by the pattern &#34;${&lt;key&gt;}&#34; where &lt;key&gt; is captured as all
    text until the next &#34;}&#34; (optionally allowing whitespace inside the braces).
    &#34;&#34;&#34;
    # Pattern: match &#34;${&#34;, then optional whitespace, capture all characters until &#34;}&#34;,
    # then optional whitespace, then &#34;}&#34;.
    placeholder_pattern = re.compile(r&#34;\$\{\s*([^}]+?)\s*\}&#34;)

    def replace_match(match):
        key = match.group(1)
        # Check if the key exists in self.
        if key in self:
            value = self[key]
            # If the value is already numeric, substitute directly.
            if isinstance(value, (int, float)):
                return str(value)
            # If the value is a string, try to interpret it as a numeric value.
            elif isinstance(value, str):
                s = value.strip()
                # Check if s is a valid integer representation.
                if re.fullmatch(r&#34;[+-]?\d+&#34;, s):
                    try:
                        num = int(s)
                        return str(num)
                    except ValueError:
                        # Should not occur because the regex already matched.
                        return match.group(0)
                # Check if s is a valid float representation (including scientific notation).
                elif re.fullmatch(r&#34;[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?&#34;, s):
                    try:
                        num = float(s)
                        return str(num)
                    except ValueError:
                        return match.group(0)
        # If key not in self or value is not numeric (or numeric string), leave placeholder intact.
        return match.group(0)

    # Replace all placeholders in the text using the replacer function.
    return placeholder_pattern.sub(replace_match, text)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>initialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self,**kwargs):
    &#34;&#34;&#34; initialization &#34;&#34;&#34;
    self.__dict__.update(kwargs)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.setattr"><code class="name flex">
<span>def <span class="ident">setattr</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>set field and value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setattr(self,key,value):
    &#34;&#34;&#34; set field and value &#34;&#34;&#34;
    if isinstance(value,list) and len(value)==0 and key in self:
        delattr(self, key)
    else:
        self.__dict__[key] = value</code></pre>
</details>
</dd>
<dt id="mstruct.struct.sortdefinitions"><code class="name flex">
<span>def <span class="ident">sortdefinitions</span></span>(<span>self, raiseerror=True, silentmode=False)</span>
</code></dt>
<dd>
<div class="desc"><p>sortdefintions sorts all definitions
so that they can be executed as param().
If any inconsistency is found, an error message is generated.</p>
<p>Flags = default values
raiseerror=True show erros of True
silentmode=False no warning if True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortdefinitions(self,raiseerror=True,silentmode=False):
    &#34;&#34;&#34; sortdefintions sorts all definitions
        so that they can be executed as param().
        If any inconsistency is found, an error message is generated.

        Flags = default values
            raiseerror=True show erros of True
            silentmode=False no warning if True
    &#34;&#34;&#34;
    find = lambda xlist: [i for i, x in enumerate(xlist) if x]
    findnot = lambda xlist: [i for i, x in enumerate(xlist) if not x]
    k,v,isexpr =  self.keys(), self.values(), self.isexpression.values()
    istatic = findnot(isexpr)
    idynamic = find(isexpr)
    static = struct.fromkeysvalues(
        [ k[i] for i in istatic ],
        [ v[i] for i in istatic ],
        makeparam = False)
    dynamic = struct.fromkeysvalues(
        [ k[i] for i in idynamic ],
        [ v[i] for i in idynamic ],
        makeparam=False)
    current = static # make static the current structure
    nmissing, anychange, errorfound = len(dynamic), False, False
    while nmissing:
        itst, found = 0, False
        while itst&lt;nmissing and not found:
            teststruct = current + dynamic[[itst]] # add the test field
            found = all(list(teststruct.isdefined()))
            ifound = itst
            itst += 1
        if found:
            current = teststruct # we accept the new field
            dynamic[ifound] = []
            nmissing -= 1
            anychange = True
        else:
            if raiseerror:
                raise KeyError(&#39;unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                               (nmissing,len(self),self._ftype))
            else:
                if (not errorfound) and (not silentmode):
                    print(&#39;WARNING: unable to interpret %d/%d expressions in &#34;%ss&#34;&#39; % \
                          (nmissing,len(self),self._ftype))
                current = teststruct # we accept the new field (even if it cannot be interpreted)
                dynamic[ifound] = []
                nmissing -= 1
                errorfound = True
    if anychange:
        self.clear() # reset all fields and assign them in the proper order
        k,v = current.keys(), current.values()
        for i in range(len(k)):
            self.setattr(k[i],v[i])</code></pre>
</details>
</dd>
<dt id="mstruct.struct.struct2dict"><code class="name flex">
<span>def <span class="ident">struct2dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create a dictionary from the current structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2dict(self):
    &#34;&#34;&#34; create a dictionary from the current structure &#34;&#34;&#34;
    return dict(self.zip())</code></pre>
</details>
</dd>
<dt id="mstruct.struct.struct2param"><code class="name flex">
<span>def <span class="ident">struct2param</span></span>(<span>self, protection=False, evaluation=True)</span>
</code></dt>
<dd>
<div class="desc"><p>convert an object struct() to param()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def struct2param(self,protection=False,evaluation=True):
    &#34;&#34;&#34; convert an object struct() to param() &#34;&#34;&#34;
    p = param(**self.struct2dict())
    for i in range(len(self)):
        if isinstance(self[i],pstr): p[i] = pstr(p[i])
    p._protection = protection
    p._evaluation = evaluation
    return p</code></pre>
</details>
</dd>
<dt id="mstruct.struct.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Update multiple fields at once, while protecting certain attributes.</p>
<h2 id="parameters">Parameters:</h2>
<p>**kwargs : dict
The fields to update and their new values.</p>
<p>Protected attributes defined in _excludedattr are not updated.</p>
<h2 id="usage">Usage:</h2>
<p>s.update(a=10, b=[1, 2, 3], new_field="new_value")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, **kwargs):
    &#34;&#34;&#34;
    Update multiple fields at once, while protecting certain attributes.

    Parameters:
    -----------
    **kwargs : dict
        The fields to update and their new values.

    Protected attributes defined in _excludedattr are not updated.

    Usage:
    ------
    s.update(a=10, b=[1, 2, 3], new_field=&#34;new_value&#34;)
    &#34;&#34;&#34;
    protected_attributes = getattr(self, &#39;_excludedattr&#39;, ())
    for key, value in kwargs.items():
        if key in protected_attributes:
            print(f&#34;Warning: Cannot update protected attribute &#39;{key}&#39;&#34;)
        else:
            self.setattr(key, value)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.validkeys"><code class="name flex">
<span>def <span class="ident">validkeys</span></span>(<span>self, list_of_keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate and return the subset of keys from the provided list that are valid in the instance.</p>
<h2 id="parameters">Parameters:</h2>
<p>list_of_keys : list
A list of keys (as strings) to check against the instance’s attributes.</p>
<h2 id="returns">Returns:</h2>
<p>list
A list of keys from list_of_keys that are valid (i.e., exist as attributes in the instance).</p>
<h2 id="raises">Raises:</h2>
<p>TypeError
If list_of_keys is not a list or if any element in list_of_keys is not a string.</p>
<h2 id="example">Example:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; s = struct()
&gt;&gt;&gt; s.foo = 42
&gt;&gt;&gt; s.bar = &quot;hello&quot;
&gt;&gt;&gt; valid = s.validkeys([&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;])
&gt;&gt;&gt; print(valid)   # Output: ['foo', 'bar'] assuming 'baz' is not defined in s
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validkeys(self, list_of_keys):
    &#34;&#34;&#34;
    Validate and return the subset of keys from the provided list that are valid in the instance.

    Parameters:
    -----------
    list_of_keys : list
        A list of keys (as strings) to check against the instance’s attributes.

    Returns:
    --------
    list
        A list of keys from list_of_keys that are valid (i.e., exist as attributes in the instance).

    Raises:
    -------
    TypeError
        If list_of_keys is not a list or if any element in list_of_keys is not a string.

    Example:
    --------
    &gt;&gt;&gt; s = struct()
    &gt;&gt;&gt; s.foo = 42
    &gt;&gt;&gt; s.bar = &#34;hello&#34;
    &gt;&gt;&gt; valid = s.validkeys([&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;])
    &gt;&gt;&gt; print(valid)   # Output: [&#39;foo&#39;, &#39;bar&#39;] assuming &#39;baz&#39; is not defined in s
    &#34;&#34;&#34;
    # Check that list_of_keys is a list
    if not isinstance(list_of_keys, list):
        raise TypeError(&#34;list_of_keys must be a list&#34;)

    # Check that every entry in the list is a string
    for key in list_of_keys:
        if not isinstance(key, str):
            raise TypeError(&#34;Each key in list_of_keys must be a string&#34;)

    # Assuming valid keys are those present in the instance&#39;s __dict__
    return [key for key in list_of_keys if key in self]</code></pre>
</details>
</dd>
<dt id="mstruct.struct.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34; return the values &#34;&#34;&#34;
    # values() is used by struct() and its iterator
    return [pstr.eval(value) for key,value in self.__dict__.items() if key not in self._excludedattr]</code></pre>
</details>
</dd>
<dt id="mstruct.struct.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, overwrite=True, mkdir=False)</span>
</code></dt>
<dd>
<div class="desc"><p>write the equivalent structure (not recursive for nested struct)
write(filename, overwrite=True, mkdir=False)</p>
<p>Parameters:
- file: The file path to write to.
- overwrite: Whether to overwrite the file if it exists (default: True).
- mkdir: Whether to create the directory if it doesn't exist (default: False).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, overwrite=True, mkdir=False):
    &#34;&#34;&#34;
        write the equivalent structure (not recursive for nested struct)
            write(filename, overwrite=True, mkdir=False)

        Parameters:
        - file: The file path to write to.
        - overwrite: Whether to overwrite the file if it exists (default: True).
        - mkdir: Whether to create the directory if it doesn&#39;t exist (default: False).
    &#34;&#34;&#34;
    # Create a Path object for the file to handle cross-platform paths
    file_path = Path(file).resolve()

    # Check if the directory exists or if mkdir is set to True, create it
    if mkdir:
        file_path.parent.mkdir(parents=True, exist_ok=True)
    elif not file_path.parent.exists():
        raise FileNotFoundError(f&#34;The directory {file_path.parent} does not exist.&#34;)
    # If overwrite is False and the file already exists, raise an exception
    if not overwrite and file_path.exists():
        raise FileExistsError(f&#34;The file {file_path} already exists, and overwrite is set to False.&#34;)
    # Convert to static if needed
    if isinstance(p,(param,paramauto)):
        tmp = self.tostatic()
    else:
        tmp = self
    # Open and write to the file using the resolved path
    with file_path.open(mode=&#34;w&#34;, encoding=&#39;utf-8&#39;) as f:
        print(f&#34;# {self._fulltype} with {len(self)} {self._ftype}s\n&#34;, file=f)
        for k, v in tmp.items():
            if v is None:
                print(k, &#34;=None&#34;, file=f, sep=&#34;&#34;)
            elif isinstance(v, (int, float)):
                print(k, &#34;=&#34;, v, file=f, sep=&#34;&#34;)
            elif isinstance(v, str):
                print(k, &#39;=&#34;&#39;, v, &#39;&#34;&#39;, file=f, sep=&#34;&#34;)
            else:
                print(k, &#34;=&#34;, str(v), file=f, sep=&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="mstruct.struct.zip"><code class="name flex">
<span>def <span class="ident">zip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>zip keys and values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zip(self):
    &#34;&#34;&#34; zip keys and values &#34;&#34;&#34;
    return zip(self.keys(),self.values())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#module-structpy">Module: struct.py</a><ul>
<li><a href="#purpose">Purpose</a></li>
<li><a href="#key-features">Key Features</a></li>
<li><a href="#evaluation-features">Evaluation Features</a></li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#basic-struct-usage">Basic Struct Usage</a></li>
<li><a href="#parameter-evaluation-with-param">Parameter Evaluation with param</a></li>
<li><a href="#path-management-with-pstr">Path Management with pstr</a></li>
<li><a href="#automatic-dependency-handling-with-paramauto">Automatic Dependency Handling with paramauto</a></li>
<li><a href="#evaluation-usage">Evaluation Usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mstruct.evaluate_with_placeholders" href="#mstruct.evaluate_with_placeholders">evaluate_with_placeholders</a></code></li>
<li><code><a title="mstruct.is_empty" href="#mstruct.is_empty">is_empty</a></code></li>
<li><code><a title="mstruct.is_literal_string" href="#mstruct.is_literal_string">is_literal_string</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mstruct.AttrErrorDict" href="#mstruct.AttrErrorDict">AttrErrorDict</a></code></h4>
</li>
<li>
<h4><code><a title="mstruct.SafeEvaluator" href="#mstruct.SafeEvaluator">SafeEvaluator</a></code></h4>
<ul class="two-column">
<li><code><a title="mstruct.SafeEvaluator.evaluate" href="#mstruct.SafeEvaluator.evaluate">evaluate</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.generic_visit" href="#mstruct.SafeEvaluator.generic_visit">generic_visit</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Attribute" href="#mstruct.SafeEvaluator.visit_Attribute">visit_Attribute</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_BinOp" href="#mstruct.SafeEvaluator.visit_BinOp">visit_BinOp</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Call" href="#mstruct.SafeEvaluator.visit_Call">visit_Call</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Constant" href="#mstruct.SafeEvaluator.visit_Constant">visit_Constant</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Dict" href="#mstruct.SafeEvaluator.visit_Dict">visit_Dict</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_ExtSlice" href="#mstruct.SafeEvaluator.visit_ExtSlice">visit_ExtSlice</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Index" href="#mstruct.SafeEvaluator.visit_Index">visit_Index</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_List" href="#mstruct.SafeEvaluator.visit_List">visit_List</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Name" href="#mstruct.SafeEvaluator.visit_Name">visit_Name</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Slice" href="#mstruct.SafeEvaluator.visit_Slice">visit_Slice</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Subscript" href="#mstruct.SafeEvaluator.visit_Subscript">visit_Subscript</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_Tuple" href="#mstruct.SafeEvaluator.visit_Tuple">visit_Tuple</a></code></li>
<li><code><a title="mstruct.SafeEvaluator.visit_UnaryOp" href="#mstruct.SafeEvaluator.visit_UnaryOp">visit_UnaryOp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mstruct.param" href="#mstruct.param">param</a></code></h4>
<ul class="">
<li><code><a title="mstruct.param.convert_matlab_like_arrays" href="#mstruct.param.convert_matlab_like_arrays">convert_matlab_like_arrays</a></code></li>
<li><code><a title="mstruct.param.escape" href="#mstruct.param.escape">escape</a></code></li>
<li><code><a title="mstruct.param.eval" href="#mstruct.param.eval">eval</a></code></li>
<li><code><a title="mstruct.param.expand_ranges" href="#mstruct.param.expand_ranges">expand_ranges</a></code></li>
<li><code><a title="mstruct.param.formateval" href="#mstruct.param.formateval">formateval</a></code></li>
<li><code><a title="mstruct.param.getval" href="#mstruct.param.getval">getval</a></code></li>
<li><code><a title="mstruct.param.protect" href="#mstruct.param.protect">protect</a></code></li>
<li><code><a title="mstruct.param.replace_matrix_shorthand" href="#mstruct.param.replace_matrix_shorthand">replace_matrix_shorthand</a></code></li>
<li><code><a title="mstruct.param.safe_fstring" href="#mstruct.param.safe_fstring">safe_fstring</a></code></li>
<li><code><a title="mstruct.param.toparamauto" href="#mstruct.param.toparamauto">toparamauto</a></code></li>
<li><code><a title="mstruct.param.tostatic" href="#mstruct.param.tostatic">tostatic</a></code></li>
<li><code><a title="mstruct.param.tostruct" href="#mstruct.param.tostruct">tostruct</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mstruct.paramauto" href="#mstruct.paramauto">paramauto</a></code></h4>
</li>
<li>
<h4><code><a title="mstruct.pstr" href="#mstruct.pstr">pstr</a></code></h4>
<ul class="">
<li><code><a title="mstruct.pstr.eval" href="#mstruct.pstr.eval">eval</a></code></li>
<li><code><a title="mstruct.pstr.topath" href="#mstruct.pstr.topath">topath</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mstruct.struct" href="#mstruct.struct">struct</a></code></h4>
<ul class="two-column">
<li><code><a title="mstruct.struct.check" href="#mstruct.struct.check">check</a></code></li>
<li><code><a title="mstruct.struct.clear" href="#mstruct.struct.clear">clear</a></code></li>
<li><code><a title="mstruct.struct.dict2struct" href="#mstruct.struct.dict2struct">dict2struct</a></code></li>
<li><code><a title="mstruct.struct.disp" href="#mstruct.struct.disp">disp</a></code></li>
<li><code><a title="mstruct.struct.dispmax" href="#mstruct.struct.dispmax">dispmax</a></code></li>
<li><code><a title="mstruct.struct.format" href="#mstruct.struct.format">format</a></code></li>
<li><code><a title="mstruct.struct.format_array" href="#mstruct.struct.format_array">format_array</a></code></li>
<li><code><a title="mstruct.struct.format_legacy" href="#mstruct.struct.format_legacy">format_legacy</a></code></li>
<li><code><a title="mstruct.struct.fromkeys" href="#mstruct.struct.fromkeys">fromkeys</a></code></li>
<li><code><a title="mstruct.struct.fromkeysvalues" href="#mstruct.struct.fromkeysvalues">fromkeysvalues</a></code></li>
<li><code><a title="mstruct.struct.generator" href="#mstruct.struct.generator">generator</a></code></li>
<li><code><a title="mstruct.struct.getattr" href="#mstruct.struct.getattr">getattr</a></code></li>
<li><code><a title="mstruct.struct.hasattr" href="#mstruct.struct.hasattr">hasattr</a></code></li>
<li><code><a title="mstruct.struct.importfrom" href="#mstruct.struct.importfrom">importfrom</a></code></li>
<li><code><a title="mstruct.struct.isdefined" href="#mstruct.struct.isdefined">isdefined</a></code></li>
<li><code><a title="mstruct.struct.isempty" href="#mstruct.struct.isempty">isempty</a></code></li>
<li><code><a title="mstruct.struct.isexpression" href="#mstruct.struct.isexpression">isexpression</a></code></li>
<li><code><a title="mstruct.struct.isstrdefined" href="#mstruct.struct.isstrdefined">isstrdefined</a></code></li>
<li><code><a title="mstruct.struct.isstrexpression" href="#mstruct.struct.isstrexpression">isstrexpression</a></code></li>
<li><code><a title="mstruct.struct.items" href="#mstruct.struct.items">items</a></code></li>
<li><code><a title="mstruct.struct.keys" href="#mstruct.struct.keys">keys</a></code></li>
<li><code><a title="mstruct.struct.keyssorted" href="#mstruct.struct.keyssorted">keyssorted</a></code></li>
<li><code><a title="mstruct.struct.np2str" href="#mstruct.struct.np2str">np2str</a></code></li>
<li><code><a title="mstruct.struct.numrepl" href="#mstruct.struct.numrepl">numrepl</a></code></li>
<li><code><a title="mstruct.struct.read" href="#mstruct.struct.read">read</a></code></li>
<li><code><a title="mstruct.struct.scan" href="#mstruct.struct.scan">scan</a></code></li>
<li><code><a title="mstruct.struct.set" href="#mstruct.struct.set">set</a></code></li>
<li><code><a title="mstruct.struct.setattr" href="#mstruct.struct.setattr">setattr</a></code></li>
<li><code><a title="mstruct.struct.sortdefinitions" href="#mstruct.struct.sortdefinitions">sortdefinitions</a></code></li>
<li><code><a title="mstruct.struct.struct2dict" href="#mstruct.struct.struct2dict">struct2dict</a></code></li>
<li><code><a title="mstruct.struct.struct2param" href="#mstruct.struct.struct2param">struct2param</a></code></li>
<li><code><a title="mstruct.struct.update" href="#mstruct.struct.update">update</a></code></li>
<li><code><a title="mstruct.struct.validkeys" href="#mstruct.struct.validkeys">validkeys</a></code></li>
<li><code><a title="mstruct.struct.values" href="#mstruct.struct.values">values</a></code></li>
<li><code><a title="mstruct.struct.write" href="#mstruct.struct.write">write</a></code></li>
<li><code><a title="mstruct.struct.zip" href="#mstruct.struct.zip">zip</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>